<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ DDOO Action Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi-filters/5.2.1/pixi-filters.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="background-3d.js?v=3"></script>
    <!-- DDOO Action Engine v3.2 + Î™®Îìà -->
    <script src="ddoo-utils.js?v=3"></script>
    <script src="ddoo-draw.js?v=4"></script>
    <script src="ddoo-action.js?v=36"></script>
    <script src="ddoo-vfx-3d.js?v=3"></script>
    <!-- üéÅ Î≤àÎì§ (fetch ÏóÜÏù¥ Ï¶âÏãú Î°úÎìú!) -->
    <script src="anim-bundle.js?v=18"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        .header {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            border-bottom: 2px solid #fbbf24;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        .header h1 {
            font-family: 'Cinzel', serif;
            color: #fbbf24;
            font-size: 1.2rem;
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
        }
        .header-btn {
            background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%);
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
        }
        .main-container {
            display: flex;
            height: 100vh;
            padding-top: 50px;
        }
        .control-panel {
            width: 280px;
            background: #0f0f18;
            border-right: 1px solid #2a2a3a;
            overflow-y: auto;
            padding: 12px;
        }
        .panel-section {
            background: #1a1a28;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .panel-section h3 {
            color: #fbbf24;
            font-size: 0.85rem;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3a3a5a;
        }
        .anim-list { display: flex; flex-direction: column; gap: 4px; }
        .anim-item {
            background: #252535;
            border: 1px solid #3a3a5a;
            padding: 8px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }
        .anim-item:hover { background: #353550; border-color: #60a5fa; }
        .anim-item.playing { background: #1e3a5f; border-color: #60a5fa; }
        .anim-item .type {
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: bold;
        }
        .anim-item .type.player { background: #3b82f6; }
        .anim-item .type.enemy { background: #ef4444; }
        .anim-item .type.card { background: #a855f7; }
        .anim-item .name { flex: 1; }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .speed-control label { color: #888; font-size: 0.75rem; }
        .speed-control input { flex: 1; }
        .speed-control .value { color: #60a5fa; font-size: 0.75rem; }
        
        /* ÌÉ≠ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò */
        .panel-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
            background: #0a0a12;
            padding: 4px;
            border-radius: 6px;
        }
        .panel-tab {
            flex: 1;
            background: #1a1a28;
            border: 1px solid #2a2a4a;
            padding: 8px 4px;
            border-radius: 4px;
            color: #888;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            transition: all 0.15s;
        }
        .panel-tab:hover { background: #252538; color: #ccc; }
        .panel-tab.active { 
            background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
            color: #fff; 
            border-color: #60a5fa;
        }
        .tab-content { max-height: calc(100vh - 380px); overflow-y: auto; }
        
        /* Draw ÏÑ§Ï†ï */
        .draw-settings { display: flex; flex-direction: column; gap: 8px; }
        .setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .setting-row label { 
            color: #888; 
            font-size: 0.7rem; 
            min-width: 45px;
        }
        .setting-row input[type="color"] {
            width: 40px;
            height: 24px;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }
        .setting-row input[type="range"] { flex: 1; }
        .setting-row .value { 
            color: #60a5fa; 
            font-size: 0.7rem; 
            min-width: 40px;
            text-align: right;
        }
        
        /* VFX/Draw ÏïÑÏù¥ÌÖú ÌÉÄÏûÖ Î∞∞ÏßÄ */
        .anim-item .type.vfx { background: #a855f7; }
        .anim-item .type.draw { background: #f472b6; }
        .anim-item .type.particle { background: #06b6d4; }
        .anim-item .type.effect-3d { 
            background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%); 
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .stage-container {
            flex: 1;
            position: relative;
            background: #0a0a12;
            overflow: hidden;
        }
        #pixiContainer { 
            width: 100%; 
            height: 100%;
            position: relative;
        }
        #bg3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        #pixiContainer canvas {
            position: relative;
            z-index: 1;
        }
        #vfxCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .stage-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #3a3a5a;
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.7rem;
            z-index: 20;
        }
        .stat-row { display: flex; justify-content: space-between; gap: 15px; color: #666; margin-bottom: 2px; }
        .stat-row .value { color: #60a5fa; }
        .log-panel {
            width: 260px;
            background: #0f0f18;
            border-left: 1px solid #2a2a3a;
            display: flex;
            flex-direction: column;
        }
        .log-header {
            padding: 8px 12px;
            background: #1a1a28;
            border-bottom: 1px solid #2a2a4a;
            font-size: 0.8rem;
            color: #fbbf24;
            display: flex;
            justify-content: space-between;
        }
        .log-header button {
            background: #3a3a5a;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            color: #888;
            cursor: pointer;
            font-size: 0.65rem;
        }
        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-family: monospace;
            font-size: 0.7rem;
        }
        .log-entry { padding: 3px 0; border-bottom: 1px solid #1a1a2a; }
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #34d399; }
        .log-entry.warn { color: #fbbf24; }
        .log-entry.error { color: #ef4444; }
        .log-entry.anim { color: #a78bfa; }
        .log-entry.vfx { color: #f472b6; }
        .log-time { color: #444; margin-right: 5px; }
        
        /* ==================== ÌÉÄÏûÑÎùºÏù∏ Ìå®ÎÑê (Í∞úÏÑ†) ==================== */
        .timeline-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 240px;
            background: #0a0a12;
            border-top: 2px solid #fbbf24;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: height 0.2s ease;
        }
        .timeline-panel.collapsed { height: 32px; }
        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 12px;
            background: linear-gradient(180deg, #1a1a2e 0%, #12121f 100%);
            border-bottom: 1px solid #2a2a4a;
            min-height: 32px;
        }
        .timeline-header h3 { color: #fbbf24; font-size: 0.75rem; margin: 0; display: flex; align-items: center; gap: 8px; }
        .timeline-header h3 .anim-name { color: #60a5fa; font-weight: normal; }
        .timeline-controls { display: flex; gap: 6px; align-items: center; }
        .timeline-btn {
            background: #2a2a4a;
            border: 1px solid #3a3a5a;
            padding: 3px 8px;
            border-radius: 3px;
            color: #ccc;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.1s;
        }
        .timeline-btn:hover { background: #3a3a5a; border-color: #60a5fa; }
        .timeline-btn.active { background: #3b82f6; color: #fff; border-color: #60a5fa; }
        .timeline-btn.play { background: #22c55e; color: #000; border-color: #4ade80; }
        .timeline-btn.play:hover { background: #16a34a; }
        .timeline-time { font-family: 'Consolas', monospace; color: #60a5fa; font-size: 0.75rem; min-width: 100px; text-align: right; }
        .timeline-body { flex: 1; display: flex; overflow: hidden; }
        .timeline-tracks {
            width: 100px;
            background: #0d0d18;
            border-right: 1px solid #2a2a4a;
            flex-shrink: 0;
            overflow-y: auto;
        }
        .timeline-track-header {
            height: 26px;
            padding: 0 8px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #1a1a2a;
            font-size: 0.65rem;
            color: #666;
            gap: 4px;
        }
        .timeline-track-header .icon { font-size: 0.7rem; }
        .timeline-track-header.player { color: #60a5fa; }
        .timeline-track-header.enemy { color: #ef4444; }
        .timeline-track-header.vfx { color: #a855f7; }
        .timeline-track-header.camera { color: #06b6d4; }
        .timeline-track-header.effects { color: #f59e0b; }
        .timeline-track-header.damage { color: #ef4444; }
        .timeline-content {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            cursor: grab;
        }
        .timeline-content:active { cursor: grabbing; }
        .timeline-ruler {
            height: 22px;
            background: #12121f;
            border-bottom: 1px solid #2a2a4a;
            position: sticky;
            top: 0;
            z-index: 50;
        }
        .timeline-ruler-mark {
            position: absolute;
            top: 0;
            height: 100%;
            border-left: 1px solid #252535;
            font-size: 0.55rem;
            color: #444;
            padding-left: 2px;
            padding-top: 1px;
            user-select: none;
        }
        .timeline-ruler-mark.major { border-color: #3a3a5a; color: #666; }
        .timeline-lanes { position: relative; min-height: 156px; }
        .timeline-lane {
            height: 26px;
            border-bottom: 1px solid #151520;
            position: relative;
        }
        .timeline-lane:nth-child(odd) { background: rgba(255,255,255,0.01); }
        .timeline-keyframe {
            position: absolute;
            height: 20px;
            top: 3px;
            border-radius: 2px;
            font-size: 0.55rem;
            display: flex;
            align-items: center;
            padding: 0 3px;
            cursor: pointer;
            overflow: hidden;
            white-space: nowrap;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .timeline-keyframe:hover { transform: translateY(-1px); box-shadow: 0 2px 6px rgba(0,0,0,0.5); z-index: 10; }
        .timeline-keyframe.player { background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%); border: 1px solid #60a5fa; }
        .timeline-keyframe.enemy { background: linear-gradient(180deg, #ef4444 0%, #b91c1c 100%); border: 1px solid #f87171; }
        .timeline-keyframe.vfx { background: linear-gradient(180deg, #a855f7 0%, #7c3aed 100%); border: 1px solid #c084fc; }
        .timeline-keyframe.camera { background: linear-gradient(180deg, #06b6d4 0%, #0891b2 100%); border: 1px solid #22d3ee; }
        .timeline-keyframe.shake { background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%); border: 1px solid #fbbf24; }
        .timeline-keyframe.hitstop { background: linear-gradient(180deg, #10b981 0%, #059669 100%); border: 1px solid #34d399; }
        .timeline-keyframe.slowmo { background: linear-gradient(180deg, #8b5cf6 0%, #6d28d9 100%); border: 1px solid #a78bfa; }
        .timeline-keyframe.color { background: linear-gradient(180deg, #ec4899 0%, #be185d 100%); border: 1px solid #f472b6; }
        .timeline-keyframe.damage { background: linear-gradient(180deg, #dc2626 0%, #991b1b 100%); border: 1px solid #f87171; }
        .timeline-keyframe.shatter { background: linear-gradient(180deg, #14b8a6 0%, #0d9488 100%); border: 1px solid #2dd4bf; }
        .timeline-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(239,68,68,0.6);
        }
        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -4px;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid #ef4444;
        }
        .timeline-empty { display: flex; align-items: center; justify-content: center; height: 100%; color: #444; font-size: 0.75rem; }
        .timeline-tooltip {
            position: fixed;
            background: #1a1a2e;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 0.65rem;
            color: #ddd;
            z-index: 2000;
            pointer-events: none;
            max-width: 250px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .timeline-tooltip .tt-title { color: #fbbf24; font-weight: bold; margin-bottom: 4px; }
        .timeline-tooltip .tt-row { display: flex; gap: 8px; color: #999; }
        .timeline-tooltip .tt-row span:first-child { color: #666; min-width: 50px; }
        /* Î©îÏù∏ Ïª®ÌÖåÏù¥ÎÑà ÎÜíÏù¥ Ï°∞Ï†ï */
        .main-container { height: calc(100vh - 240px); transition: height 0.2s ease; }
        .main-container.timeline-collapsed { height: calc(100vh - 32px); }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéÆ DDOO Action Studio v1.0</h1>
        <button class="header-btn" onclick="location.href='index.html'">üéÆ Í≤åÏûÑÏúºÎ°ú</button>
    </div>
    
    <div class="main-container">
        <div class="control-panel">
            <!-- ÌÉ≠ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò -->
            <div class="panel-tabs">
                <button class="panel-tab active" data-tab="anim" onclick="switchTab('anim')">üé¨ Anim</button>
                <button class="panel-tab" data-tab="vfx" onclick="switchTab('vfx')">‚ú® VFX</button>
                <button class="panel-tab" data-tab="draw" onclick="switchTab('draw')">üé® Draw</button>
            </div>
            
            <!-- Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉ≠ -->
            <div class="tab-content" id="tab-anim">
                <div class="panel-section">
                    <h3>üìÅ Animations</h3>
                    <div id="animList" class="anim-list"></div>
                </div>
            </div>
            
            <!-- VFX ÌÉ≠ -->
            <div class="tab-content" id="tab-vfx" style="display:none;">
                <div class="panel-section">
                    <h3>‚ú® VFX Effects</h3>
                    <div id="vfxList" class="anim-list"></div>
                </div>
            </div>
            
            <!-- Draw ÌÉ≠ -->
            <div class="tab-content" id="tab-draw" style="display:none;">
                <div class="panel-section">
                    <h3>üé® Draw Particles</h3>
                    <div id="drawList" class="anim-list"></div>
                </div>
                <div class="panel-section">
                    <h3>üéõÔ∏è Draw Settings</h3>
                    <div class="draw-settings">
                        <div class="setting-row">
                            <label>Color</label>
                            <input type="color" id="drawColor" value="#60a5fa">
                        </div>
                        <div class="setting-row">
                            <label>Glow</label>
                            <input type="color" id="drawGlow" value="#3b82f6">
                        </div>
                        <div class="setting-row">
                            <label>Size</label>
                            <input type="range" id="drawSize" min="50" max="300" value="150">
                            <span class="value" id="drawSizeValue">150</span>
                        </div>
                        <div class="setting-row">
                            <label>Angle</label>
                            <input type="range" id="drawAngle" min="-180" max="180" value="-30">
                            <span class="value" id="drawAngleValue">-30¬∞</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ÏÑ§Ï†ï ÏÑπÏÖò (Í≥µÌÜµ) -->
            <div class="panel-section">
                <h3>‚öôÔ∏è Settings</h3>
                <div class="speed-control">
                    <label>Speed</label>
                    <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1" onchange="updateSpeed()">
                    <span class="value" id="speedValue">1.0x</span>
                </div>
            </div>
        </div>
        
        <div class="stage-container">
            <div id="pixiContainer"></div>
            <canvas id="vfxCanvas"></canvas>
            <div class="stage-overlay" id="statsOverlay">
                <div class="stat-row"><span>Player:</span><span class="value" id="playerPos">0, 0</span></div>
                <div class="stat-row"><span>Enemy:</span><span class="value" id="enemyPos">0, 0</span></div>
                <div class="stat-row"><span>FPS:</span><span class="value" id="fpsValue">60</span></div>
            </div>
        </div>
        
        <div class="log-panel">
            <div class="log-header">
                <span>üìú Log</span>
                <button onclick="clearLog()">Clear</button>
            </div>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>
    
    <!-- üé¨ ÌÉÄÏûÑÎùºÏù∏ Ìå®ÎÑê (Í∞úÏÑ†) -->
    <div class="timeline-panel" id="timelinePanel">
        <div class="timeline-header">
            <h3>üé¨ Timeline <span class="anim-name" id="tlAnimName"></span></h3>
            <div class="timeline-controls">
                <button class="timeline-btn play" id="tlPlayBtn" onclick="Timeline.togglePlay()">‚ñ∂</button>
                <button class="timeline-btn" onclick="Timeline.stop()">‚èπ</button>
                <button class="timeline-btn" onclick="Timeline.zoom(-0.1)">‚àí</button>
                <button class="timeline-btn" onclick="Timeline.zoom(0.1)">+</button>
                <span class="timeline-time" id="timelineTime">0.000s / 0.000s</span>
                <button class="timeline-btn" id="tlLoopBtn" onclick="Timeline.toggleLoop()">üîÅ</button>
                <button class="timeline-btn" id="tlToggleBtn" onclick="Timeline.toggle()">‚ñº</button>
            </div>
        </div>
        <div class="timeline-body">
            <div class="timeline-tracks">
                <div class="timeline-track-header player"><span class="icon">üéÆ</span>Player</div>
                <div class="timeline-track-header enemy"><span class="icon">üëπ</span>Enemy</div>
                <div class="timeline-track-header vfx"><span class="icon">‚ú®</span>VFX</div>
                <div class="timeline-track-header camera"><span class="icon">üì∑</span>Camera</div>
                <div class="timeline-track-header effects"><span class="icon">‚ö°</span>Effects</div>
                <div class="timeline-track-header damage"><span class="icon">üí•</span>Damage</div>
            </div>
            <div class="timeline-content" id="timelineContent">
                <div class="timeline-ruler" id="timelineRuler"></div>
                <div class="timeline-lanes" id="timelineLanes">
                    <div class="timeline-lane" id="playerLane"></div>
                    <div class="timeline-lane" id="enemyLane"></div>
                    <div class="timeline-lane" id="vfxLane"></div>
                    <div class="timeline-lane" id="cameraLane"></div>
                    <div class="timeline-lane" id="effectsLane"></div>
                    <div class="timeline-lane" id="damageLane"></div>
                </div>
                <div class="timeline-playhead" id="timelinePlayhead"></div>
            </div>
        </div>
    </div>
    <div class="timeline-tooltip" id="tlTooltip" style="display:none;"></div>

    <script>
        // ==================== Ï†ÑÏó≠ Î≥ÄÏàò ====================
        let app, vfxCanvas, vfxCtx;
        let playerContainer, playerSprite, enemyContainer, enemySprite;
        let stageContainer; // ÏâêÏù¥ÌÅ¨Ïö©
        
        // Îã§Ï§ë Ï†Å ÏßÄÏõê
        let enemies = [];  // [{container, sprite, baseX}]
        let currentTargetIndex = 0;
        
        const config = {
            speed: 1,
            playerBaseX: 0,
            enemyBaseX: 0,
            baseY: 0,
            // Ï∫êÎ¶≠ÌÑ∞ ÌÅ¨Í∏∞ Ï†ïÎ≥¥
            charHeight: 120,    // Í∏∞Î≥∏ Ï∫êÎ¶≠ÌÑ∞ ÎÜíÏù¥
            charWidth: 60,      // Í∏∞Î≥∏ Ï∫êÎ¶≠ÌÑ∞ ÎÑàÎπÑ
            vfxScale: 1.0,      // VFX Ïä§ÏºÄÏùº
            enemyCount: 3       // Ï†Å Ïàò
        };
        
        let animCache = new Map();
        let vfxCache = new Map();
        
        // ÎèôÏ†ÅÏúºÎ°ú index.jsonÏóêÏÑú Î°úÎìú
        let ANIM_FILES = [];
        let VFX_FILES = [];
        
        // VFX ÌååÌã∞ÌÅ¥ ÌíÄ
        const particles = [];
        let animationFrame = null;
        
        // ==================== Ï¥àÍ∏∞Ìôî ====================
        document.addEventListener('DOMContentLoaded', async () => {
            log('info', 'üéÆ DDOO Action Studio Ï¥àÍ∏∞Ìôî...');
            await initPixi();
            await loadAllVFX();
            await loadAllAnimations();
            renderAnimList();
            startVFXLoop();
            startUpdateLoop();
            log('success', '‚úÖ Ï§ÄÎπÑ ÏôÑÎ£å! Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.');
        });
        
        async function initPixi() {
            const container = document.getElementById('pixiContainer');
            const width = container.clientWidth || 900;
            const height = container.clientHeight || 600;
            
            // üé• 3D Î∞∞Í≤Ω Ï¥àÍ∏∞Ìôî (Background3D)
            if (typeof Background3D !== 'undefined') {
                log('info', 'üé• 3D Î∞∞Í≤Ω Ï¥àÍ∏∞Ìôî Ï§ë...');
                // Ïª®ÌÖåÏù¥ÎÑà ÏÑ§Ï†ï (pixiContainer ÏïàÏóê Î†åÎçîÎßÅ)
                Background3D.createContainer = function() {
                    const old = document.getElementById('bg3d');
                    if (old) old.remove();
                    
                    this.container = document.createElement('div');
                    this.container.id = 'bg3d';
                    this.container.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        z-index: 0;
                        pointer-events: none;
                    `;
                    container.appendChild(this.container);
                };
                
                await Background3D.init();
                Background3D.setAutoZoom(false);  // ÏûêÎèô Ï§å ÎπÑÌôúÏÑ±Ìôî
                log('success', '‚úÖ 3D Î∞∞Í≤Ω Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
            }
            
            app = new PIXI.Application({
                width, height,
                backgroundAlpha: 0,  // Ìà¨Î™Ö Î∞∞Í≤Ω (3D Î∞∞Í≤Ω Î≥¥Ïù¥Í≤å)
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            container.appendChild(app.view);
            app.view.style.position = 'relative';
            app.view.style.zIndex = '1';
            
            vfxCanvas = document.getElementById('vfxCanvas');
            vfxCanvas.width = width;
            vfxCanvas.height = height;
            vfxCtx = vfxCanvas.getContext('2d');
            
            // Ïä§ÌÖåÏù¥ÏßÄ Ïª®ÌÖåÏù¥ÎÑà (ÏâêÏù¥ÌÅ¨Ïö©)
            stageContainer = new PIXI.Container();
            stageContainer.sortableChildren = true;  // zIndex Ï†ïÎ†¨ ÌôúÏÑ±Ìôî!
            app.stage.addChild(stageContainer);
            
            // 3D Î∞∞Í≤ΩÏù¥ ÏóÜÏúºÎ©¥ Ìè¥Î∞± Î∞∞Í≤Ω Í∑∏Î¶¨Í∏∞
            if (typeof Background3D === 'undefined' || !Background3D.isInitialized) {
                drawBackground(width, height);
            }
            
            // DDOOAction ÏóîÏßÑ Ï¥àÍ∏∞Ìôî (Ïª®ÌÖåÏù¥ÎÑà/Ïï†ÎãàÎ©îÏù¥ÏÖò/VFX Î°úÎìú) - Ï∫êÎ¶≠ÌÑ∞ ÏÉùÏÑ± Ï†ÑÏóê!
            if (typeof DDOOAction !== 'undefined') {
                await DDOOAction.init(app, stageContainer);
                log('success', '‚úÖ DDOOAction ÏóîÏßÑ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
                
                // DDOOActionÏùò animCacheÎ•º test_animationÏóêÏÑúÎèÑ ÏÇ¨Ïö©
                animCache = DDOOAction.animCache;
                vfxCache = DDOOAction.vfxCache;
            }
            
            await createCharacters(width, height);
            
            log('info', `Stage: ${width}x${height}`);
            
            // üîÑ Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§Îü¨
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => handleResize(), 100);
            });
        }
        
        // üîÑ Î¶¨ÏÇ¨Ïù¥Ï¶à Ï≤òÎ¶¨
        function handleResize() {
            const container = document.getElementById('pixiContainer');
            if (!container || !app) return;
            
            const width = container.clientWidth || 900;
            const height = container.clientHeight || 600;
            
            // PixiJS Ï∫îÎ≤ÑÏä§ Î¶¨ÏÇ¨Ïù¥Ï¶à
            app.renderer.resize(width, height);
            
            // VFX Ï∫îÎ≤ÑÏä§ Î¶¨ÏÇ¨Ïù¥Ï¶à
            const vfxCanvas = document.getElementById('vfxCanvas');
            if (vfxCanvas) {
                vfxCanvas.width = width;
                vfxCanvas.height = height;
            }
            
            // Ï∫êÎ¶≠ÌÑ∞ ÏúÑÏπò Ïû¨Í≥ÑÏÇ∞
            const groundY = height * 0.75;
            config.baseY = groundY;
            config.playerBaseX = width * 0.22;
            const enemyStartX = width * 0.58;
            const enemySpacing = width * 0.12;
            
            // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
            if (playerContainer) {
                playerContainer.x = config.playerBaseX;
                playerContainer.y = groundY;
                
                const playerChar = DDOOAction?.characters?.get('player');
                if (playerChar) {
                    playerChar.baseX = config.playerBaseX;
                    playerChar.baseY = groundY;
                    if (playerChar.shadow) {
                        playerChar.shadow.x = config.playerBaseX;
                        playerChar.shadow.y = groundY + 5;
                    }
                }
            }
            
            // Ï†Å ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
            enemies.forEach((e, i) => {
                const newX = enemyStartX + (i * enemySpacing);
                const newY = groundY - (i * 15);
                
                e.container.x = newX;
                e.container.y = newY;
                e.baseX = newX;
                e.baseY = newY;
                
                const charData = DDOOAction?.characters?.get(e.id);
                if (charData) {
                    charData.baseX = newX;
                    charData.baseY = newY;
                    if (charData.shadow) {
                        charData.shadow.x = newX;
                        charData.shadow.y = newY + 5;
                    }
                }
            });
            
            // Î∞∞Í≤Ω Îã§Ïãú Í∑∏Î¶¨Í∏∞
            if (stageContainer && stageContainer.children.length > 0) {
                const bg = stageContainer.children[0];
                if (bg instanceof PIXI.Graphics) {
                    bg.clear();
                    drawBackgroundGraphics(bg, width, height);
                }
            }
            
            // 3D Î∞∞Í≤Ω Î¶¨ÏÇ¨Ïù¥Ï¶à
            if (typeof Background3D !== 'undefined' && Background3D.handleResize) {
                Background3D.handleResize();
            }
            
            // ÌÉÄÍ≤ü ÏÑ†ÌÉù UI ÏóÖÎç∞Ïù¥Ìä∏
            const currentEnemy = enemies[currentTargetIndex];
            if (currentEnemy) {
                config.enemyBaseX = currentEnemy.baseX;
                enemyContainer = currentEnemy.container;
            }
            
            log('info', `üìê Î¶¨ÏÇ¨Ïù¥Ï¶à: ${width}x${height}`);
        }
        
        function drawBackgroundGraphics(bg, width, height) {
            // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º
            for (let i = 0; i < 10; i++) {
                const alpha = 0.03 + (i * 0.01);
                bg.beginFill(0x1a1a2e, alpha);
                bg.drawRect(0, height * (i / 10), width, height / 10);
                bg.endFill();
            }
            
            // Î∞îÎã• ÎùºÏù∏
            const groundY = height * 0.7;
            bg.lineStyle(2, 0x3a3a5a, 0.6);
            bg.moveTo(0, groundY);
            bg.lineTo(width, groundY);
            
            // Í∑∏Î¶¨Îìú
            bg.lineStyle(1, 0x2a2a3a, 0.2);
            for (let x = 0; x < width; x += 100) {
                bg.moveTo(x, 0);
                bg.lineTo(x, height);
            }
        }
        
        function drawBackground(width, height) {
            const bg = new PIXI.Graphics();
            
            // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º
            for (let i = 0; i < 10; i++) {
                const alpha = 0.03 + (i * 0.01);
                bg.beginFill(0x1a1a2e, alpha);
                bg.drawRect(0, height * (i / 10), width, height / 10);
                bg.endFill();
            }
            
            // Î∞îÎã• ÎùºÏù∏
            const groundY = height * 0.7;
            bg.lineStyle(2, 0x3a3a5a, 0.6);
            bg.moveTo(0, groundY);
            bg.lineTo(width, groundY);
            
            // Í∑∏Î¶¨Îìú
            bg.lineStyle(1, 0x2a2a3a, 0.2);
            for (let x = 0; x < width; x += 100) {
                bg.moveTo(x, 0);
                bg.lineTo(x, height);
            }
            
            stageContainer.addChild(bg);
        }
        
        async function createCharacters(width, height) {
            const groundY = height * 0.75;  // Î∞îÎã•ÏùÑ ÏïΩÍ∞Ñ ÎÇÆÏ∂§
            config.baseY = groundY;
            config.playerBaseX = width * 0.22;  // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò
            
            // Ï†Å ÏúÑÏπò Í≥ÑÏÇ∞ (3Î™Ö Î∞∞Ïπò) - Îçî Ïò§Î•∏Ï™ΩÏóê, Í∞ÑÍ≤© Ï¢ÅÍ≤å
            const enemyStartX = width * 0.58;
            const enemySpacing = width * 0.12;  // Í∞ÑÍ≤© Ï§ÑÏûÑ
            
            // üéÆ DDOOAction ÏóîÏßÑ ÏÇ¨Ïö©!
            const useDDOOEngine = typeof DDOOAction !== 'undefined';
            
            if (useDDOOEngine && DDOOAction.initialized) {
                log('info', 'üéÆ DDOOAction ÏóîÏßÑÏúºÎ°ú Ï∫êÎ¶≠ÌÑ∞ ÏÉùÏÑ±...');
                
                // ÏïÑÏõÉÎùºÏù∏ ÏÑ§Ï†ï Ï°∞Ï†ï (ÎÑàÎ¨¥ ÎëêÍªçÏßÄ ÏïäÍ≤å)
                DDOOAction.config.character.outlineThickness = 1;
                DDOOAction.config.enableOutline = false;  // ÌÖåÏä§Ìä∏Ïö© ÎπÑÌôúÏÑ±Ìôî
                
                // ÌîåÎ†àÏù¥Ïñ¥ ÌÖçÏä§Ï≤ò Î°úÎìú
                let playerTex;
                try {
                    playerTex = await PIXI.Assets.load('hero.png');
                    log('success', `‚úÖ hero.png (${playerTex.width}x${playerTex.height})`);
                } catch (e) {
                    playerTex = createFallbackTexture(0x60a5fa, 'P');
                    log('warn', '‚ö†Ô∏è hero.png fallback');
                }
                
                // DDOOActionÏúºÎ°ú ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ± (Í∑∏Î¶ºÏûê, ÏïÑÏõÉÎùºÏù∏, Î∏åÎ†àÏã± Ìè¨Ìï®!)
                const playerData = DDOOAction.createCharacter('player', {
                    texture: playerTex,
                    x: config.playerBaseX,
                    y: groundY,
                    scale: 1.0,
                    team: 'player',
                    enableEffects: true
                });
                playerContainer = playerData.container;
                playerSprite = playerData.sprite;
                playerContainer.zIndex = 100;  // Í∏∞Î≥∏ zIndex (Ï†ÅÎ≥¥Îã§ ÎÜíÍ≤å)
                
                // Ï†Å ÌÖçÏä§Ï≤ò Î°úÎìú
                let enemyTex;
                try {
                    enemyTex = await PIXI.Assets.load('goblinarcher.png');
                    log('success', `‚úÖ goblinarcher.png (${enemyTex.width}x${enemyTex.height})`);
                } catch (e) {
                    enemyTex = createFallbackTexture(0xef4444, 'E');
                    log('warn', '‚ö†Ô∏è goblinarcher.png fallback');
                }
                
                // üéØ Îã§Ï§ë Ï†Å ÏÉùÏÑ± (3Î™Ö!)
                enemies = [];
                for (let i = 0; i < config.enemyCount; i++) {
                    const enemyX = enemyStartX + (i * enemySpacing);
                    const enemyId = i === 0 ? 'enemy' : `enemy${i + 1}`;
                    
                    // ÏõêÍ∑ºÍ∞ê: Îí§Î°ú Í∞àÏàòÎ°ù ÏûëÍ≥† ÎÜíÏù¥ Ïò¨ÎùºÍ∞ê
                    const depthScale = 0.75 - (i * 0.08);
                    const depthY = groundY - (i * 15);  // Îí§Î°ú Í∞àÏàòÎ°ù ÏïΩÍ∞Ñ ÏúÑÎ°ú
                    const depthZIndex = 50 - (i * 10);  // ÏïûÏóê ÏûàÏùÑÏàòÎ°ù ÎÜíÏùÄ zIndex
                    
                    const enemyData = DDOOAction.createCharacter(enemyId, {
                        texture: enemyTex,
                        x: enemyX,
                        y: depthY,
                        scale: depthScale,
                        team: 'enemy',
                        enableEffects: true
                    });
                    
                    enemyData.container.zIndex = depthZIndex;  // Îí§Ïóê ÏûàÎäî Ï†ÅÏùÄ ÎÇÆÏùÄ zIndex
                    
                    enemies.push({
                        id: enemyId,
                        container: enemyData.container,
                        sprite: enemyData.sprite,
                        baseX: enemyX,
                        baseY: depthY,
                        scale: depthScale,
                        zIndex: depthZIndex
                    });
                    
                    log('info', `  ‚Üí ${enemyId} at x=${enemyX.toFixed(0)}, scale=${depthScale.toFixed(2)}, z=${depthZIndex}`);
                }
                
                // Ï≤´ Î≤àÏß∏ Ï†ÅÏùÑ Í∏∞Î≥∏ ÌÉÄÍ≤üÏúºÎ°ú
                enemyContainer = enemies[0].container;
                enemySprite = enemies[0].sprite;
                config.enemyBaseX = enemies[0].baseX;
                
                log('success', `‚úÖ DDOOAction Ï∫êÎ¶≠ÌÑ∞ ÏÉùÏÑ± ÏôÑÎ£å (ÌîåÎ†àÏù¥Ïñ¥ 1Î™Ö, Ï†Å ${config.enemyCount}Î™Ö)`);
                
            } else {
                // Ìè¥Î∞±: Í∏∞Ï°¥ Î∞©Ïãù
                log('warn', '‚ö†Ô∏è DDOOAction ÏóÜÏùå, Í∏∞Ï°¥ Î∞©Ïãù ÏÇ¨Ïö©');
                
                // ÌîåÎ†àÏù¥Ïñ¥
                playerContainer = new PIXI.Container();
                playerContainer.x = config.playerBaseX;
                playerContainer.y = groundY;
                
                try {
                    const tex = await PIXI.Assets.load('hero.png');
                    playerSprite = new PIXI.Sprite(tex);
                    playerSprite.anchor.set(0.5, 1);
                    playerSprite.scale.set(1.0);
                } catch (e) {
                    playerSprite = createFallback(0x60a5fa, 'P');
                }
                playerContainer.addChild(playerSprite);
                stageContainer.addChild(playerContainer);
                
                // Îã§Ï§ë Ï†Å (Ìè¥Î∞±)
                enemies = [];
                const enemyTex = await PIXI.Assets.load('goblinarcher.png').catch(() => null);
                
                for (let i = 0; i < config.enemyCount; i++) {
                    const enemyX = enemyStartX + (i * enemySpacing);
                    const depthScale = 0.75 - (i * 0.08);
                    const depthY = groundY - (i * 15);
                    
                    const container = new PIXI.Container();
                    container.x = enemyX;
                    container.y = depthY;
                    
                    let sprite;
                    if (enemyTex) {
                        sprite = new PIXI.Sprite(enemyTex);
                        sprite.anchor.set(0.5, 1);
                        sprite.scale.set(depthScale);
                    } else {
                        sprite = createFallback(0xef4444, `E${i+1}`);
                    }
                    container.addChild(sprite);
                    stageContainer.addChild(container);
                    
                    enemies.push({
                        id: `enemy${i === 0 ? '' : i + 1}`,
                        container,
                        sprite,
                        baseX: enemyX,
                        baseY: depthY,
                        scale: depthScale
                    });
                }
                
                enemyContainer = enemies[0].container;
                enemySprite = enemies[0].sprite;
                config.enemyBaseX = enemies[0].baseX;
                
                initAfterimageSystem();
                startBreathing();
            }
            
            // Ï∫êÎ¶≠ÌÑ∞ ÌÅ¨Í∏∞ Ï†ÄÏû•
            updateCharacterInfo();
            
            // ÌÉÄÍ≤ü ÏÑ†ÌÉù UI Ï∂îÍ∞Ä
            addTargetSelector();
        }
        
        // Ìè¥Î∞± ÌÖçÏä§Ï≤ò ÏÉùÏÑ±
        function createFallbackTexture(color, letter) {
            const g = new PIXI.Graphics();
            g.beginFill(color);
            g.drawRoundedRect(0, 0, 70, 120, 10);
            g.endFill();
            return app.renderer.generateTexture(g);
        }
        
        function updateCharacterInfo() {
            // ÌîåÎ†àÏù¥Ïñ¥ Î∞îÏö¥Îìú
            const pBounds = playerSprite.getBounds();
            config.playerHeight = pBounds.height;
            config.playerWidth = pBounds.width;
            
            // Ï†Å Î∞îÏö¥Îìú
            const eBounds = enemySprite.getBounds();
            config.enemyHeight = eBounds.height;
            config.enemyWidth = eBounds.width;
            
            log('info', `Player: ${config.playerWidth.toFixed(0)}x${config.playerHeight.toFixed(0)}`);
            log('info', `Enemies: ${enemies.length}Î™Ö`);
        }
        
        // üéØ ÌÉÄÍ≤ü ÏÑ†ÌÉù UI
        function addTargetSelector() {
            const overlay = document.getElementById('statsOverlay');
            
            const targetRow = document.createElement('div');
            targetRow.className = 'stat-row';
            targetRow.innerHTML = `
                <span>Target:</span>
                <select id="targetSelect" style="background:#252535;color:#60a5fa;border:1px solid #3a3a5a;padding:2px 5px;border-radius:3px;font-size:0.7rem;">
                    ${enemies.map((e, i) => `<option value="${i}">${e.id} (x:${e.baseX.toFixed(0)})</option>`).join('')}
                </select>
            `;
            overlay.appendChild(targetRow);
            
            document.getElementById('targetSelect').addEventListener('change', (e) => {
                selectTarget(parseInt(e.target.value));
            });
        }
        
        // ÌÉÄÍ≤ü Î≥ÄÍ≤Ω
        function selectTarget(index) {
            if (index < 0 || index >= enemies.length) return;
            currentTargetIndex = index;
            
            const target = enemies[index];
            enemyContainer = target.container;
            enemySprite = target.sprite;
            config.enemyBaseX = target.baseX;
            
            // DDOOActionÏùò ÌÉÄÍ≤üÎèÑ Î≥ÄÍ≤Ω
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized) {
                // üéØ enemy Ï∫êÎ¶≠ÌÑ∞Î•º ÏÉà ÌÉÄÍ≤üÏúºÎ°ú ÏßÅÏ†ë ÍµêÏ≤¥!
                const newCharData = {
                    container: target.container,
                    sprite: target.sprite,
                    baseX: target.baseX,
                    baseY: target.baseY || config.baseY,
                    baseScale: target.scale || 1,  // üî• baseScale Ï∂îÍ∞Ä!
                    team: 'enemy',
                    state: 'idle'
                };
                DDOOAction.characters.set('enemy', newCharData);
                
                log('info', `üéØ DDOOAction ÌÉÄÍ≤ü ÏóÖÎç∞Ïù¥Ìä∏: enemy ‚Üí ${target.id}`);
            }
            
            log('info', `üéØ ÌÉÄÍ≤ü Î≥ÄÍ≤Ω: ${target.id} (x:${target.baseX.toFixed(0)})`);
        }
        
        function createFallback(color, letter) {
            const c = new PIXI.Container();
            const body = new PIXI.Graphics();
            body.beginFill(color);
            body.drawRoundedRect(-35, -120, 70, 120, 10);
            body.endFill();
            const text = new PIXI.Text(letter, { fontFamily: 'Arial', fontSize: 40, fill: 0xffffff, fontWeight: 'bold' });
            text.anchor.set(0.5);
            text.y = -60;
            c.addChild(body);
            c.addChild(text);
            return c;
        }
        
        function startBreathing() {
            gsap.to(playerSprite.scale, { y: 1.02, duration: 1.8, repeat: -1, yoyo: true, ease: 'sine.inOut' });
            gsap.to(enemySprite.scale, { y: 1.02, duration: 1.5, repeat: -1, yoyo: true, ease: 'sine.inOut' });
        }
        
        // ==================== ÏûîÏÉÅ ÏãúÏä§ÌÖú ====================
        const afterimages = [];
        let afterimageContainer = null;
        
        function initAfterimageSystem() {
            afterimageContainer = new PIXI.Container();
            stageContainer.addChildAt(afterimageContainer, 0); // Ï∫êÎ¶≠ÌÑ∞ Îí§Ïóê Î∞∞Ïπò
        }
        
        function createAfterimage(sourceSprite, sourceContainer, alpha = 0.6, tint = 0x8888ff) {
            if (!afterimageContainer || !sourceSprite.texture) return;
            
            const ghost = new PIXI.Sprite(sourceSprite.texture);
            ghost.anchor.set(sourceSprite.anchor.x, sourceSprite.anchor.y);
            ghost.x = sourceContainer.x;
            ghost.y = sourceContainer.y;
            ghost.scale.set(sourceSprite.scale.x, sourceSprite.scale.y);
            ghost.rotation = sourceSprite.rotation;
            ghost.alpha = alpha;
            ghost.tint = tint;
            
            afterimageContainer.addChild(ghost);
            
            // ÏûîÏÉÅ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
            afterimages.push({
                sprite: ghost,
                life: 150,
                maxLife: 150,
                fadeSpeed: 1
            });
        }
        
        function updateAfterimages(delta) {
            for (let i = afterimages.length - 1; i >= 0; i--) {
                const ai = afterimages[i];
                ai.life -= delta * 16;
                
                const progress = ai.life / ai.maxLife;
                ai.sprite.alpha = progress * 0.6;
                ai.sprite.scale.x *= 0.995;
                ai.sprite.scale.y *= 0.995;
                
                if (ai.life <= 0) {
                    afterimageContainer.removeChild(ai.sprite);
                    ai.sprite.destroy();
                    afterimages.splice(i, 1);
                }
            }
        }
        
        function clearAfterimages() {
            afterimages.forEach(ai => {
                afterimageContainer.removeChild(ai.sprite);
                ai.sprite.destroy();
            });
            afterimages.length = 0;
        }
        
        // ==================== JSON Î°úÎìú (Î≤àÎì§ Ïö∞ÏÑ†, fetch Ìè¥Î∞±) ====================
        async function loadAllVFX() {
            log('info', 'üí• Loading VFX...');
            
            // üéÅ Î≤àÎì§Ïù¥ ÏûàÏúºÎ©¥ Ï¶âÏãú ÏÇ¨Ïö©!
            if (window.VFX_BUNDLE) {
                log('success', 'üéÅ VFX Î≤àÎì§ ÏÇ¨Ïö© (fetch Ïä§ÌÇµ!)');
                Object.entries(window.VFX_BUNDLE).forEach(([id, data]) => {
                    vfxCache.set(id, data);
                });
                VFX_FILES = Object.keys(window.VFX_BUNDLE);
                log('success', `‚úÖ VFX Î°úÎìú ÏôÑÎ£å: ${vfxCache.size}Í∞ú (Î≤àÎì§)`);
                return;
            }
            
            // Ìè¥Î∞±: fetchÎ°ú Î°úÎìú
            try {
                const indexRes = await fetch('vfx/index.json');
                if (indexRes.ok) {
                    VFX_FILES = await indexRes.json();
                    log('info', `üìã vfx/index.json: ${VFX_FILES.length}Í∞ú Î∞úÍ≤¨`);
                }
            } catch (e) {
                log('warn', '‚ö†Ô∏è vfx/index.json ÏóÜÏùå, Í∏∞Î≥∏ Î™©Î°ù ÏÇ¨Ïö©');
                VFX_FILES = ['slash', 'hit', 'spark', 'dash', 'stab', 'critical', 'block'];
            }
            
            for (const id of VFX_FILES) {
                try {
                    const res = await fetch(`vfx/${id}.json`);
                    if (res.ok) {
                        vfxCache.set(id, await res.json());
                    }
                } catch (e) {
                    log('warn', `‚ö†Ô∏è vfx/${id} failed`);
                }
            }
            log('success', `‚úÖ VFX Î°úÎìú ÏôÑÎ£å: ${vfxCache.size}Í∞ú`);
        }
        
        async function loadAllAnimations() {
            log('info', 'üìÅ Loading animations...');
            
            // üéÅ Î≤àÎì§Ïù¥ ÏûàÏúºÎ©¥ Ï¶âÏãú ÏÇ¨Ïö©!
            if (window.ANIM_BUNDLE) {
                log('success', 'üéÅ Anim Î≤àÎì§ ÏÇ¨Ïö© (fetch Ïä§ÌÇµ!)');
                Object.entries(window.ANIM_BUNDLE).forEach(([id, data]) => {
                    animCache.set(id, data);
                });
                ANIM_FILES = Object.keys(window.ANIM_BUNDLE);
                log('success', `‚úÖ Ïï†ÎãàÎ©îÏù¥ÏÖò Î°úÎìú ÏôÑÎ£å: ${animCache.size}Í∞ú (Î≤àÎì§)`);
                return;
            }
            
            // Ìè¥Î∞±: fetchÎ°ú Î°úÎìú
            try {
                const indexRes = await fetch('anim/index.json');
                if (indexRes.ok) {
                    ANIM_FILES = await indexRes.json();
                    log('info', `üìã anim/index.json: ${ANIM_FILES.length}Í∞ú Î∞úÍ≤¨`);
                }
            } catch (e) {
                log('warn', '‚ö†Ô∏è anim/index.json ÏóÜÏùå, Í∏∞Î≥∏ Î™©Î°ù ÏÇ¨Ïö©');
                ANIM_FILES = ['player.attack', 'player.hit', 'enemy.attack', 'enemy.hit'];
            }
            
            for (const id of ANIM_FILES) {
                try {
                    const res = await fetch(`anim/${id}.json`);
                    if (res.ok) {
                        animCache.set(id, await res.json());
                    }
                } catch (e) {
                    log('warn', `‚ö†Ô∏è anim/${id} failed`);
                }
            }
            log('success', `‚úÖ Ïï†ÎãàÎ©îÏù¥ÏÖò Î°úÎìú ÏôÑÎ£å: ${animCache.size}Í∞ú`);
        }
        
        function renderAnimList() {
            const container = document.getElementById('animList');
            container.innerHTML = '';
            animCache.forEach((data, id) => {
                const type = id.split('.')[0];
                const name = id.split('.')[1];
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = id;
                item.innerHTML = `<span class="type ${type}">${type}</span><span class="name">${name}</span>`;
                item.onclick = () => playAnimation(id);
                container.appendChild(item);
            });
        }
        
        // ==================== ÌÉ≠ Ï†ÑÌôò ====================
        function switchTab(tabName) {
            // ÌÉ≠ Î≤ÑÌäº ÌôúÏÑ±Ìôî
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            
            // ÌÉ≠ Ïª®ÌÖêÏ∏† ÌëúÏãú
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = content.id === `tab-${tabName}` ? 'block' : 'none';
            });
            
            // VFX/Draw Î¶¨Ïä§Ìä∏ Î†åÎçîÎßÅ (ÏµúÏ¥à 1Ìöå)
            if (tabName === 'vfx' && !document.getElementById('vfxList').children.length) {
                renderVFXList();
            }
            if (tabName === 'draw' && !document.getElementById('drawList').children.length) {
                renderDrawList();
            }
        }
        
        // ==================== VFX Î¶¨Ïä§Ìä∏ Î†åÎçîÎßÅ ====================
        function renderVFXList() {
            const container = document.getElementById('vfxList');
            container.innerHTML = '';
            
            vfxCache.forEach((data, id) => {
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = id;
                item.innerHTML = `<span class="type vfx">VFX</span><span class="name">${data.name || id}</span>`;
                item.onclick = () => playVFX(id);
                container.appendChild(item);
            });
            
            log('info', `üìã VFX Î¶¨Ïä§Ìä∏ Î†åÎçîÎßÅ: ${vfxCache.size}Í∞ú`);
        }
        
        // ==================== VFX Ïû¨ÏÉù ====================
        function playVFX(id) {
            const vfxData = vfxCache.get(id);
            if (!vfxData) {
                log('error', `‚ùå VFX not found: ${id}`);
                return;
            }
            
            // ÏÑ†ÌÉù ÌëúÏãú
            document.querySelectorAll('#vfxList .anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`#vfxList .anim-item[data-id="${id}"]`)?.classList.add('playing');
            
            // ÌôîÎ©¥ Ï§ëÏïôÏóêÏÑú VFX Ïû¨ÏÉù
            const centerX = app.screen.width / 2;
            const centerY = config.baseY - 60;
            
            log('vfx', `‚ú® VFX: ${id}`);
            
            if (typeof DDOOAction !== 'undefined' && DDOOAction.triggerVFX) {
                DDOOAction.triggerVFX(id, centerX, centerY, 1, 1.5);
            } else {
                triggerVFX(vfxData, centerX, centerY, 1, 1.5);
            }
        }
        
        // ==================== Draw Î¶¨Ïä§Ìä∏ Î†åÎçîÎßÅ ====================
        function renderDrawList() {
            const container = document.getElementById('drawList');
            container.innerHTML = '';
            
            // DDOODrawÏóêÏÑú Ìï®Ïàò Î™©Î°ù Ï∂îÏ∂ú
            const drawFunctions = [
                // === 3D Ïù¥ÌéôÌä∏ (WebGL) ===
                { id: 'sparks3d', name: '‚ú® 3D Sparks', type: '3d', is3d: true },
                // === 2D Ïù¥ÌéôÌä∏ (Canvas) ===
                { id: 'slash', name: '‚öîÔ∏è Slash (Í≤ÄÍ∏∞)', type: 'slash' },
                { id: 'sword_arc', name: 'üåô Sword Arc (Í≤Ä Ìò∏)', type: 'sword_arc' },
                { id: 'trail_dot', name: 'üîµ Trail Dot', type: 'trail_dot' },
                { id: 'energy_orb', name: 'üîÆ Energy Orb', type: 'energy_orb' },
                { id: 'electric', name: '‚ö° Electric', type: 'electric' },
                { id: 'wave', name: 'üåä Wave', type: 'wave' },
                { id: 'star', name: '‚≠ê Star', type: 'star' },
                { id: 'comet', name: '‚òÑÔ∏è Comet', type: 'comet' },
                { id: 'voxel', name: 'üéÜ Voxel', type: 'voxel' },
                { id: 'smoke', name: 'üí® Smoke', type: 'smoke' },
                { id: 'symbol', name: '‚ú® Symbol', type: 'symbol' },
                { id: 'arrow', name: '‚û§ Arrow', type: 'arrow' },
                { id: 'spark', name: '‚ú¶ Spark', type: 'spark' },
                { id: 'flash', name: 'üí´ Flash', type: 'flash' },
                { id: 'ring', name: '‚≠ï Ring', type: 'ring' },
                { id: 'line', name: '‚îÅ Line', type: 'line' },
                { id: 'debris', name: 'üß± Debris', type: 'debris' }
            ];
            
            drawFunctions.forEach(df => {
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = df.id;
                const typeClass = df.is3d ? 'effect-3d' : 'draw';
                const typeLabel = df.is3d ? '3D' : 'DRAW';
                item.innerHTML = `<span class="type ${typeClass}">${typeLabel}</span><span class="name">${df.name}</span>`;
                item.onclick = () => df.is3d ? play3DEffect(df.id) : playDrawParticle(df.type);
                container.appendChild(item);
            });
            
            // ÏÑ§Ï†ï Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
            document.getElementById('drawSize').addEventListener('input', (e) => {
                document.getElementById('drawSizeValue').textContent = e.target.value;
            });
            document.getElementById('drawAngle').addEventListener('input', (e) => {
                document.getElementById('drawAngleValue').textContent = e.target.value + '¬∞';
            });
            
            log('info', `üìã Draw Î¶¨Ïä§Ìä∏ Î†åÎçîÎßÅ: ${drawFunctions.length}Í∞ú`);
            
            // 3D VFX Ï¥àÍ∏∞Ìôî
            if (typeof DDOOVfx3D !== 'undefined' && !DDOOVfx3D.initialized) {
                DDOOVfx3D.init(document.getElementById('pixiContainer'));
                log('success', 'üéÆ 3D VFX ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî');
            }
        }
        
        // ==================== 3D Ïù¥ÌéôÌä∏ Ïû¨ÏÉù ====================
        function play3DEffect(effectId) {
            // ÏÑ†ÌÉù ÌëúÏãú
            document.querySelectorAll('#drawList .anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`#drawList .anim-item[data-id="${effectId}"]`)?.classList.add('playing');
            
            // ÏÑ§Ï†ïÍ∞í Í∞ÄÏ†∏Ïò§Í∏∞
            const color = document.getElementById('drawColor').value;
            const glow = document.getElementById('drawGlow').value;
            const size = parseInt(document.getElementById('drawSize').value);
            const angle = parseInt(document.getElementById('drawAngle').value);
            
            // ÌôîÎ©¥ Ï§ëÏïô (pixiContainer Í∏∞Ï§Ä)
            const container = document.getElementById('pixiContainer');
            const centerX = container.clientWidth / 2;
            const centerY = config.baseY - 60;
            
            // ÏÉâÏÉÅÏùÑ hexÎ°ú Î≥ÄÌôò
            const colorHex = parseInt(color.replace('#', ''), 16);
            const glowHex = parseInt(glow.replace('#', ''), 16);
            
            log('vfx', `üéÆ 3D Effect: ${effectId} (size:${size})`);
            
            if (typeof DDOOVfx3D === 'undefined') {
                log('error', '‚ùå DDOOVfx3DÍ∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§');
                return;
            }
            
            // 3D VFX Ï¥àÍ∏∞Ìôî Ï≤¥ÌÅ¨
            if (!DDOOVfx3D.initialized) {
                DDOOVfx3D.init(container);
            }
            
            switch (effectId) {
                case 'slash3d':
                    DDOOVfx3D.slash3D(centerX, centerY, {
                        color: colorHex,
                        glowColor: glowHex,
                        length: size,
                        width: size / 4,
                        arc: 140,
                        startAngle: angle,
                        duration: 0.5,
                        direction: 1
                    });
                    break;
                    
                case 'shockwave3d':
                    DDOOVfx3D.shockwave3D(centerX, centerY, {
                        color: colorHex,
                        maxRadius: size,
                        thickness: size / 15,
                        duration: 0.5
                    });
                    break;
                    
                case 'sparks3d':
                    DDOOVfx3D.sparks3D(centerX, centerY, {
                        color: colorHex,
                        count: Math.floor(size / 5),
                        speed: size * 1.5,
                        size: 4,
                        duration: 0.7
                    });
                    break;
            }
        }
        
        // ==================== Draw ÌååÌã∞ÌÅ¥ Ïû¨ÏÉù ====================
        function playDrawParticle(type) {
            // ÏÑ†ÌÉù ÌëúÏãú
            document.querySelectorAll('#drawList .anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`#drawList .anim-item[data-id="${type}"]`)?.classList.add('playing');
            
            // ÏÑ§Ï†ïÍ∞í Í∞ÄÏ†∏Ïò§Í∏∞
            const color = document.getElementById('drawColor').value;
            const glow = document.getElementById('drawGlow').value;
            const size = parseInt(document.getElementById('drawSize').value);
            const angle = parseInt(document.getElementById('drawAngle').value);
            
            // ÌôîÎ©¥ Ï§ëÏïô
            const centerX = app.screen.width / 2;
            const centerY = config.baseY - 60;
            
            log('vfx', `üé® Draw: ${type} (size:${size}, angle:${angle}¬∞)`);
            
            // ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
            const particleConfig = {
                x: centerX,
                y: centerY,
                color: color,
                glow: glow,
                life: 500
            };
            
            switch (type) {
                case 'slash':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'slash',
                            ...particleConfig,
                            angle: angle,
                            length: size,
                            width: size / 8
                        });
                    }
                    break;
                case 'sword_arc':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'sword_arc',
                            ...particleConfig,
                            dir: 1,
                            radius: size / 2,
                            thickness: size / 10,
                            startAngle: -80,
                            endAngle: 80
                        });
                    }
                    break;
                case 'trail_dot':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'trail_dot',
                            ...particleConfig,
                            size: size / 10
                        });
                    }
                    break;
                case 'energy_orb':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'energy_orb',
                            ...particleConfig,
                            startSize: size / 5
                        });
                    }
                    break;
                case 'electric':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'electric',
                            ...particleConfig,
                            angle: angle,
                            length: size,
                            segments: 8,
                            width: 3
                        });
                    }
                    break;
                case 'wave':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'wave',
                            ...particleConfig,
                            startSize: size / 4,
                            maxSize: size,
                            thickness: size / 15,
                            startAngle: -90,
                            endAngle: 90
                        });
                    }
                    break;
                case 'star':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'star',
                            ...particleConfig,
                            startSize: size / 5,
                            points: 4,
                            rotation: angle * Math.PI / 180
                        });
                    }
                    break;
                case 'comet':
                    if (typeof DDOOAction !== 'undefined') {
                        const rad = angle * Math.PI / 180;
                        DDOOAction.spawnParticle({
                            type: 'comet',
                            ...particleConfig,
                            startSize: size / 10,
                            tailLength: size / 2,
                            vx: Math.cos(rad) * 5,
                            vy: Math.sin(rad) * 5
                        });
                    }
                    break;
                case 'voxel':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'voxel',
                            ...particleConfig,
                            size: size / 8,
                            rotation: angle * Math.PI / 180,
                            rotationSpeed: 0.1
                        });
                    }
                    break;
                case 'smoke':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'smoke',
                            ...particleConfig,
                            startSize: size / 4,
                            rotation: 0,
                            rotationSpeed: 0.02
                        });
                    }
                    break;
                case 'symbol':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'symbol',
                            ...particleConfig,
                            size: size / 3,
                            symbol: '‚≠ê'
                        });
                    }
                    break;
                case 'arrow':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'arrow',
                            ...particleConfig,
                            dir: 1,
                            startLength: size,
                            startWidth: size / 2,
                            tipAngle: 35,
                            innerColor: glow + '80'
                        });
                    }
                    break;
                case 'spark':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'spark',
                            ...particleConfig,
                            startSize: size / 10
                        });
                    }
                    break;
                case 'flash':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'flash',
                            ...particleConfig,
                            startSize: size / 2
                        });
                    }
                    break;
                case 'ring':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'ring',
                            ...particleConfig,
                            startSize: size / 5,
                            maxSize: size
                        });
                    }
                    break;
                case 'line':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'line',
                            ...particleConfig,
                            angle: angle,
                            startLength: size,
                            startWidth: 3
                        });
                    }
                    break;
                case 'debris':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'debris',
                            ...particleConfig,
                            startSize: size / 10
                        });
                    }
                    break;
            }
        }
        
        // ==================== Î©îÏù∏ Ïû¨ÏÉù ====================
        async function playAnimation(id, skipReset = false) {
            const data = animCache.get(id);
            if (!data) { log('error', `‚ùå Not found: ${id}`); return; }
            
            document.querySelectorAll('.anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`.anim-item[data-id="${id}"]`)?.classList.add('playing');
            
            log('anim', `‚ñ∂Ô∏è ${id}`);
            
            if (!skipReset) {
                resetCharacters();
                await delay(100);
            }
            
            const target = data.target || (id.startsWith('enemy') ? 'enemy' : 'player');
            const container = target === 'player' ? playerContainer : enemyContainer;
            const sprite = target === 'player' ? playerSprite : enemySprite;
            const baseX = target === 'player' ? config.playerBaseX : config.enemyBaseX;
            const dir = target === 'player' ? 1 : -1;
            
            // üéÆ DDOOAction ÏóîÏßÑ ÏÇ¨Ïö©!
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized) {
                // üéØ ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÌÉÄÍ≤ü Ï†ïÎ≥¥
                const currentTarget = enemies[currentTargetIndex];
                const targetCont = currentTarget?.container || enemyContainer;
                const targetSpr = currentTarget?.sprite || enemySprite;
                
                
                await DDOOAction.play(id, {
                    container,
                    sprite,
                    baseX,
                    baseY: config.baseY,
                    dir,
                    isRelative: false,
                    // üéØ ÌÉÄÍ≤ü Ï†ïÎ≥¥ Ï†ÑÎã¨!
                    targetContainer: targetCont,
                    targetSprite: targetSpr,
                    targetBaseX: currentTarget?.baseX || config.enemyBaseX,
                    targetBaseY: currentTarget?.baseY || config.baseY,
                    onComplete: () => log('success', `‚úÖ ${id} ÏôÑÎ£å`),
                    onHit: (kf) => log('info', `üí• ÌûàÌä∏! ${kf.vfx || ''}`),
                    getHitPoint: () => {
                        // üéØ ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÌÉÄÍ≤üÏùò ÌÉÄÍ≤©Ï†ê!
                        return { 
                            x: targetCont.x, 
                            y: targetCont.y - (config.enemyHeight || 100) / 2 
                        };
                    }
                });
                return;
            }
            
            // Ìè¥Î∞±: Í∏∞Ï°¥ Î∞©Ïãù
            if (data.type === 'sequence' && data.steps) {
                await playSequence(data);
            } else if (data.keyframes) {
                await playKeyframes(data, container, sprite, baseX, dir, false);
            }
        }
        
        // ==================== ÏãúÌÄÄÏä§ Ïû¨ÏÉù ====================
        async function playSequence(data) {
            log('anim', `üé¨ Sequence: ${data.id}`);
            
            for (const step of data.steps) {
                if (step.delay && !step.anim) {
                    await delay(step.delay / config.speed);
                    continue;
                }
                
                if (step.anim) {
                    const animData = animCache.get(step.anim);
                    if (!animData) { log('warn', `‚ö†Ô∏è ${step.anim} not found`); continue; }
                    
                    log('info', `  ‚Üí ${step.anim}`);
                    
                    const target = animData.target || (step.anim.startsWith('enemy') ? 'enemy' : 'player');
                    const container = target === 'player' ? playerContainer : enemyContainer;
                    const sprite = target === 'player' ? playerSprite : enemySprite;
                    const dir = target === 'player' ? 1 : -1;
                    
                    if (step.delay) await delay(step.delay / config.speed);
                    
                    if (animData.keyframes) {
                        const promise = playKeyframes(animData, container, sprite, container.x, dir, true);
                        if (step.wait) await promise;
                    }
                }
            }
            
            log('success', `‚úÖ Sequence done: ${data.id}`);
        }
        
        // ==================== ÌÇ§ÌîÑÎ†àÏûÑ Ïû¨ÏÉù (FGO Ïä§ÌÉÄÏùº) ====================
        async function playKeyframes(data, container, sprite, startX, dir, isRelative) {
            return new Promise((resolve) => {
                const baseScale = 1.0;
                const returnToBase = data.returnToBase;
                const targetBaseX = dir === 1 ? config.playerBaseX : config.enemyBaseX;
                
                gsap.killTweensOf(container);
                gsap.killTweensOf(sprite);
                gsap.killTweensOf(sprite.scale);
                
                const tl = gsap.timeline({
                    timeScale: config.speed,
                    onComplete: () => {
                        if (returnToBase) {
                            gsap.to(container, {
                                x: targetBaseX,
                                duration: 0.25,
                                ease: 'power2.inOut',
                                onComplete: resolve
                            });
                        } else {
                            resolve();
                        }
                    }
                });
                
                data.keyframes.forEach((kf, idx) => {
                    if (idx === 0) return;
                    
                    const dur = (kf.duration || 100) / 1000;
                    const ease = kf.ease || 'power2.out';
                    const pos = idx === 1 ? 0 : '>';
                    
                    // Ïª®ÌÖåÏù¥ÎÑà Ïù¥Îèô
                    if (kf.x !== undefined) {
                        const targetX = isRelative ? startX + (kf.x * dir) : config.playerBaseX + (kf.x * dir);
                        tl.to(container, { x: targetX, duration: dur, ease }, pos);
                    }
                    
                    if (kf.y !== undefined) {
                        tl.to(container, { y: config.baseY + kf.y, duration: dur, ease }, '<');
                    }
                    
                    // Ïä§ÏºÄÏùº (Ïä§ÏøºÏãú/Ïä§Ìä∏Î†àÏπò)
                    if (kf.scaleX !== undefined || kf.scaleY !== undefined) {
                        const scaleX = (kf.scaleX ?? 1) * baseScale;
                        const scaleY = (kf.scaleY ?? 1) * baseScale;
                        tl.to(sprite.scale, { x: scaleX, y: scaleY, duration: dur, ease }, '<');
                    }
                    
                    // ÌöåÏ†Ñ
                    if (kf.rotation !== undefined) {
                        tl.to(sprite, { rotation: kf.rotation * dir, duration: dur, ease }, '<');
                    }
                    
                    // ÏïåÌåå
                    if (kf.alpha !== undefined) {
                        tl.to(sprite, { alpha: kf.alpha, duration: dur, ease }, '<');
                    }
                    
                    // ========== VFX Ìä∏Î¶¨Í±∞ ==========
                    if (kf.vfx) {
                        tl.call(() => triggerVFX(kf.vfx, container, dir), null, '<');
                    }
                    
                    // ========== ÌûàÌä∏Ïä§ÌÜ± ==========
                    if (kf.hitstop) {
                        tl.call(() => {
                            tl.pause();
                            setTimeout(() => tl.resume(), kf.hitstop / config.speed);
                        }, null, '>');
                    }
                    
                    // ========== Ïä§ÌÅ¨Î¶∞ÏâêÏù¥ÌÅ¨ ==========
                    if (kf.shake) {
                        tl.call(() => screenShake(kf.shake), null, '<');
                    }
                    
                    // ========== Î≥µÏÖÄ ÏâêÌÑ∞ (ÌÉÄÍ≤©Í∞ê!) ==========
                    if (kf.shatter && typeof DDOOAction !== 'undefined') {
                        tl.call(() => {
                            const shatterOpts = typeof kf.shatter === 'object' ? kf.shatter : {};
                            const target = shatterOpts.target || 'enemy';
                            DDOOAction.shatterTarget(target, {
                                gridSize: shatterOpts.grid || 10,
                                force: shatterOpts.force || 12,
                                gravity: shatterOpts.gravity || 0.35,
                                life: shatterOpts.life || 500,
                                color: shatterOpts.color || null,
                                dirBias: data.target === 'player' ? 1 : -1,
                                hideSprite: shatterOpts.hide !== false,
                                hideTime: shatterOpts.hideTime || 150
                            });
                        }, null, '<');
                    }
                    
                    // ========== ÏûîÏÉÅ ÏÉùÏÑ± ==========
                    if (kf.afterimage) {
                        tl.call(() => {
                            const tint = data.target === 'player' ? 0x60a5fa : 0xef4444;
                            createAfterimage(sprite, container, 0.7, tint);
                        }, null, '<');
                    }
                });
            });
        }
        
        function resetCharacters() {
            gsap.killTweensOf(playerContainer);
            gsap.killTweensOf(playerSprite);
            gsap.killTweensOf(playerSprite.scale);
            gsap.killTweensOf(stageContainer);
            
            // Î™®Îì† Ï†Å Ìä∏Ïúà Ï†ïÎ¶¨
            enemies.forEach(e => {
                gsap.killTweensOf(e.container);
                gsap.killTweensOf(e.sprite);
                gsap.killTweensOf(e.sprite.scale);
            });
            
            playerContainer.x = config.playerBaseX;
            playerContainer.y = config.baseY;
            playerSprite.rotation = 0;
            playerSprite.scale.set(1.0);
            playerSprite.alpha = 1;
            
            // Î™®Îì† Ï†Å Î¶¨ÏÖã
            enemies.forEach((e, i) => {
                e.container.x = e.baseX;
                e.container.y = e.baseY || config.baseY;
                e.sprite.rotation = 0;
                e.sprite.scale.set(e.scale || (0.75 - (i * 0.08)));
                e.sprite.alpha = 1;
            });
            
            stageContainer.x = 0;
            stageContainer.y = 0;
            stageContainer.scale.set(1, 1);
            stageContainer.alpha = 1;
            
            // ‚ö†Ô∏è DDOOAction Ïπ¥Î©îÎùº/Ïù¥ÌéôÌä∏ Î¶¨ÏÖã!
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized) {
                DDOOAction.resetCameraImmediate();
                DDOOAction.resetColorGradeImmediate();
                DDOOAction.resetSlowmoImmediate();
                
                const playerChar = DDOOAction.characters.get('player');
                if (playerChar) {
                    playerChar.sprite.alpha = 1;
                    playerChar.sprite.rotation = 0;
                    playerChar.sprite.scale.set(1, 1);
                    playerChar.container.x = config.playerBaseX;
                    playerChar.container.y = config.baseY;
                }
                
                // Î™®Îì† Ï†Å Î¶¨ÏÖã
                enemies.forEach((e, i) => {
                    const charData = DDOOAction.characters.get(e.id);
                    if (charData) {
                        charData.sprite.alpha = 1;
                        charData.sprite.rotation = 0;
                        const scale = e.scale || (0.75 - (i * 0.08));
                        charData.sprite.scale.set(scale, scale);
                        charData.container.x = e.baseX;
                        charData.container.y = e.baseY || config.baseY;
                    }
                });
            }
            
            // üé• 3D Î∞∞Í≤Ω Ïπ¥Î©îÎùºÎèÑ Î¶¨ÏÖã
            if (typeof Background3D !== 'undefined' && Background3D.isInitialized && Background3D.autoZoom) {
                const baseZ = Background3D.cameraDefaults?.posZ || 15;
                Background3D.autoZoom.targetZ = baseZ;
                Background3D.autoZoom.currentZ = baseZ;
            }
            
            clearVFX();
            clearAfterimages();
            startBreathing();
        }
        
        // ==================== VFX ÏãúÏä§ÌÖú (JSON Í∏∞Î∞ò) ====================
        
        // Ï∫êÎ¶≠ÌÑ∞Ïùò Ïã§Ï†ú Î∞îÏö¥Îìú Í≥ÑÏÇ∞
        function getCharacterBounds(container) {
            const sprite = container.children[0];
            if (!sprite) return { width: 60, height: 120, centerY: -60 };
            
            const bounds = sprite.getBounds();
            const scale = sprite.scale.x;
            
            return {
                width: bounds.width,
                height: bounds.height,
                centerY: -bounds.height / 2,  // Ï§ëÏã¨Ï†ê Y
                scale: scale
            };
        }
        
        // ÌÉÄÍ≤©Ï†ê Í≥ÑÏÇ∞ (Ï†Å ÏúÑÏπò Í∏∞Ï§Ä)
        function getHitPoint(attackerContainer, targetContainer) {
            const targetBounds = getCharacterBounds(targetContainer);
            
            // ÌÉÄÍ≤©Ï†êÏùÄ ÌÉÄÍ≤ü Ï∫êÎ¶≠ÌÑ∞Ïùò Ï§ëÏã¨
            return {
                x: targetContainer.x,
                y: targetContainer.y + targetBounds.centerY,
                scale: targetBounds.scale
            };
        }
        
        function triggerVFX(vfxId, container, dir) {
            const vfxData = vfxCache.get(vfxId);
            if (!vfxData) {
                log('warn', `‚ö†Ô∏è VFX not found: ${vfxId}`);
                return;
            }
            
            // ÌÉÄÍ≤©Ï†ê Í≥ÑÏÇ∞: Í≥µÍ≤©ÏûêÍ∞Ä ÌîåÎ†àÏù¥Ïñ¥Î©¥ Ï†ÅÏóêÍ≤å, Ï†ÅÏù¥Î©¥ ÌîåÎ†àÏù¥Ïñ¥ÏóêÍ≤å
            const isPlayer = container === playerContainer;
            const targetContainer = isPlayer ? enemyContainer : playerContainer;
            const hitPoint = getHitPoint(container, targetContainer);
            
            // VFX ÌÉÄÏûÖÏóê Îî∞Î•∏ ÏúÑÏπò Í≤∞Ï†ï
            let vfxX, vfxY, vfxScale;
            
            if (vfxId === 'dash' || vfxId === 'trail') {
                // ÎåÄÏãú/Ìä∏Î†àÏùºÏùÄ ÏûêÏã† ÏúÑÏπò
                const bounds = getCharacterBounds(container);
                vfxX = container.x;
                vfxY = container.y + bounds.centerY;
                vfxScale = bounds.scale;
            } else {
                // Í≥µÍ≤© Ïù¥ÌéôÌä∏Îäî ÌÉÄÍ≤©Ï†ê (ÌÉÄÍ≤ü ÏúÑÏπò)
                vfxX = hitPoint.x;
                vfxY = hitPoint.y;
                vfxScale = hitPoint.scale;
            }
            
            log('vfx', `üí• ${vfxId} at (${vfxX.toFixed(0)}, ${vfxY.toFixed(0)}) scale:${vfxScale.toFixed(2)}`);
            
            // VFXÏóê Ï†ïÏùòÎêú shake Ïã§Ìñâ
            if (vfxData.shake) {
                screenShake(vfxData.shake);
            }
            
            // Í∞Å ÌååÌã∞ÌÅ¥ Ï†ïÏùò Ï≤òÎ¶¨
            for (const pDef of vfxData.particles) {
                spawnParticlesFromDef(pDef, vfxX, vfxY, dir, container, vfxScale);
            }
        }
        
        // JSON Ï†ïÏùòÏóêÏÑú ÌååÌã∞ÌÅ¥ ÏÉùÏÑ± (Ïä§ÏºÄÏùº Ï†ÅÏö©)
        function spawnParticlesFromDef(def, x, y, dir, container, scale = 1.0) {
            const count = def.count || 1;
            const delayBetween = def.delay || 0;
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    switch (def.type) {
                        case 'slash':
                        case 'thrust':
                            spawnSlashParticle(def, x, y, dir, i, scale);
                            break;
                        case 'arrow':
                        case 'wedge':
                            spawnArrowParticle(def, x, y, dir, i, scale);
                            break;
                        case 'spark':
                            spawnSparkParticle(def, x, y, scale);
                            break;
                        case 'flash':
                            spawnFlashParticle(def, x, y, scale);
                            break;
                        case 'ring':
                            spawnRingParticle(def, x, y, scale);
                            break;
                        case 'line':
                            spawnLineParticle(def, x, y, i, scale);
                            break;
                        case 'debris':
                            spawnDebrisParticle(def, x, y, scale);
                            break;
                        case 'trail':
                            spawnTrailParticle(def, container, i, scale);
                            break;
                        case 'projectile':
                            spawnProjectileParticle(def, x, y, dir, scale, container);
                            break;
                        case 'sword_arc':
                            spawnSwordArcParticle(def, x, y, dir, i, scale);
                            break;
                    }
                }, i * delayBetween);
            }
        }
        
        // Í≤Ä Í∂§Ï†Å ÏïÑÌÅ¨ Ïä§Ìè∞
        function spawnSwordArcParticle(def, x, y, dir, index, scale) {
            const radius = getRandValue(def.radius) * scale;
            const thickness = (def.thickness || 15) * scale;
            const colors = Array.isArray(def.colors) ? def.colors : [def.color || '#ffffff'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const glowColors = Array.isArray(def.glowColors) ? def.glowColors : [def.glow || '#60a5fa'];
            const glow = glowColors[Math.floor(Math.random() * glowColors.length)];
            
            spawnParticle({
                type: 'sword_arc',
                x: x,
                y: y,
                dir: dir,
                radius: radius,
                thickness: thickness,
                startAngle: def.startAngle || -60,
                endAngle: def.endAngle || 60,
                color: color,
                glow: glow,
                trail: def.trail !== false,
                life: getRandValue(def.life) || 180
            });
        }
        
        function spawnSlashParticle(def, x, y, dir, index, scale) {
            const angles = Array.isArray(def.angle) ? def.angle : [def.angle || 0];
            const angle = angles[index % angles.length] || (Math.random() - 0.5) * 60;
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 8) * scale;
            
            spawnParticle({
                type: 'slash',
                x, y,
                angle: angle * dir,
                length: length,
                width: width,
                color: def.color || '#ffffff',
                glow: def.glow || '#60a5fa',
                life: def.life || 150
            });
        }
        
        // ">" Î™®Ïñë ÌôîÏÇ¥Ìëú Ïù¥ÌéôÌä∏
        function spawnArrowParticle(def, x, y, dir, index, scale) {
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 60) * scale;
            const tipAngle = def.tipAngle || 35; // ÌôîÏÇ¥Ï¥â Í∞ÅÎèÑ
            
            const p = {
                type: 'arrow',
                x, y,
                dir: dir,
                startLength: length,
                startWidth: width,
                tipAngle: tipAngle,
                color: def.color || '#ffffff',
                glow: def.glow || '#a78bfa',
                innerColor: def.innerColor || 'rgba(167, 139, 250, 0.5)',
                life: def.life || 120
            };
            spawnParticle(p);
        }
        
        function spawnSparkParticle(def, x, y, scale) {
            const spread = (def.spread || 50) * scale;
            const speed = getRandValue(def.speed) * scale;
            const size = getRandValue(def.size) * scale;
            const angle = Math.random() * Math.PI * 2;
            const colors = def.colors || [def.color || '#fbbf24'];
            
            spawnParticle({
                type: 'spark',
                x: x + (Math.random() - 0.5) * spread,
                y: y + (Math.random() - 0.5) * spread,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2,
                size: size,
                color: colors[Math.floor(Math.random() * colors.length)],
                life: getRandValue(def.life)
            });
        }
        
        function spawnFlashParticle(def, x, y, scale) {
            spawnParticle({
                type: 'flash',
                x, y,
                size: (def.size || 80) * scale,
                color: def.color || '#ffffff',
                life: def.life || 80
            });
        }
        
        function spawnRingParticle(def, x, y, scale) {
            spawnParticle({
                type: 'ring',
                x, y,
                size: (def.size || 20) * scale,
                maxSize: (def.maxSize || 100) * scale,
                color: def.color || '#ef4444',
                life: def.life || 200
            });
        }
        
        function spawnLineParticle(def, x, y, index, scale) {
            const angleStep = def.angleStep || 30;
            const angle = index * angleStep;
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 3) * scale;
            
            spawnParticle({
                type: 'line',
                x, y,
                angle: angle,
                length: length,
                width: width,
                color: def.color || '#fbbf24',
                life: def.life || 150
            });
        }
        
        function spawnDebrisParticle(def, x, y, scale) {
            const speed = getRandValue(def.speed) * scale;
            const size = getRandValue(def.size) * scale;
            const angle = Math.random() * Math.PI * 2;
            const colors = def.colors || [def.color || '#ef4444'];
            
            spawnParticle({
                type: 'debris',
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 5,
                size: size,
                color: colors[Math.floor(Math.random() * colors.length)],
                gravity: def.gravity || 0.3,
                life: getRandValue(def.life)
            });
        }
        
        function spawnTrailParticle(def, container, index, scale) {
            const bounds = getCharacterBounds(container);
            const offsetX = (def.offsetX || -20) * index * scale;
            const size = (getRandValue(def.size) - index * 5) * scale;
            
            spawnParticle({
                type: 'trail',
                x: container.x + offsetX,
                y: container.y + bounds.centerY,
                size: Math.max(size, 10),
                color: def.color || 'rgba(96, 165, 250, 0.3)',
                life: def.life || 150
            });
        }
        
        function spawnProjectileParticle(def, startX, startY, dir, scale, container) {
            // ÏãúÏûëÏ†ê (ÌîåÎ†àÏù¥Ïñ¥) ‚Üí ÎÅùÏ†ê (Ï†Å)
            const targetContainer = container === playerContainer ? enemyContainer : playerContainer;
            const targetBounds = getCharacterBounds(targetContainer);
            const endX = targetContainer.x;
            const endY = targetContainer.y + targetBounds.centerY;
            
            spawnParticle({
                type: 'projectile',
                x: startX,
                y: startY,
                targetX: endX,
                targetY: endY,
                speed: (def.speed || 20) * scale,
                rotation: def.rotation || 0,
                size: (def.size || 15) * scale,
                shape: def.shape || 'circle',
                color: def.color || '#94a3b8',
                glow: def.glow || '#60a5fa',
                life: def.life || 300,
                dir: dir
            });
        }
        
        // Ïú†Ìã∏: Î∞∞Ïó¥Ïù¥Î©¥ ÎûúÎç§ Î≤îÏúÑ, ÏïÑÎãàÎ©¥ Í∑∏ÎåÄÎ°ú
        function getRandValue(val) {
            if (Array.isArray(val)) {
                return val[0] + Math.random() * (val[1] - val[0]);
            }
            return val || 0;
        }
        
        // ÌååÌã∞ÌÅ¥ Ïä§Ìè∞
        function spawnParticle(config) {
            particles.push({
                ...config,
                startLife: config.life,
                startSize: config.size || 10,
                startLength: config.length || 50,
                born: performance.now()
            });
        }
        
        // VFX Î†åÎçî Î£®ÌîÑ
        function startVFXLoop() {
            let lastTime = performance.now();
            
            function render() {
                const now = performance.now();
                const delta = (now - lastTime) / 16.67; // 60fps Í∏∞Ï§Ä
                lastTime = now;
                
                // ÏûîÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏
                updateAfterimages(delta);
                
                vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const age = now - p.born;
                    const progress = age / p.startLife;
                    
                    if (progress >= 1) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    const alpha = 1 - progress;
                    
                    vfxCtx.save();
                    
                    switch (p.type) {
                        case 'slash':
                            // DDOODrawÏùò ÌôîÎ†§Ìïú Î≤ÑÏ†Ñ ÏÇ¨Ïö©!
                            if (typeof DDOODraw !== 'undefined' && DDOODraw.drawSlashParticle) {
                                DDOODraw.drawSlashParticle(vfxCtx, p, alpha, progress);
                            } else {
                                drawSlashParticle(p, alpha, progress);
                            }
                            break;
                        case 'arrow':
                            drawArrowParticle(p, alpha, progress);
                            break;
                        case 'spark':
                            p.x += p.vx || 0;
                            p.y += p.vy || 0;
                            if (p.gravity) p.vy += p.gravity;
                            drawSparkParticle(p, alpha);
                            break;
                        case 'flash':
                            drawFlashParticle(p, alpha, progress);
                            break;
                        case 'ring':
                            drawRingParticle(p, alpha, progress);
                            break;
                        case 'line':
                            drawLineParticle(p, alpha, progress);
                            break;
                        case 'debris':
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += p.gravity;
                            drawDebrisParticle(p, alpha);
                            break;
                        case 'trail':
                            drawTrailParticle(p, alpha);
                            break;
                        case 'projectile':
                            updateAndDrawProjectile(p, alpha, progress);
                            break;
                        case 'sword_arc':
                            // DDOODrawÏùò ÌôîÎ†§Ìïú Î≤ÑÏ†Ñ ÏÇ¨Ïö©!
                            if (typeof DDOODraw !== 'undefined' && DDOODraw.drawSwordArcParticle) {
                                DDOODraw.drawSwordArcParticle(vfxCtx, p, alpha, progress);
                            } else {
                                drawSwordArcParticle(p, alpha, progress);
                            }
                            break;
                    }
                    
                    vfxCtx.restore();
                }
                
                animationFrame = requestAnimationFrame(render);
            }
            render();
        }
        
        // Í≤Ä Í∂§Ï†Å ÏïÑÌÅ¨ Î†åÎçîÎßÅ
        function drawSwordArcParticle(p, alpha, progress) {
            if (!isFinite(p.x) || !isFinite(p.y)) return;
            
            const radius = p.radius || 60;
            const thickness = (p.thickness || 15) * (1 - progress * 0.4);
            const dir = p.dir || 1;
            const color = p.color || '#ffffff';
            const glow = p.glow || '#60a5fa';
            
            const startAngle = (p.startAngle || -60) * Math.PI / 180;
            const endAngle = (p.endAngle || 60) * Math.PI / 180;
            const currentEnd = startAngle + (endAngle - startAngle) * Math.min(1, progress * 3);
            const fadeStart = Math.max(startAngle, currentEnd - (endAngle - startAngle) * 0.7);
            
            vfxCtx.save();
            vfxCtx.translate(p.x, p.y);
            if (dir < 0) vfxCtx.scale(-1, 1);
            
            // Ïô∏Î∂Ä Í∏ÄÎ°úÏö∞
            vfxCtx.shadowColor = glow;
            vfxCtx.shadowBlur = 30 + thickness;
            
            vfxCtx.strokeStyle = glow;
            vfxCtx.lineWidth = thickness * 2.5;
            vfxCtx.lineCap = 'round';
            vfxCtx.globalAlpha = alpha * 0.3;
            
            vfxCtx.beginPath();
            vfxCtx.arc(0, 0, radius, fadeStart, currentEnd);
            vfxCtx.stroke();
            
            // Î©îÏù∏ ÏïÑÌÅ¨
            const arcLength = (currentEnd - fadeStart) * radius;
            if (arcLength > 0) {
                const startX = Math.cos(fadeStart) * radius;
                const startY = Math.sin(fadeStart) * radius;
                const endX = Math.cos(currentEnd) * radius;
                const endY = Math.sin(currentEnd) * radius;
                
                const grad = vfxCtx.createLinearGradient(startX, startY, endX, endY);
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(0.2, color + 'aa');
                grad.addColorStop(0.5, color);
                grad.addColorStop(0.8, '#ffffff');
                grad.addColorStop(1, '#ffffff');
                
                vfxCtx.strokeStyle = grad;
                vfxCtx.lineWidth = thickness;
                vfxCtx.globalAlpha = alpha;
                
                vfxCtx.beginPath();
                vfxCtx.arc(0, 0, radius, fadeStart, currentEnd);
                vfxCtx.stroke();
                
                // ÎÅùÏ†ê ÌïòÏù¥ÎùºÏù¥Ìä∏
                if (progress < 0.5) {
                    const tipX = Math.cos(currentEnd) * radius;
                    const tipY = Math.sin(currentEnd) * radius;
                    
                    const tipGrad = vfxCtx.createRadialGradient(tipX, tipY, 0, tipX, tipY, thickness * 2);
                    tipGrad.addColorStop(0, '#ffffff');
                    tipGrad.addColorStop(0.5, color);
                    tipGrad.addColorStop(1, 'transparent');
                    
                    vfxCtx.fillStyle = tipGrad;
                    vfxCtx.globalAlpha = alpha * (1 - progress * 2);
                    vfxCtx.beginPath();
                    vfxCtx.arc(tipX, tipY, thickness * 2, 0, Math.PI * 2);
                    vfxCtx.fill();
                }
            }
            
            vfxCtx.restore();
        }
        
        function drawSlashParticle(p, alpha, progress) {
            const rad = p.angle * Math.PI / 180;
            const len = p.startLength * (1 - progress * 0.3);
            
            vfxCtx.translate(p.x, p.y);
            vfxCtx.rotate(rad);
            
            // Í∏ÄÎ°úÏö∞
            if (p.glow) {
                vfxCtx.shadowColor = p.glow;
                vfxCtx.shadowBlur = 20;
            }
            
            // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ïä¨ÎûòÏãú
            const grad = vfxCtx.createLinearGradient(-len/2, 0, len/2, 0);
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(0.3, p.color);
            grad.addColorStop(0.7, p.color);
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.strokeStyle = grad;
            vfxCtx.lineWidth = p.width * alpha;
            vfxCtx.lineCap = 'round';
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(-len/2, 0);
            vfxCtx.lineTo(len/2, 0);
            vfxCtx.stroke();
        }
        
        // ">" ÌôîÏÇ¥Ìëú Î™®Ïñë Í∑∏Î¶¨Í∏∞
        function drawArrowParticle(p, alpha, progress) {
            const len = p.startLength * (1 - progress * 0.4);
            const width = p.startWidth * (1 - progress * 0.3);
            const tipRad = (p.tipAngle || 35) * Math.PI / 180;
            
            // ÌôîÏÇ¥Ìëú Î∞©Ìñ• (dir: 1 = Ïò§Î•∏Ï™Ω, -1 = ÏôºÏ™Ω)
            const dir = p.dir || 1;
            
            vfxCtx.translate(p.x, p.y);
            if (dir < 0) vfxCtx.scale(-1, 1);
            
            // Í∏ÄÎ°úÏö∞
            if (p.glow) {
                vfxCtx.shadowColor = p.glow;
                vfxCtx.shadowBlur = 25;
            }
            vfxCtx.globalAlpha = alpha;
            
            // ÎÇ¥Î∂Ä Ï±ÑÏö∞Í∏∞ (Î∞òÌà¨Î™Ö)
            if (p.innerColor) {
                vfxCtx.fillStyle = p.innerColor;
                vfxCtx.beginPath();
                vfxCtx.moveTo(len, 0);                          // Îæ∞Ï°±Ìïú ÎÅù
                vfxCtx.lineTo(0, -width * Math.sin(tipRad));    // ÏúÑÏ™Ω ÎÇ†Í∞ú
                vfxCtx.lineTo(len * 0.3, 0);                    // ÏïàÏ™Ω Í∫æÏûÑ
                vfxCtx.lineTo(0, width * Math.sin(tipRad));     // ÏïÑÎûòÏ™Ω ÎÇ†Í∞ú
                vfxCtx.closePath();
                vfxCtx.fill();
            }
            
            // Ïô∏Í≥ΩÏÑ† (Î∞ùÏùÄ ÏÉâ)
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = 3 * alpha;
            vfxCtx.lineCap = 'round';
            vfxCtx.lineJoin = 'round';
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(0, -width * Math.sin(tipRad));  // ÏúÑÏ™Ω ÎÇ†Í∞ú
            vfxCtx.lineTo(len, 0);                         // Îæ∞Ï°±Ìïú ÎÅù
            vfxCtx.lineTo(0, width * Math.sin(tipRad));   // ÏïÑÎûòÏ™Ω ÎÇ†Í∞ú
            vfxCtx.stroke();
            
            // Ï§ëÏïô Í∞ïÏ°∞ÏÑ†
            vfxCtx.strokeStyle = '#ffffff';
            vfxCtx.lineWidth = 2 * alpha;
            vfxCtx.beginPath();
            vfxCtx.moveTo(len * 0.2, 0);
            vfxCtx.lineTo(len * 0.9, 0);
            vfxCtx.stroke();
        }
        
        function drawSparkParticle(p, alpha) {
            vfxCtx.fillStyle = p.color;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 8;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawFlashParticle(p, alpha, progress) {
            const size = p.startSize * (1 + progress);
            const grad = vfxCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
            grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
            grad.addColorStop(0.5, `rgba(255,255,255,${alpha * 0.5})`);
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.fillStyle = grad;
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawRingParticle(p, alpha, progress) {
            const size = p.size + (p.maxSize - p.size) * progress;
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = 4 * alpha;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 15;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
            vfxCtx.stroke();
        }
        
        function drawLineParticle(p, alpha, progress) {
            const rad = p.angle * Math.PI / 180;
            const len = p.startLength * (1 - progress * 0.5);
            const startOffset = p.startLength * progress * 0.3;
            
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = p.width * alpha;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.lineCap = 'round';
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 8;
            
            const sx = p.x + Math.cos(rad) * startOffset;
            const sy = p.y + Math.sin(rad) * startOffset;
            const ex = p.x + Math.cos(rad) * (startOffset + len);
            const ey = p.y + Math.sin(rad) * (startOffset + len);
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(sx, sy);
            vfxCtx.lineTo(ex, ey);
            vfxCtx.stroke();
        }
        
        function drawDebrisParticle(p, alpha) {
            vfxCtx.fillStyle = p.color;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 5;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawTrailParticle(p, alpha) {
            // NaN/Infinity Ï≤¥ÌÅ¨
            if (!isFinite(p.x) || !isFinite(p.y) || !isFinite(p.size) || p.size <= 0) {
                return;
            }
            
            const grad = vfxCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
            grad.addColorStop(0, p.color.replace('0.3', String(0.3 * alpha)));
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.fillStyle = grad;
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function updateAndDrawProjectile(p, alpha, progress) {
            // Ìà¨ÏÇ¨Ï≤¥ Ïù¥Îèô (ÏãúÏûëÏ†ê ‚Üí ÌÉÄÍ≤ü)
            const dx = p.targetX - p.x;
            const dy = p.targetY - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > p.speed) {
                p.x += (dx / dist) * p.speed;
                p.y += (dy / dist) * p.speed;
            }
            
            // ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏
            if (p.rotation) {
                p.currentRotation = (p.currentRotation || 0) + (p.rotation * Math.PI / 180) * 0.016;
            }
            
            vfxCtx.save();
            vfxCtx.translate(p.x, p.y);
            vfxCtx.rotate(p.currentRotation || 0);
            
            // Í∏ÄÎ°úÏö∞
            vfxCtx.shadowColor = p.glow;
            vfxCtx.shadowBlur = 12;
            vfxCtx.globalAlpha = alpha;
            
            // Îã®Í≤Ä Í∑∏Î¶¨Í∏∞
            if (p.shape === 'dagger') {
                // Îã®Í≤Ä Î∏îÎ†àÏù¥Îìú
                vfxCtx.fillStyle = p.color;
                vfxCtx.beginPath();
                vfxCtx.moveTo(p.size, 0);           // ÎÅù
                vfxCtx.lineTo(0, -p.size * 0.3);    // ÏúÑ
                vfxCtx.lineTo(-p.size * 0.5, 0);    // ÏÜêÏû°Ïù¥
                vfxCtx.lineTo(0, p.size * 0.3);     // ÏïÑÎûò
                vfxCtx.closePath();
                vfxCtx.fill();
                
                // ÌïòÏù¥ÎùºÏù¥Ìä∏
                vfxCtx.fillStyle = '#ffffff';
                vfxCtx.globalAlpha = alpha * 0.6;
                vfxCtx.beginPath();
                vfxCtx.moveTo(p.size * 0.8, 0);
                vfxCtx.lineTo(0, -p.size * 0.15);
                vfxCtx.lineTo(-p.size * 0.2, 0);
                vfxCtx.closePath();
                vfxCtx.fill();
            } else {
                // Í∏∞Î≥∏ ÏõêÌòï
                vfxCtx.fillStyle = p.color;
                vfxCtx.beginPath();
                vfxCtx.arc(0, 0, p.size, 0, Math.PI * 2);
                vfxCtx.fill();
            }
            
            vfxCtx.restore();
            
            // ÏûîÏÉÅ Ìä∏Î†àÏùº ÏÉùÏÑ± (dist > 0 Ïùº ÎïåÎßå)
            if (dist > 0.1 && Math.random() > 0.6) {
                spawnParticle({
                    type: 'trail',
                    x: p.x - (dx / dist) * 10,
                    y: p.y - (dy / dist) * 10,
                    size: p.size * 0.5,
                    color: 'rgba(148, 163, 184, 0.2)',
                    life: 80
                });
            }
        }
        
        
        // Ïä§ÌÅ¨Î¶∞ÏâêÏù¥ÌÅ¨
        function screenShake(intensity) {
            const duration = 150;
            const startTime = performance.now();
            
            function shake() {
                const elapsed = performance.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    stageContainer.x = 0;
                    stageContainer.y = 0;
                    return;
                }
                
                const decay = 1 - progress;
                const offsetX = (Math.random() - 0.5) * intensity * decay;
                const offsetY = (Math.random() - 0.5) * intensity * decay;
                
                stageContainer.x = offsetX;
                stageContainer.y = offsetY;
                
                requestAnimationFrame(shake);
            }
            shake();
        }
        
        function clearVFX() {
            particles.length = 0;
            vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
        }
        
        // ==================== Ïú†Ìã∏ ====================
        function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
        
        function updateSpeed() {
            config.speed = parseFloat(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = config.speed.toFixed(1) + 'x';
        }
        
        function log(type, msg) {
            const c = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString('ko-KR', { hour12: false });
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${msg}`;
            c.appendChild(entry);
            c.scrollTop = c.scrollHeight;
        }
        
        function clearLog() { document.getElementById('logContainer').innerHTML = ''; }
        
        // ÏÑ±Îä• ÏµúÏ†ÅÌôî: requestAnimationFrame + Ïì∞Î°úÌãÄÎßÅ
        let lastUpdateTime = 0;
        function startUpdateLoop() {
            const updateStats = (time) => {
                // 100ms Ïì∞Î°úÌãÄÎßÅ
                if (time - lastUpdateTime > 100) {
                    lastUpdateTime = time;
                    if (playerContainer) {
                        document.getElementById('playerPos').textContent = `${playerContainer.x | 0}, ${playerContainer.y | 0}`;
                        document.getElementById('enemyPos').textContent = `${enemyContainer.x | 0}, ${enemyContainer.y | 0}`;
                        document.getElementById('fpsValue').textContent = app.ticker.FPS | 0;
                    }
                }
                requestAnimationFrame(updateStats);
            };
            requestAnimationFrame(updateStats);
        }
        
        // ==================== üé¨ ÌÉÄÏûÑÎùºÏù∏ ÏãúÏä§ÌÖú (Í∞úÏÑ†) ====================
        const Timeline = {
            scale: 0.25,
            duration: 2000,
            currentTime: 0,
            isPlaying: false,
            isLoop: false,
            isVisible: true,
            animId: null,
            playStartTime: 0,
            rafId: null,
            
            tracks: { player: [], enemy: [], vfx: [], camera: [], effects: [], damage: [] },
            
            // Ï¥àÍ∏∞Ìôî
            init() {
                this.renderRuler();
                this.setupEvents();
            },
            
            // Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
            setupEvents() {
                const content = document.getElementById('timelineContent');
                let isDragging = false;
                let startX = 0;
                let scrollLeft = 0;
                
                // ÎìúÎûòÍ∑∏Î°ú Ïä§ÌÅ¨Î°§
                content.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('timeline-keyframe')) return;
                    isDragging = true;
                    startX = e.pageX - content.offsetLeft;
                    scrollLeft = content.scrollLeft;
                });
                
                content.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const x = e.pageX - content.offsetLeft;
                    content.scrollLeft = scrollLeft - (x - startX);
                });
                
                content.addEventListener('mouseup', () => isDragging = false);
                content.addEventListener('mouseleave', () => isDragging = false);
                
                // ÌÅ¥Î¶≠ÏúºÎ°ú ÏãúÍ∞Ñ Ïù¥Îèô
                content.addEventListener('click', (e) => {
                    if (e.target.classList.contains('timeline-keyframe')) return;
                    const rect = content.getBoundingClientRect();
                    const x = e.clientX - rect.left + content.scrollLeft;
                    this.seekTo(x / this.scale);
                });
                
                // ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    if (e.code === 'Space') { e.preventDefault(); this.togglePlay(); }
                    if (e.code === 'Home') this.seekTo(0);
                    if (e.code === 'End') this.seekTo(this.duration);
                });
            },
            
            // ÎààÍ∏àÏûê Î†åÎçîÎßÅ (ÏµúÏ†ÅÌôî: DocumentFragment ÏÇ¨Ïö©)
            renderRuler() {
                const ruler = document.getElementById('timelineRuler');
                const fragment = document.createDocumentFragment();
                ruler.innerHTML = '';
                ruler.style.width = (this.duration * this.scale) + 'px';
                
                const step = this.scale < 0.15 ? 500 : this.scale < 0.3 ? 200 : 100;
                for (let t = 0; t <= this.duration; t += step) {
                    const mark = document.createElement('div');
                    mark.className = 'timeline-ruler-mark' + (t % 500 === 0 ? ' major' : '');
                    mark.style.left = (t * this.scale) + 'px';
                    if (t % 500 === 0) mark.textContent = (t / 1000).toFixed(1) + 's';
                    fragment.appendChild(mark);
                }
                ruler.appendChild(fragment);
            },
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖò Î∂ÑÏÑù
            analyzeAnimation(animId) {
                const data = animCache.get(animId);
                if (!data) return;
                
                this.animId = animId;
                this.clear();
                document.getElementById('tlAnimName').textContent = animId;
                
                if (data.type === 'sequence' && data.steps) {
                    this.analyzeSequence(data);
                } else if (data.keyframes) {
                    this.duration = this.calcAnimDuration(data);
                    this.analyzeKeyframes(data, 0);
                }
                
                this.renderRuler();
                this.render();
            },
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖò Í∏∏Ïù¥ Í≥ÑÏÇ∞ (duration Í∏∞Î∞ò!)
            calcAnimDuration(data) {
                if (!data.keyframes) return data.duration || 500;
                let total = 0;
                data.keyframes.forEach(kf => total += kf.duration || 0);
                return total || data.duration || 500;
            },
            
            // ÏãúÌÄÄÏä§ Î∂ÑÏÑù (Í∞úÏÑ†: duration Í∏∞Î∞ò)
            analyzeSequence(data) {
                let currentTime = 0;
                
                data.steps.forEach((step, idx) => {
                    // ÎîúÎ†àÏù¥Îßå ÏûàÎäî Í≤ΩÏö∞
                    if (step.delay && !step.anim) {
                        currentTime += step.delay;
                        return;
                    }
                    
                    if (step.anim) {
                        // ÎûúÎç§ Î∞∞Ïó¥Ïù¥Î©¥ Ï≤´ Î≤àÏß∏ ÏÇ¨Ïö©
                        const animId = Array.isArray(step.anim) ? step.anim[0] : step.anim;
                        const animData = animCache.get(animId);
                        if (!animData) return;
                        
                        // ÎîúÎ†àÏù¥ Ï†ÅÏö©
                        if (step.delay) currentTime += step.delay;
                        
                        // ÌÇ§ÌîÑÎ†àÏûÑ Î∂ÑÏÑù
                        this.analyzeKeyframes(animData, currentTime, step);
                        
                        // Ïï†ÎãàÎ©îÏù¥ÏÖò Í∏∏Ïù¥ Í≥ÑÏÇ∞ (waitÎ©¥ ÎåÄÍ∏∞)
                        if (step.wait) {
                            currentTime += this.calcAnimDuration(animData);
                        }
                    }
                    
                    // Ïù¥Î≤§Ìä∏ (damage, buff Îì±)
                    if (step.damage) {
                        this.tracks.damage.push({
                            time: currentTime,
                            duration: 50,
                            label: `üí• ${step.damage}`,
                            type: 'damage',
                            data: step
                        });
                    }
                    if (step.event) {
                        this.tracks.damage.push({
                            time: currentTime,
                            duration: 50,
                            label: `üì¶ ${step.event.type}`,
                            type: 'damage',
                            data: step.event
                        });
                    }
                });
                
                this.duration = Math.max(this.duration, currentTime + 200);
            },
            
            // ÌÇ§ÌîÑÎ†àÏûÑ Î∂ÑÏÑù (Í∞úÏÑ†: Î™®Îì† ÏÜçÏÑ± Î∂ÑÏÑù)
            analyzeKeyframes(data, startTime, stepData = {}) {
                const target = data.target || (data.id?.startsWith('enemy') ? 'enemy' : 'player');
                if (!data.keyframes) return;
                
                let accTime = startTime;
                
                data.keyframes.forEach((kf, idx) => {
                    const time = accTime;
                    const duration = kf.duration || 50;
                    
                    // Î©îÏù∏ ÌÇ§ÌîÑÎ†àÏûÑ (player/enemy)
                    this.tracks[target].push({
                        time, duration,
                        label: this.getKeyframeLabel(kf, idx),
                        type: target,
                        data: kf
                    });
                    
                    // VFX
                    if (kf.vfx) {
                        this.tracks.vfx.push({
                            time, duration: 150,
                            label: kf.vfx,
                            type: 'vfx',
                            data: kf
                        });
                    }
                    
                    // Ïπ¥Î©îÎùº (zoom, focus)
                    if (kf.camera) {
                        let label = 'üì∑';
                        if (kf.camera.zoom) label += ` ${kf.camera.zoom}x`;
                        if (kf.camera.focus) label += ` ‚Üí ${kf.camera.focus}`;
                        this.tracks.camera.push({
                            time, duration: kf.camera.duration || 200,
                            label, type: 'camera',
                            data: kf.camera
                        });
                    }
                    
                    // Ïù¥ÌéôÌä∏ (shake, hitstop, slowmo, color, shatter)
                    if (kf.shake) {
                        this.tracks.effects.push({
                            time, duration: 150,
                            label: `üì≥ ${kf.shake}`,
                            type: 'shake',
                            data: kf
                        });
                    }
                    if (kf.hitstop) {
                        this.tracks.effects.push({
                            time, duration: kf.hitstop,
                            label: `‚è∏ ${kf.hitstop}ms`,
                            type: 'hitstop',
                            data: kf
                        });
                    }
                    if (kf.slowmo) {
                        const slowLabel = typeof kf.slowmo === 'object' ? `${kf.slowmo.scale}x` : kf.slowmo;
                        this.tracks.effects.push({
                            time, duration: 200,
                            label: `üêå ${slowLabel}`,
                            type: 'slowmo',
                            data: kf
                        });
                    }
                    if (kf.color) {
                        this.tracks.effects.push({
                            time, duration: 150,
                            label: `üé® ${kf.color}`,
                            type: 'color',
                            data: kf
                        });
                    }
                    if (kf.shatter) {
                        const grid = kf.shatter.grid || 10;
                        this.tracks.effects.push({
                            time, duration: 200,
                            label: `üíé ${grid}¬≤`,
                            type: 'shatter',
                            data: kf
                        });
                    }
                    
                    // Îã§Ïùå ÌÇ§ÌîÑÎ†àÏûÑ ÏãúÍ∞Ñ
                    accTime += duration;
                });
                
                // Ïä§ÌÖùÏóêÏÑú damageÍ∞Ä ÏûàÏúºÎ©¥ ÎßàÏßÄÎßâÏóê Ï∂îÍ∞Ä
                if (stepData.damage && !data.keyframes.some(kf => kf.damage)) {
                    this.tracks.damage.push({
                        time: accTime - 50,
                        duration: 50,
                        label: `üí• ${stepData.damage}`,
                        type: 'damage',
                        data: stepData
                    });
                }
            },
            
            // ÌÇ§ÌîÑÎ†àÏûÑ Î†àÏù¥Î∏î (Í∞ÑÍ≤∞ÌïòÍ≤å)
            getKeyframeLabel(kf, idx) {
                const parts = [];
                if (kf.x !== undefined) parts.push(`x${kf.x}`);
                if (kf.y !== undefined) parts.push(`y${kf.y}`);
                if (kf.scaleX !== undefined && kf.scaleX !== 1) parts.push(`s${kf.scaleX.toFixed(1)}`);
                if (kf.rotation !== undefined && kf.rotation !== 0) parts.push(`r${kf.rotation.toFixed(1)}`);
                if (kf.alpha !== undefined && kf.alpha !== 1) parts.push(`Œ±${kf.alpha}`);
                if (kf.afterimage) parts.push('üë§');
                if (kf.dashToTarget) parts.push('üéØ');
                return parts.length > 0 ? parts.join(' ') : `#${idx}`;
            },
            
            // Î†åÎçîÎßÅ (ÏµúÏ†ÅÌôî: batch DOM ÏóÖÎç∞Ïù¥Ìä∏)
            render() {
                const lanes = document.getElementById('timelineLanes');
                lanes.style.width = (this.duration * this.scale + 50) + 'px';
                
                this.renderTrack('player', 'playerLane');
                this.renderTrack('enemy', 'enemyLane');
                this.renderTrack('vfx', 'vfxLane');
                this.renderTrack('camera', 'cameraLane');
                this.renderTrack('effects', 'effectsLane');
                this.renderTrack('damage', 'damageLane');
            },
            
            renderTrack(trackName, laneId) {
                const lane = document.getElementById(laneId);
                const fragment = document.createDocumentFragment();
                
                this.tracks[trackName].forEach(item => {
                    const el = document.createElement('div');
                    el.className = `timeline-keyframe ${item.type}`;
                    el.style.cssText = `left:${item.time * this.scale}px;width:${Math.max(item.duration * this.scale, 20)}px`;
                    el.textContent = item.label;
                    el.dataset.time = item.time;
                    el.addEventListener('click', (e) => { e.stopPropagation(); this.onKeyframeClick(item, e); });
                    el.addEventListener('mouseenter', (e) => this.showTooltip(item, e));
                    el.addEventListener('mouseleave', () => this.hideTooltip());
                    fragment.appendChild(el);
                });
                
                lane.innerHTML = '';
                lane.appendChild(fragment);
            },
            
            // Ìà¥ÌåÅ
            showTooltip(item, e) {
                const tt = document.getElementById('tlTooltip');
                let html = `<div class="tt-title">${item.label}</div>`;
                html += `<div class="tt-row"><span>Time:</span><span>${item.time}ms</span></div>`;
                html += `<div class="tt-row"><span>Duration:</span><span>${item.duration}ms</span></div>`;
                
                const d = item.data;
                if (d.x !== undefined) html += `<div class="tt-row"><span>X:</span><span>${d.x}</span></div>`;
                if (d.y !== undefined) html += `<div class="tt-row"><span>Y:</span><span>${d.y}</span></div>`;
                if (d.scaleX !== undefined) html += `<div class="tt-row"><span>ScaleX:</span><span>${d.scaleX}</span></div>`;
                if (d.scaleY !== undefined) html += `<div class="tt-row"><span>ScaleY:</span><span>${d.scaleY}</span></div>`;
                if (d.vfx) html += `<div class="tt-row"><span>VFX:</span><span>${d.vfx}</span></div>`;
                if (d.ease) html += `<div class="tt-row"><span>Ease:</span><span>${d.ease}</span></div>`;
                
                tt.innerHTML = html;
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 10) + 'px';
                tt.style.top = (e.clientY - tt.offsetHeight - 10) + 'px';
            },
            
            hideTooltip() {
                document.getElementById('tlTooltip').style.display = 'none';
            },
            
            onKeyframeClick(item, e) {
                log('info', `üéØ ${item.type}: ${item.label} @ ${item.time}ms`);
                this.seekTo(item.time);
            },
            
            // ÌîåÎ†àÏù¥Ìó§Îìú ÏÑ§Ï†ï
            setPlayhead(time) {
                this.currentTime = Math.max(0, Math.min(time, this.duration));
                const playhead = document.getElementById('timelinePlayhead');
                playhead.style.left = (this.currentTime * this.scale) + 'px';
                document.getElementById('timelineTime').textContent = 
                    `${(this.currentTime / 1000).toFixed(2)}s / ${(this.duration / 1000).toFixed(2)}s`;
                
                // ÏûêÎèô Ïä§ÌÅ¨Î°§
                const content = document.getElementById('timelineContent');
                const playheadX = this.currentTime * this.scale;
                if (playheadX > content.scrollLeft + content.clientWidth - 50) {
                    content.scrollLeft = playheadX - 100;
                } else if (playheadX < content.scrollLeft + 50) {
                    content.scrollLeft = Math.max(0, playheadX - 100);
                }
            },
            
            // ÏãúÍ∞Ñ Ïù¥Îèô
            seekTo(time) {
                this.setPlayhead(time);
            },
            
            // Ïû¨ÏÉù/Ï†ïÏßÄ ÌÜ†Í∏Ä
            togglePlay() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            },
            
            // Ïû¨ÏÉù
            play() {
                if (!this.animId) return;
                this.isPlaying = true;
                document.getElementById('tlPlayBtn').textContent = '‚è∏';
                document.getElementById('tlPlayBtn').classList.add('active');
                
                // Ïï†ÎãàÎ©îÏù¥ÏÖò Ïû¨ÏÉù
                playAnimation(this.animId, true);
                
                // ÌîåÎ†àÏù¥Ìó§Îìú ÎèôÍ∏∞Ìôî
                this.playStartTime = performance.now();
                const updateLoop = () => {
                    if (!this.isPlaying) return;
                    const elapsed = (performance.now() - this.playStartTime) / config.speed;
                    this.setPlayhead(elapsed);
                    
                    if (elapsed >= this.duration) {
                        if (this.isLoop) {
                            this.playStartTime = performance.now();
                            playAnimation(this.animId, true);
                        } else {
                            this.stop();
                        }
                    } else {
                        this.rafId = requestAnimationFrame(updateLoop);
                    }
                };
                this.rafId = requestAnimationFrame(updateLoop);
            },
            
            // ÏùºÏãúÏ†ïÏßÄ
            pause() {
                this.isPlaying = false;
                if (this.rafId) cancelAnimationFrame(this.rafId);
                document.getElementById('tlPlayBtn').textContent = '‚ñ∂';
                document.getElementById('tlPlayBtn').classList.remove('active');
            },
            
            // Ï†ïÏßÄ
            stop() {
                this.pause();
                this.setPlayhead(0);
                resetCharacters();
            },
            
            // Î£®ÌîÑ ÌÜ†Í∏Ä
            toggleLoop() {
                this.isLoop = !this.isLoop;
                document.getElementById('tlLoopBtn').classList.toggle('active', this.isLoop);
            },
            
            // Ï§å
            zoom(delta) {
                this.scale = Math.max(0.05, Math.min(1, this.scale + delta));
                this.renderRuler();
                this.render();
                this.setPlayhead(this.currentTime);
            },
            
            // Ìå®ÎÑê ÌÜ†Í∏Ä
            toggle() {
                this.isVisible = !this.isVisible;
                const panel = document.getElementById('timelinePanel');
                const main = document.querySelector('.main-container');
                const btn = document.getElementById('tlToggleBtn');
                
                panel.classList.toggle('collapsed', !this.isVisible);
                main.classList.toggle('timeline-collapsed', !this.isVisible);
                btn.textContent = this.isVisible ? '‚ñº' : '‚ñ≤';
            },
            
            // ÌÅ¥Î¶¨Ïñ¥
            clear() {
                this.tracks = { player: [], enemy: [], vfx: [], camera: [], effects: [], damage: [] };
                this.duration = 2000;
                this.setPlayhead(0);
            }
        };
        
        // playAnimation ÎûòÌïë (ÌÉÄÏûÑÎùºÏù∏ Ïó∞Îèô)
        const _originalPlayAnimation = playAnimation;
        playAnimation = async function(id, skipReset) {
            Timeline.analyzeAnimation(id);
            return _originalPlayAnimation(id, skipReset);
        };
        
        // ÌÉÄÏûÑÎùºÏù∏ Ï¥àÍ∏∞Ìôî
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => Timeline.init(), 100);
        });
    </script>
</body>
</html>
