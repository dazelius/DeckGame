<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¬ Animation Test Tool - Shadow Deck</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* í—¤ë” */
        .header {
            background: linear-gradient(180deg, #1a1a2e 0%, #16162a 100%);
            border-bottom: 2px solid #3a3a5a;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        
        .header h1 {
            font-family: 'Cinzel', serif;
            color: #fbbf24;
            font-size: 1.3rem;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }
        
        .header-buttons {
            display: flex;
            gap: 8px;
        }
        
        .header-btn {
            background: #3a3a5a;
            color: #fff;
            border: 1px solid #5a5a7a;
            padding: 6px 14px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        
        .header-btn:hover {
            background: #4a4a6a;
            border-color: #fbbf24;
        }
        
        .header-btn.primary {
            background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%);
            border-color: #fbbf24;
            color: #000;
            font-weight: bold;
        }
        
        /* ë©”ì¸ ë ˆì´ì•„ì›ƒ */
        .main-container {
            display: flex;
            height: 100vh;
            padding-top: 52px;
        }
        
        /* ì™¼ìª½ íŒ¨ë„ - ì»¨íŠ¸ë¡¤ */
        .control-panel {
            width: 320px;
            background: #12121a;
            border-right: 1px solid #2a2a3a;
            overflow-y: auto;
            padding: 15px;
        }
        
        .panel-section {
            background: #1a1a28;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .panel-section h3 {
            color: #fbbf24;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3a3a5a;
        }
        
        .anim-category {
            margin-bottom: 8px;
        }
        
        .anim-category-title {
            color: #888;
            font-size: 0.75rem;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        
        .anim-btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .anim-btn {
            background: #252535;
            color: #ccc;
            border: 1px solid #3a3a5a;
            padding: 8px 6px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            text-align: center;
        }
        
        .anim-btn:hover {
            background: #353550;
            border-color: #60a5fa;
            color: #fff;
        }
        
        .anim-btn.active {
            background: linear-gradient(180deg, #3a3a6a 0%, #2a2a5a 100%);
            border-color: #60a5fa;
            color: #60a5fa;
        }
        
        .anim-btn.player { border-left: 3px solid #60a5fa; }
        .anim-btn.enemy { border-left: 3px solid #ef4444; }
        .anim-btn.card { border-left: 3px solid #a78bfa; }
        
        /* ì‹œí€€ìŠ¤ ë¹Œë” */
        .sequence-builder {
            background: #0f0f18;
            border-radius: 6px;
            padding: 10px;
            min-height: 60px;
            margin-top: 10px;
        }
        
        .sequence-item {
            display: inline-block;
            background: #2a2a4a;
            color: #fff;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            font-size: 0.7rem;
        }
        
        .sequence-item.player { background: #1e3a5f; }
        .sequence-item.enemy { background: #5f1e1e; }
        
        /* í”„ë¦¬ë·° ì»¨íŠ¸ë¡¤ */
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .control-row label {
            color: #888;
            font-size: 0.8rem;
            min-width: 50px;
        }
        
        .control-row input[type="range"] {
            flex: 1;
        }
        
        .control-row .value {
            color: #60a5fa;
            font-size: 0.8rem;
            min-width: 40px;
            text-align: right;
        }
        
        .play-controls {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }
        
        .play-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .play-btn.play {
            background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
            color: #fff;
        }
        
        .play-btn.stop {
            background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);
            color: #fff;
        }
        
        .play-btn:hover {
            transform: scale(1.02);
        }
        
        /* ì¤‘ì•™ - ìŠ¤í…Œì´ì§€ */
        .stage-container {
            flex: 1;
            position: relative;
            background: #0a0a12;
            overflow: hidden;
        }
        
        #pixiCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* VFX ìº”ë²„ìŠ¤ */
        #vfxCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        /* ìŠ¤í…Œì´ì§€ ì˜¤ë²„ë ˆì´ */
        .stage-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            border: 1px solid #3a3a5a;
            border-radius: 8px;
            padding: 12px 15px;
            font-family: monospace;
            font-size: 0.75rem;
            z-index: 20;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            color: #888;
            margin-bottom: 3px;
        }
        
        .stat-row .value {
            color: #60a5fa;
        }
        
        /* ì˜¤ë¥¸ìª½ íŒ¨ë„ - ë¡œê·¸ */
        .log-panel {
            width: 280px;
            background: #12121a;
            border-left: 1px solid #2a2a3a;
            display: flex;
            flex-direction: column;
        }
        
        .log-header {
            padding: 10px 15px;
            background: #1a1a28;
            border-bottom: 1px solid #2a2a4a;
            font-size: 0.85rem;
            color: #fbbf24;
        }
        
        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 0.75rem;
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2a;
        }
        
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #34d399; }
        .log-entry.warn { color: #fbbf24; }
        .log-entry.error { color: #ef4444; }
        .log-entry.anim { color: #a78bfa; }
        
        .log-time {
            color: #555;
            margin-right: 6px;
        }
        
        /* í”„ë¦¬ì…‹ ë²„íŠ¼ë“¤ */
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        
        .preset-btn {
            background: linear-gradient(180deg, #4a4a6a 0%, #3a3a5a 100%);
            color: #fff;
            border: 1px solid #5a5a8a;
            padding: 10px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            text-align: center;
            transition: all 0.2s;
        }
        
        .preset-btn:hover {
            background: linear-gradient(180deg, #5a5a8a 0%, #4a4a6a 100%);
            border-color: #fbbf24;
        }
        
        .preset-btn .emoji {
            display: block;
            font-size: 1.5rem;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ¬ Animation Simulator</h1>
        <div class="header-buttons">
            <button class="header-btn" onclick="resetStage()">ğŸ”„ ë¦¬ì…‹</button>
            <button class="header-btn" onclick="toggleStats()">ğŸ“Š ìŠ¤íƒ¯</button>
            <button class="header-btn primary" onclick="location.href='index.html'">ğŸ® ê²Œì„ìœ¼ë¡œ</button>
        </div>
    </div>
    
    <div class="main-container">
        <!-- ì™¼ìª½: ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
        <div class="control-panel">
            <!-- í”„ë¦¬ì…‹ ì‹œë®¬ë ˆì´ì…˜ -->
            <div class="panel-section">
                <h3>âš¡ í”„ë¦¬ì…‹ ì‹œë®¬ë ˆì´ì…˜</h3>
                <div class="preset-grid">
                    <button class="preset-btn" onclick="runPreset('playerAttack')">
                        <span class="emoji">âš”ï¸</span>
                        í”Œë ˆì´ì–´ ê³µê²©
                    </button>
                    <button class="preset-btn" onclick="runPreset('enemyAttack')">
                        <span class="emoji">ğŸ‘¹</span>
                        ëª¬ìŠ¤í„° ê³µê²©
                    </button>
                    <button class="preset-btn" onclick="runPreset('flurry')">
                        <span class="emoji">ğŸ—¡ï¸</span>
                        ì—°ì† ì°Œë¥´ê¸°
                    </button>
                    <button class="preset-btn" onclick="runPreset('playerHit')">
                        <span class="emoji">ğŸ’¥</span>
                        í”Œë ˆì´ì–´ í”¼ê²©
                    </button>
                    <button class="preset-btn" onclick="runPreset('enemyHit')">
                        <span class="emoji">ğŸ©¸</span>
                        ëª¬ìŠ¤í„° í”¼ê²©
                    </button>
                    <button class="preset-btn" onclick="runPreset('defend')">
                        <span class="emoji">ğŸ›¡ï¸</span>
                        ë°©ì–´
                    </button>
                    <button class="preset-btn" onclick="runPreset('death')">
                        <span class="emoji">ğŸ’€</span>
                        ì‚¬ë§
                    </button>
                    <button class="preset-btn" onclick="runPreset('combo')">
                        <span class="emoji">ğŸ”¥</span>
                        ì½¤ë³´ ê³µê²©
                    </button>
                </div>
                
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #3a3a5a;">
                    <div class="anim-category-title">ğŸ“„ JSON ì‹œí€€ìŠ¤</div>
                    <div class="preset-grid">
                        <button class="preset-btn" onclick="runPreset('strike')" style="background: linear-gradient(180deg, #fbbf24 0%, #d97706 100%); color: #000;">
                            <span class="emoji">âš”ï¸</span>
                            card.strike
                        </button>
                        <button class="preset-btn" onclick="runPreset('bash')" style="background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);">
                            <span class="emoji">ğŸ’¥</span>
                            card.bash
                        </button>
                        <button class="preset-btn" onclick="runPreset('flurryP')" style="background: linear-gradient(180deg, #818cf8 0%, #6366f1 100%);">
                            <span class="emoji">ğŸ—¡ï¸</span>
                            card.flurryP
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- ê°œë³„ ì• ë‹ˆë©”ì´ì…˜ -->
            <div class="panel-section">
                <h3>ğŸ¬ ê°œë³„ ì• ë‹ˆë©”ì´ì…˜</h3>
                
                <div class="anim-category">
                    <div class="anim-category-title">ğŸ§‘ Player</div>
                    <div class="anim-btn-grid">
                        <button class="anim-btn player" onclick="playAnim('player', 'idle')">Idle</button>
                        <button class="anim-btn player" onclick="playAnim('player', 'dash')">Dash â†’</button>
                        <button class="anim-btn player" onclick="playAnim('player', 'attack')">Attack</button>
                        <button class="anim-btn player" onclick="playAnim('player', 'stab')">Stab</button>
                        <button class="anim-btn player" onclick="playAnim('player', 'hit')">Hit</button>
                        <button class="anim-btn player" onclick="playAnim('player', 'defend')">Defend</button>
                        <button class="anim-btn player" onclick="playAnim('player', 'return')">â† Return</button>
                        <button class="anim-btn player" onclick="playAnim('player', 'death')">Death</button>
                    </div>
                </div>
                
                <div class="anim-category">
                    <div class="anim-category-title">ğŸ‘¹ Enemy</div>
                    <div class="anim-btn-grid">
                        <button class="anim-btn enemy" onclick="playAnim('enemy', 'idle')">Idle</button>
                        <button class="anim-btn enemy" onclick="playAnim('enemy', 'dash')">â† Dash</button>
                        <button class="anim-btn enemy" onclick="playAnim('enemy', 'attack')">Attack</button>
                        <button class="anim-btn enemy" onclick="playAnim('enemy', 'hit')">Hit</button>
                        <button class="anim-btn enemy" onclick="playAnim('enemy', 'stun')">Stun</button>
                        <button class="anim-btn enemy" onclick="playAnim('enemy', 'return')">Return â†’</button>
                        <button class="anim-btn enemy" onclick="playAnim('enemy', 'death')">Death</button>
                        <button class="anim-btn enemy" onclick="playAnim('enemy', 'spawn')">Spawn</button>
                    </div>
                </div>
            </div>
            
            <!-- ì„¤ì • -->
            <div class="panel-section">
                <h3>âš™ï¸ ì„¤ì •</h3>
                <div class="control-row">
                    <label>ì†ë„:</label>
                    <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1" 
                        oninput="updateSpeed(this.value)">
                    <span class="value" id="speedValue">1.0x</span>
                </div>
                <div class="control-row">
                    <label>VFX:</label>
                    <input type="checkbox" id="vfxEnabled" checked onchange="toggleVFX(this.checked)">
                    <span style="color: #888; font-size: 0.8rem;">ì´í™íŠ¸ í™œì„±í™”</span>
                </div>
                <div class="control-row">
                    <label>Shake:</label>
                    <input type="checkbox" id="shakeEnabled" checked onchange="toggleShake(this.checked)">
                    <span style="color: #888; font-size: 0.8rem;">í™”ë©´ í”ë“¤ë¦¼</span>
                </div>
            </div>
            
            <!-- ì¬ìƒ ì»¨íŠ¸ë¡¤ -->
            <div class="play-controls">
                <button class="play-btn stop" onclick="stopAll()">â¹ï¸ ì¤‘ì§€</button>
                <button class="play-btn play" onclick="resetStage()">ğŸ”„ ë¦¬ì…‹</button>
            </div>
        </div>
        
        <!-- ì¤‘ì•™: ìŠ¤í…Œì´ì§€ -->
        <div class="stage-container">
            <div id="pixiCanvas"></div>
            <canvas id="vfxCanvas"></canvas>
            
            <div class="stage-overlay" id="statsOverlay">
                <div class="stat-row">
                    <span>Player X:</span>
                    <span class="value" id="statPlayerX">0</span>
                </div>
                <div class="stat-row">
                    <span>Player Scale:</span>
                    <span class="value" id="statPlayerScale">1.0</span>
                </div>
                <div class="stat-row">
                    <span>Enemy X:</span>
                    <span class="value" id="statEnemyX">0</span>
                </div>
                <div class="stat-row">
                    <span>Enemy Scale:</span>
                    <span class="value" id="statEnemyScale">1.0</span>
                </div>
                <div class="stat-row">
                    <span>FPS:</span>
                    <span class="value" id="statFPS">60</span>
                </div>
            </div>
        </div>
        
        <!-- ì˜¤ë¥¸ìª½: ë¡œê·¸ -->
        <div class="log-panel">
            <div class="log-header">ğŸ“œ ì• ë‹ˆë©”ì´ì…˜ ë¡œê·¸</div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>
    
    <!-- ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/PixiPlugin.min.js"></script>
    
    <script>
        // ==========================================
        // JSON ì• ë‹ˆë©”ì´ì…˜ ë¡œë” (ì¸ë¼ì¸)
        // ==========================================
        const AnimData = {
            cache: new Map(),
            basePath: 'anim/',
            
            async load(id) {
                if (this.cache.has(id)) return this.cache.get(id);
                
                try {
                    const response = await fetch(`${this.basePath}${id}.json`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    this.cache.set(id, data);
                    console.log(`[AnimData] âœ… ë¡œë“œ: ${id}`);
                    return data;
                } catch (e) {
                    console.warn(`[AnimData] âš ï¸ ë¡œë“œ ì‹¤íŒ¨: ${id}`);
                    return null;
                }
            },
            
            get(id) {
                return this.cache.get(id) || null;
            },
            
            async preload(ids) {
                await Promise.all(ids.map(id => this.load(id)));
            }
        };
    </script>
    
    <script>
        // ==========================================
        // ì• ë‹ˆë©”ì´ì…˜ ì‹œë®¬ë ˆì´í„°
        // ==========================================
        
        let app = null;
        let playerSprite = null;
        let enemySprite = null;
        let playerContainer = null;
        let enemyContainer = null;
        let vfxCtx = null;
        
        // ì„¤ì •
        const config = {
            speed: 1.0,
            vfxEnabled: true,
            shakeEnabled: true,
            playerBaseX: 0,
            enemyBaseX: 0,
            baseY: 0
        };
        
        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', async () => {
            await initPixi();
            initVFX();
            startUpdateLoop();
            
            // JSON ì• ë‹ˆë©”ì´ì…˜ ì‚¬ì „ ë¡œë“œ
            await loadAnimations();
            
            log('info', 'ì‹œë®¬ë ˆì´í„° ì´ˆê¸°í™” ì™„ë£Œ');
        });
        
        // JSON ì• ë‹ˆë©”ì´ì…˜ ë¡œë“œ
        async function loadAnimations() {
            log('info', 'ğŸ“‚ ì• ë‹ˆë©”ì´ì…˜ ë°ì´í„° ë¡œë“œ ì¤‘...');
            
            const animations = [
                'player.attack', 'player.stab', 'player.hit', 'player.dash', 
                'player.defend', 'player.return',
                'enemy.attack', 'enemy.hit', 'enemy.dash',
                'card.strike', 'card.bash', 'card.flurry', 'card.flurryP'
            ];
            
            await AnimData.preload(animations);
            
            log('success', `âœ… ${AnimData.cache.size}ê°œ ì• ë‹ˆë©”ì´ì…˜ ë¡œë“œ ì™„ë£Œ`);
            
            // ë¡œë“œëœ ëª©ë¡ í‘œì‹œ
            updateAnimList();
        }
        
        // ë¡œë“œëœ ì• ë‹ˆë©”ì´ì…˜ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateAnimList() {
            AnimData.cache.forEach((anim, id) => {
                log('anim', `  ğŸ“„ ${id}: ${anim.name || id}`);
            });
        }
        
        // PixiJS ì´ˆê¸°í™”
        async function initPixi() {
            const container = document.getElementById('pixiCanvas');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // PixiJS 7 ë°©ì‹ (ìƒì„±ìì—ì„œ ì˜µì…˜ ì „ë‹¬)
            app = new PIXI.Application({
                width: width,
                height: height,
                backgroundColor: 0x0a0a12,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            
            container.appendChild(app.view);
            
            // GSAP PixiPlugin ë“±ë¡
            gsap.registerPlugin(PixiPlugin);
            PixiPlugin.registerPIXI(PIXI);
            
            // ë°°ê²½ ê·¸ë¦¬ë“œ
            drawBackground();
            
            // ìºë¦­í„° ìƒì„±
            createCharacters(width, height);
            
            // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ëŸ¬
            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                app.renderer.resize(w, h);
                repositionCharacters(w, h);
            });
            
            log('success', 'PixiJS ì´ˆê¸°í™” ì™„ë£Œ');
        }
        
        // ë°°ê²½ ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
        function drawBackground() {
            const bg = new PIXI.Graphics();
            const w = app.screen.width;
            const h = app.screen.height;
            
            // ë°°ê²½ (PixiJS 7 ìŠ¤íƒ€ì¼)
            bg.beginFill(0x0a0a12);
            bg.drawRect(0, 0, w, h);
            bg.endFill();
            
            // ê·¸ë¦¬ë“œ ë¼ì¸
            bg.lineStyle(1, 0x1a1a2a, 0.5);
            for (let x = 0; x < w; x += 50) {
                bg.moveTo(x, 0);
                bg.lineTo(x, h);
            }
            for (let y = 0; y < h; y += 50) {
                bg.moveTo(0, y);
                bg.lineTo(w, y);
            }
            
            // ì¤‘ì•™ì„ 
            bg.lineStyle(2, 0x3a3a5a, 0.5);
            bg.moveTo(w / 2, 0);
            bg.lineTo(w / 2, h);
            
            // ë°”ë‹¥ì„ 
            const groundY = h * 0.7;
            bg.lineStyle(3, 0x4a4a6a, 0.8);
            bg.moveTo(0, groundY);
            bg.lineTo(w, groundY);
            
            app.stage.addChild(bg);
        }
        
        // ìºë¦­í„° ìƒì„±
        function createCharacters(width, height) {
            const groundY = height * 0.65;
            config.baseY = groundY;
            
            // í”Œë ˆì´ì–´ ì»¨í…Œì´ë„ˆ
            playerContainer = new PIXI.Container();
            playerContainer.x = width * 0.25;
            playerContainer.y = groundY;
            config.playerBaseX = playerContainer.x;
            
            // í”Œë ˆì´ì–´ ìŠ¤í”„ë¼ì´íŠ¸ (ì„ì‹œ ê·¸ë˜í”½)
            playerSprite = createCharacterGraphic(0x60a5fa, 'ğŸ§™', 'PLAYER');
            playerContainer.addChild(playerSprite);
            app.stage.addChild(playerContainer);
            
            // ì  ì»¨í…Œì´ë„ˆ
            enemyContainer = new PIXI.Container();
            enemyContainer.x = width * 0.75;
            enemyContainer.y = groundY;
            config.enemyBaseX = enemyContainer.x;
            
            // ì  ìŠ¤í”„ë¼ì´íŠ¸
            enemySprite = createCharacterGraphic(0xef4444, 'ğŸ‘¹', 'ENEMY');
            enemyContainer.addChild(enemySprite);
            app.stage.addChild(enemyContainer);
            
            // ìˆ¨ì‰¬ê¸° ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
            startBreathing();
        }
        
        // ìºë¦­í„° ê·¸ë˜í”½ ìƒì„± (PixiJS 7 ìŠ¤íƒ€ì¼)
        function createCharacterGraphic(color, emoji, label) {
            const container = new PIXI.Container();
            
            // ë°”ë””
            const body = new PIXI.Graphics();
            body.beginFill(color, 0.9);
            body.lineStyle(3, 0xffffff, 0.3);
            body.drawRoundedRect(-50, -120, 100, 120, 10);
            body.endFill();
            container.addChild(body);
            
            // ê·¸ë¦¼ì
            const shadow = new PIXI.Graphics();
            shadow.beginFill(0x000000, 0.4);
            shadow.drawEllipse(0, 5, 40, 10);
            shadow.endFill();
            container.addChild(shadow);
            
            // ì´ëª¨ì§€ í…ìŠ¤íŠ¸ (PixiJS 7 ìŠ¤íƒ€ì¼)
            const emojiText = new PIXI.Text(emoji, { fontSize: 50 });
            emojiText.anchor.set(0.5);
            emojiText.y = -70;
            container.addChild(emojiText);
            
            // ë¼ë²¨ (PixiJS 7 ìŠ¤íƒ€ì¼)
            const labelText = new PIXI.Text(label, {
                fontFamily: 'Cinzel',
                fontSize: 14,
                fill: 0xffffff,
                fontWeight: 'bold'
            });
            labelText.anchor.set(0.5);
            labelText.y = -15;
            container.addChild(labelText);
            
            return container;
        }
        
        // ìºë¦­í„° ì¬ë°°ì¹˜
        function repositionCharacters(width, height) {
            const groundY = height * 0.65;
            config.baseY = groundY;
            
            playerContainer.x = width * 0.25;
            playerContainer.y = groundY;
            config.playerBaseX = playerContainer.x;
            
            enemyContainer.x = width * 0.75;
            enemyContainer.y = groundY;
            config.enemyBaseX = enemyContainer.x;
        }
        
        // ìˆ¨ì‰¬ê¸° ì• ë‹ˆë©”ì´ì…˜
        function startBreathing() {
            gsap.to(playerContainer.scale, {
                x: 1.02,
                y: 1.02,
                duration: 1.5,
                ease: 'sine.inOut',
                repeat: -1,
                yoyo: true
            });
            
            gsap.to(enemyContainer.scale, {
                x: 1.02,
                y: 1.02,
                duration: 1.2,
                ease: 'sine.inOut',
                repeat: -1,
                yoyo: true,
                delay: 0.3
            });
        }
        
        // VFX ì´ˆê¸°í™”
        function initVFX() {
            const canvas = document.getElementById('vfxCanvas');
            const container = document.querySelector('.stage-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            vfxCtx = canvas.getContext('2d');
            
            window.addEventListener('resize', () => {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            });
        }
        
        // ==========================================
        // ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜ë“¤
        // ==========================================
        
        // JSON ë°ì´í„° ê¸°ë°˜ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
        async function playAnimFromJSON(animId) {
            const animData = AnimData.get(animId);
            
            if (!animData) {
                log('warn', `âš ï¸ ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ: ${animId}, ë¡œë“œ ì‹œë„...`);
                const loaded = await AnimData.load(animId);
                if (!loaded) {
                    log('error', `âŒ ë¡œë“œ ì‹¤íŒ¨: ${animId}`);
                    return;
                }
                return playAnimFromJSON(animId);
            }
            
            log('anim', `â–¶ï¸ [JSON] ${animId}: ${animData.name}`);
            
            const target = animData.target || 'player';
            const container = target === 'player' ? playerContainer : enemyContainer;
            const sprite = target === 'player' ? playerSprite : enemySprite;
            const baseX = target === 'player' ? config.playerBaseX : config.enemyBaseX;
            const direction = target === 'player' ? 1 : -1;
            
            // ì´ì „ ì• ë‹ˆë©”ì´ì…˜ í‚¬
            gsap.killTweensOf(container);
            gsap.killTweensOf(container.scale);
            gsap.killTweensOf(sprite);
            
            // ì‹œí€€ìŠ¤ íƒ€ì…
            if (animData.type === 'sequence' && animData.steps) {
                return playSequenceFromJSON(animData);
            }
            
            // í‚¤í”„ë ˆì„ íƒ€ì…
            if (animData.keyframes) {
                return playKeyframesFromJSON(animData, container, sprite, direction, baseX);
            }
        }
        
        // ì‹œí€€ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
        async function playSequenceFromJSON(animData) {
            log('anim', `ğŸ¬ ì‹œí€€ìŠ¤ ì‹œì‘: ${animData.id}`);
            
            for (const step of animData.steps) {
                if (step.delay) {
                    await delay(step.delay);
                    continue;
                }
                
                if (step.anim) {
                    const promise = playAnimFromJSON(step.anim);
                    
                    if (step.callback) {
                        log('info', `ğŸ“ ì½œë°±: ${step.callback}(${step.callbackArg})`);
                    }
                    
                    if (step.wait) {
                        await promise;
                    }
                }
            }
            
            log('success', `âœ… ì‹œí€€ìŠ¤ ì™„ë£Œ: ${animData.id}`);
        }
        
        // í‚¤í”„ë ˆì„ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
        function playKeyframesFromJSON(animData, container, sprite, direction, baseX) {
            return new Promise((resolve) => {
                const tl = gsap.timeline({ 
                    timeScale: config.speed,
                    onComplete: resolve
                });
                
                let elapsed = 0;
                
                animData.keyframes.forEach((kf, index) => {
                    if (index === 0) return; // ì²« í”„ë ˆì„ì€ ì´ˆê¸°ê°’
                    
                    const duration = (kf.duration || 100) / 1000;
                    const ease = kf.ease || 'power2.out';
                    
                    // ìŠ¤í”„ë¼ì´íŠ¸ íŠ¸ìœˆ
                    const spriteProps = {};
                    if (kf.x !== undefined) spriteProps.x = kf.x * direction;
                    if (kf.rotation !== undefined) spriteProps.rotation = kf.rotation * direction;
                    if (kf.scaleX !== undefined) spriteProps.scaleX = kf.scaleX;
                    if (kf.scaleY !== undefined) spriteProps.scaleY = kf.scaleY;
                    
                    if (Object.keys(spriteProps).length > 0) {
                        tl.to(sprite, { ...spriteProps, duration, ease }, elapsed);
                    }
                    
                    // ì´ë²¤íŠ¸ ì²˜ë¦¬
                    if (animData.events?.onPeak?.frame === index) {
                        const event = animData.events.onPeak;
                        tl.call(() => {
                            if (config.vfxEnabled && event.vfx) {
                                const pos = container.getGlobalPosition();
                                if (event.vfx === 'slash' || event.vfx === 'stab') {
                                    createSlashVFX(pos.x + 50 * direction, pos.y - 60, event.vfx === 'stab');
                                } else if (event.vfx === 'hit' || event.vfx === 'blood') {
                                    createHitVFX(pos.x, pos.y - 60);
                                } else if (event.vfx === 'shield') {
                                    createShieldVFX(pos.x, pos.y - 60);
                                }
                            }
                            if (config.shakeEnabled && event.shake) {
                                screenShake(event.shake);
                            }
                        }, null, elapsed + duration * 0.5);
                    }
                    
                    elapsed += duration;
                });
                
                // returnToBase ì²˜ë¦¬
                if (animData.returnToBase) {
                    tl.to(container, { x: baseX, duration: 0.2, ease: 'power2.out' }, elapsed);
                }
            });
        }
        
        function playAnim(target, animName) {
            // JSON ë°ì´í„° ë¨¼ì € í™•ì¸
            const animId = `${target}.${animName}`;
            if (AnimData.has(animId)) {
                return playAnimFromJSON(animId);
            }
            
            // í´ë°±: í•˜ë“œì½”ë”©ëœ ì• ë‹ˆë©”ì´ì…˜
            log('anim', `â–¶ï¸ ${target}.${animName}`);
            
            const container = target === 'player' ? playerContainer : enemyContainer;
            const sprite = target === 'player' ? playerSprite : enemySprite;
            const baseX = target === 'player' ? config.playerBaseX : config.enemyBaseX;
            const direction = target === 'player' ? 1 : -1;
            
            // ì´ì „ ì• ë‹ˆë©”ì´ì…˜ í‚¬
            gsap.killTweensOf(container);
            gsap.killTweensOf(container.scale);
            gsap.killTweensOf(sprite);
            
            switch (animName) {
                case 'idle':
                    gsap.to(container.scale, {
                        x: 1.02, y: 1.02,
                        duration: 1.5 / config.speed,
                        ease: 'sine.inOut',
                        repeat: -1,
                        yoyo: true
                    });
                    break;
                    
                case 'dash':
                    const dashDist = target === 'player' ? 200 : -200;
                    gsap.timeline({ timeScale: config.speed })
                        .to(container, {
                            x: baseX + dashDist,
                            duration: 0.15,
                            ease: 'power2.out'
                        })
                        .to(container.scale, {
                            x: 1.1, y: 0.95,
                            duration: 0.1,
                            ease: 'power2.out'
                        }, 0);
                    break;
                    
                case 'attack':
                    gsap.timeline({ timeScale: config.speed })
                        .to(sprite, {
                            x: -10 * direction,
                            scaleX: 0.95,
                            scaleY: 1.05,
                            duration: 0.05,
                            ease: 'power2.in'
                        })
                        .to(sprite, {
                            x: 30 * direction,
                            scaleX: 1.15,
                            scaleY: 0.9,
                            duration: 0.06,
                            ease: 'power4.out',
                            onComplete: () => {
                                if (config.vfxEnabled) {
                                    const pos = container.getGlobalPosition();
                                    createSlashVFX(pos.x + 50 * direction, pos.y - 60);
                                }
                                if (config.shakeEnabled) {
                                    screenShake(8);
                                }
                            }
                        })
                        .to(sprite, {
                            x: 0,
                            scaleX: 1,
                            scaleY: 1,
                            duration: 0.1,
                            ease: 'power2.out'
                        });
                    break;
                    
                case 'stab':
                    gsap.timeline({ timeScale: config.speed })
                        .to(sprite, {
                            x: -8 * direction,
                            scaleX: 0.95,
                            scaleY: 1.05,
                            duration: 0.03,
                            ease: 'power2.in'
                        })
                        .to(sprite, {
                            x: 25 * direction,
                            scaleX: 1.1,
                            scaleY: 0.92,
                            duration: 0.03,
                            ease: 'power4.out',
                            onComplete: () => {
                                if (config.vfxEnabled) {
                                    const pos = container.getGlobalPosition();
                                    createSlashVFX(pos.x + 40 * direction, pos.y - 50, true);
                                }
                            }
                        })
                        .to(sprite, {
                            x: 0,
                            scaleX: 1,
                            scaleY: 1,
                            duration: 0.06,
                            ease: 'power2.out'
                        });
                    break;
                    
                case 'hit':
                    const hitDir = target === 'player' ? -1 : 1;
                    gsap.timeline({ timeScale: config.speed })
                        .to(container, {
                            x: container.x + 15 * hitDir,
                            duration: 0.04,
                            ease: 'power4.out'
                        }, 0)
                        .to(container.scale, {
                            x: 0.85,
                            y: 1.15,
                            duration: 0.04,
                            ease: 'power4.out',
                            onComplete: () => {
                                if (config.vfxEnabled) {
                                    const pos = container.getGlobalPosition();
                                    createHitVFX(pos.x, pos.y - 60);
                                }
                                if (config.shakeEnabled) {
                                    screenShake(12);
                                }
                            }
                        }, 0)
                        .to({}, { duration: 0.08 }) // íˆíŠ¸ìŠ¤íƒ‘
                        .to(container, {
                            x: baseX,
                            duration: 0.2,
                            ease: 'elastic.out(1, 0.5)'
                        })
                        .to(container.scale, {
                            x: 1,
                            y: 1,
                            duration: 0.2,
                            ease: 'elastic.out(1, 0.5)'
                        }, '<');
                    break;
                    
                case 'defend':
                    gsap.timeline({ timeScale: config.speed })
                        .to(container.scale, {
                            x: 0.9,
                            y: 1.1,
                            duration: 0.1,
                            ease: 'power2.out',
                            onComplete: () => {
                                if (config.vfxEnabled) {
                                    const pos = container.getGlobalPosition();
                                    createShieldVFX(pos.x, pos.y - 60);
                                }
                            }
                        })
                        .to(container.scale, {
                            x: 1,
                            y: 1,
                            duration: 0.3,
                            ease: 'elastic.out(1, 0.5)'
                        });
                    break;
                    
                case 'return':
                    gsap.to(container, {
                        x: baseX,
                        duration: 0.2 / config.speed,
                        ease: 'power2.out'
                    });
                    gsap.to(container.scale, {
                        x: 1,
                        y: 1,
                        duration: 0.2 / config.speed,
                        ease: 'power2.out'
                    });
                    break;
                    
                case 'death':
                    gsap.timeline({ timeScale: config.speed })
                        .to(container.scale, {
                            x: 1.1,
                            y: 0.9,
                            duration: 0.1,
                            ease: 'power2.out'
                        })
                        .to(container, {
                            alpha: 0,
                            y: config.baseY + 50,
                            rotation: 0.3,
                            duration: 0.5,
                            ease: 'power2.in'
                        })
                        .to(container.scale, {
                            x: 0.5,
                            y: 1.5,
                            duration: 0.5,
                            ease: 'power2.in'
                        }, '<');
                    break;
                    
                case 'stun':
                    gsap.timeline({ timeScale: config.speed, repeat: 2 })
                        .to(container, {
                            rotation: -0.1,
                            duration: 0.08,
                            ease: 'power2.inOut'
                        })
                        .to(container, {
                            rotation: 0.1,
                            duration: 0.08,
                            ease: 'power2.inOut'
                        })
                        .to(container, {
                            rotation: 0,
                            duration: 0.08,
                            ease: 'power2.out'
                        });
                    break;
                    
                case 'spawn':
                    container.alpha = 0;
                    container.scale.set(0);
                    container.y = config.baseY - 100;
                    
                    gsap.timeline({ timeScale: config.speed })
                        .to(container, {
                            alpha: 1,
                            y: config.baseY,
                            duration: 0.3,
                            ease: 'back.out(2)'
                        })
                        .to(container.scale, {
                            x: 1,
                            y: 1,
                            duration: 0.3,
                            ease: 'back.out(2)'
                        }, '<');
                    break;
            }
        }
        
        // ==========================================
        // í”„ë¦¬ì…‹ ì‹œí€€ìŠ¤
        // ==========================================
        
        async function runPreset(presetName) {
            log('info', `ğŸ¬ í”„ë¦¬ì…‹ ì‹œì‘: ${presetName}`);
            
            // ë¨¼ì € ë¦¬ì…‹
            resetCharacters();
            await delay(100);
            
            switch (presetName) {
                case 'playerAttack':
                    // í”Œë ˆì´ì–´ â†’ ì  ê³µê²© ì‹œí€€ìŠ¤
                    playAnim('player', 'dash');
                    await delay(150);
                    playAnim('player', 'attack');
                    await delay(100);
                    playAnim('enemy', 'hit');
                    await delay(300);
                    playAnim('player', 'return');
                    break;
                    
                case 'enemyAttack':
                    // ì  â†’ í”Œë ˆì´ì–´ ê³µê²© ì‹œí€€ìŠ¤
                    playAnim('enemy', 'dash');
                    await delay(150);
                    playAnim('enemy', 'attack');
                    await delay(100);
                    playAnim('player', 'hit');
                    await delay(300);
                    playAnim('enemy', 'return');
                    break;
                    
                case 'flurry':
                    // JSON ì‹œí€€ìŠ¤ ì‚¬ìš©
                    if (AnimData.has('card.flurry')) {
                        await playAnimFromJSON('card.flurry');
                    } else {
                        // í´ë°±: í•˜ë“œì½”ë”©
                        playAnim('player', 'dash');
                        await delay(150);
                        
                        for (let i = 0; i < 3; i++) {
                            playAnim('player', 'stab');
                            await delay(50);
                            playAnim('enemy', 'hit');
                            log('anim', `ğŸ’¥ ${i + 1}ë²ˆì§¸ íƒ€ê²©!`);
                            await delay(150);
                        }
                        
                        await delay(100);
                        playAnim('player', 'return');
                    }
                    break;
                    
                case 'flurryP':
                    // JSON ì‹œí€€ìŠ¤ ì‚¬ìš© (ì—°ì† ì°Œë¥´ê¸°+)
                    if (AnimData.has('card.flurryP')) {
                        await playAnimFromJSON('card.flurryP');
                    }
                    break;
                    
                case 'strike':
                    // JSON ì‹œí€€ìŠ¤ ì‚¬ìš© (ë² ê¸°)
                    if (AnimData.has('card.strike')) {
                        await playAnimFromJSON('card.strike');
                    }
                    break;
                    
                case 'bash':
                    // JSON ì‹œí€€ìŠ¤ ì‚¬ìš© (ê°•íƒ€)
                    if (AnimData.has('card.bash')) {
                        await playAnimFromJSON('card.bash');
                    }
                    break;
                    
                case 'playerHit':
                    playAnim('player', 'hit');
                    break;
                    
                case 'enemyHit':
                    playAnim('enemy', 'hit');
                    break;
                    
                case 'defend':
                    playAnim('player', 'defend');
                    break;
                    
                case 'death':
                    playAnim('enemy', 'hit');
                    await delay(200);
                    playAnim('enemy', 'death');
                    break;
                    
                case 'combo':
                    // ì½¤ë³´ ê³µê²© (ê³µê²© â†’ ì°Œë¥´ê¸° â†’ ê°•íƒ€)
                    playAnim('player', 'dash');
                    await delay(150);
                    
                    playAnim('player', 'attack');
                    await delay(80);
                    playAnim('enemy', 'hit');
                    await delay(200);
                    
                    playAnim('player', 'stab');
                    await delay(50);
                    playAnim('enemy', 'hit');
                    await delay(200);
                    
                    playAnim('player', 'attack');
                    await delay(80);
                    playAnim('enemy', 'hit');
                    await delay(300);
                    
                    playAnim('player', 'return');
                    break;
            }
            
            log('success', `âœ… í”„ë¦¬ì…‹ ì™„ë£Œ: ${presetName}`);
        }
        
        // ==========================================
        // VFX í•¨ìˆ˜ë“¤
        // ==========================================
        
        function createSlashVFX(x, y, isStab = false) {
            if (!config.vfxEnabled) return;
            
            const particles = [];
            const color = isStab ? '#60a5fa' : '#fbbf24';
            const count = isStab ? 5 : 8;
            
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 10 - 5,
                    size: 3 + Math.random() * 4,
                    life: 1,
                    color: color
                });
            }
            
            // ìŠ¬ë˜ì‹œ ë¼ì¸
            const slashAnim = {
                x: x - 30,
                y: y - 20,
                length: 0,
                targetLength: 80,
                angle: isStab ? 0 : -30 + Math.random() * 20,
                life: 1,
                color: color
            };
            
            animateVFX(particles, slashAnim);
        }
        
        function createHitVFX(x, y) {
            if (!config.vfxEnabled) return;
            
            const particles = [];
            
            // í”¼ íŠ€ê¹€
            for (let i = 0; i < 12; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 15 - 3,
                    size: 2 + Math.random() * 5,
                    life: 1,
                    color: '#ef4444'
                });
            }
            
            animateVFX(particles, null);
        }
        
        function createShieldVFX(x, y) {
            if (!config.vfxEnabled) return;
            
            // ì‰´ë“œ ì´í™íŠ¸
            const ring = {
                x: x,
                y: y,
                radius: 0,
                targetRadius: 60,
                life: 1,
                color: '#60a5fa'
            };
            
            animateRing(ring);
        }
        
        function animateVFX(particles, slash) {
            let frame = 0;
            const maxFrames = 30;
            
            function draw() {
                if (frame >= maxFrames) return;
                
                // íŒŒí‹°í´
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.5; // ì¤‘ë ¥
                    p.life -= 0.03;
                    
                    if (p.life > 0) {
                        vfxCtx.beginPath();
                        vfxCtx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                        vfxCtx.fillStyle = p.color;
                        vfxCtx.globalAlpha = p.life;
                        vfxCtx.fill();
                    }
                });
                
                // ìŠ¬ë˜ì‹œ
                if (slash && slash.life > 0) {
                    slash.length = Math.min(slash.length + 15, slash.targetLength);
                    slash.life -= 0.08;
                    
                    vfxCtx.save();
                    vfxCtx.translate(slash.x, slash.y);
                    vfxCtx.rotate(slash.angle * Math.PI / 180);
                    
                    vfxCtx.beginPath();
                    vfxCtx.moveTo(0, 0);
                    vfxCtx.lineTo(slash.length, 0);
                    vfxCtx.strokeStyle = slash.color;
                    vfxCtx.lineWidth = 4 * slash.life;
                    vfxCtx.globalAlpha = slash.life;
                    vfxCtx.stroke();
                    
                    vfxCtx.restore();
                }
                
                vfxCtx.globalAlpha = 1;
                frame++;
                requestAnimationFrame(draw);
            }
            
            draw();
        }
        
        function animateRing(ring) {
            let frame = 0;
            const maxFrames = 20;
            
            function draw() {
                if (frame >= maxFrames) return;
                
                ring.radius = Math.min(ring.radius + 5, ring.targetRadius);
                ring.life -= 0.05;
                
                if (ring.life > 0) {
                    vfxCtx.beginPath();
                    vfxCtx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
                    vfxCtx.strokeStyle = ring.color;
                    vfxCtx.lineWidth = 3 * ring.life;
                    vfxCtx.globalAlpha = ring.life;
                    vfxCtx.stroke();
                }
                
                vfxCtx.globalAlpha = 1;
                frame++;
                requestAnimationFrame(draw);
            }
            
            draw();
        }
        
        // í™”ë©´ í”ë“¤ë¦¼
        function screenShake(intensity) {
            if (!config.shakeEnabled) return;
            
            const stage = app.stage;
            gsap.timeline()
                .to(stage, {
                    x: intensity,
                    y: intensity / 2,
                    duration: 0.02,
                    ease: 'none'
                })
                .to(stage, {
                    x: -intensity,
                    y: -intensity / 2,
                    duration: 0.02,
                    ease: 'none'
                })
                .to(stage, {
                    x: intensity / 2,
                    y: 0,
                    duration: 0.02,
                    ease: 'none'
                })
                .to(stage, {
                    x: 0,
                    y: 0,
                    duration: 0.05,
                    ease: 'power2.out'
                });
        }
        
        // ==========================================
        // ìœ í‹¸ë¦¬í‹°
        // ==========================================
        
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms / config.speed));
        }
        
        function stopAll() {
            gsap.killTweensOf(playerContainer);
            gsap.killTweensOf(playerContainer.scale);
            gsap.killTweensOf(playerSprite);
            gsap.killTweensOf(enemyContainer);
            gsap.killTweensOf(enemyContainer.scale);
            gsap.killTweensOf(enemySprite);
            gsap.killTweensOf(app.stage);
            
            resetCharacters();
            log('warn', 'â¹ï¸ ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€');
        }
        
        function resetCharacters() {
            // í”Œë ˆì´ì–´ ë¦¬ì…‹
            playerContainer.x = config.playerBaseX;
            playerContainer.y = config.baseY;
            playerContainer.alpha = 1;
            playerContainer.rotation = 0;
            playerContainer.scale.set(1);
            playerSprite.x = 0;
            playerSprite.y = 0;
            playerSprite.scale.set(1);
            
            // ì  ë¦¬ì…‹
            enemyContainer.x = config.enemyBaseX;
            enemyContainer.y = config.baseY;
            enemyContainer.alpha = 1;
            enemyContainer.rotation = 0;
            enemyContainer.scale.set(1);
            enemySprite.x = 0;
            enemySprite.y = 0;
            enemySprite.scale.set(1);
        }
        
        function resetStage() {
            stopAll();
            vfxCtx.clearRect(0, 0, vfxCtx.canvas.width, vfxCtx.canvas.height);
            app.stage.x = 0;
            app.stage.y = 0;
            startBreathing();
            log('info', 'ğŸ”„ ìŠ¤í…Œì´ì§€ ë¦¬ì…‹');
        }
        
        function updateSpeed(value) {
            config.speed = parseFloat(value);
            document.getElementById('speedValue').textContent = config.speed.toFixed(1) + 'x';
        }
        
        function toggleVFX(enabled) {
            config.vfxEnabled = enabled;
            log('info', `VFX: ${enabled ? 'ON' : 'OFF'}`);
        }
        
        function toggleShake(enabled) {
            config.shakeEnabled = enabled;
            log('info', `í™”ë©´ í”ë“¤ë¦¼: ${enabled ? 'ON' : 'OFF'}`);
        }
        
        function toggleStats() {
            const overlay = document.getElementById('statsOverlay');
            overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
        }
        
        // ì—…ë°ì´íŠ¸ ë£¨í”„
        function startUpdateLoop() {
            let lastTime = performance.now();
            let frameCount = 0;
            
            function update() {
                const now = performance.now();
                frameCount++;
                
                if (now - lastTime >= 1000) {
                    document.getElementById('statFPS').textContent = frameCount;
                    frameCount = 0;
                    lastTime = now;
                }
                
                // ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
                if (playerContainer && enemyContainer) {
                    document.getElementById('statPlayerX').textContent = Math.round(playerContainer.x);
                    document.getElementById('statPlayerScale').textContent = playerContainer.scale.x.toFixed(2);
                    document.getElementById('statEnemyX').textContent = Math.round(enemyContainer.x);
                    document.getElementById('statEnemyScale').textContent = enemyContainer.scale.x.toFixed(2);
                }
                
                // VFX ìº”ë²„ìŠ¤ í´ë¦¬ì–´ (íˆ¬ëª…ë„ ë‚®ì¶¤ìœ¼ë¡œ ì”ìƒ íš¨ê³¼)
                vfxCtx.fillStyle = 'rgba(10, 10, 18, 0.15)';
                vfxCtx.fillRect(0, 0, vfxCtx.canvas.width, vfxCtx.canvas.height);
                
                requestAnimationFrame(update);
            }
            
            update();
        }
        
        // ë¡œê·¸
        function log(type, message) {
            const container = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString('ko-KR', { 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit',
                fractionalSecondDigits: 2
            });
            
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${message}`;
            container.insertBefore(entry, container.firstChild);
            
            // ìµœëŒ€ 50ê°œ
            while (container.children.length > 50) {
                container.removeChild(container.lastChild);
            }
        }
    </script>
</body>
</html>
