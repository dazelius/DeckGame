<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé¨ JSON Animation Player - Shadow Deck</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .header {
            background: linear-gradient(180deg, #1a1a2e 0%, #16162a 100%);
            border-bottom: 2px solid #fbbf24;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            font-family: 'Cinzel', serif;
            color: #fbbf24;
            font-size: 1.3rem;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }
        
        .header-btn {
            background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%);
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
        }
        
        .main-container {
            display: flex;
            height: calc(100vh - 52px);
        }
        
        /* ÏôºÏ™Ω Ìå®ÎÑê */
        .control-panel {
            width: 300px;
            background: #12121a;
            border-right: 1px solid #2a2a3a;
            overflow-y: auto;
            padding: 15px;
        }
        
        .panel-section {
            background: #1a1a28;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .panel-section h3 {
            color: #fbbf24;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3a3a5a;
        }
        
        .anim-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .anim-item {
            background: #252535;
            border: 1px solid #3a3a5a;
            padding: 10px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .anim-item:hover {
            background: #353550;
            border-color: #60a5fa;
        }
        
        .anim-item.playing {
            background: linear-gradient(90deg, #1e3a5f 0%, #252535 100%);
            border-color: #60a5fa;
        }
        
        .anim-item .type {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
        }
        
        .anim-item .type.player { background: #3b82f6; color: #fff; }
        .anim-item .type.enemy { background: #ef4444; color: #fff; }
        .anim-item .type.card { background: #a78bfa; color: #fff; }
        
        .anim-item .name {
            flex: 1;
            font-size: 0.85rem;
        }
        
        .anim-item .duration {
            color: #888;
            font-size: 0.75rem;
        }
        
        /* Ïä§ÌîºÎìú Ïª®Ìä∏Î°§ */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .speed-control label { color: #888; font-size: 0.8rem; }
        .speed-control input { flex: 1; }
        .speed-control .value { color: #60a5fa; font-size: 0.8rem; min-width: 40px; text-align: right; }
        
        /* Ïä§ÌÖåÏù¥ÏßÄ */
        .stage-container {
            flex: 1;
            position: relative;
            background: #0a0a12;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #pixiContainer {
            width: 100%;
            height: 100%;
        }
        
        #vfxCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .stage-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #3a3a5a;
            border-radius: 8px;
            padding: 12px 15px;
            font-family: monospace;
            font-size: 0.75rem;
            z-index: 20;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            color: #888;
            margin-bottom: 3px;
        }
        
        .stat-row .value { color: #60a5fa; }
        
        /* Î°úÍ∑∏ Ìå®ÎÑê */
        .log-panel {
            width: 280px;
            background: #12121a;
            border-left: 1px solid #2a2a3a;
            display: flex;
            flex-direction: column;
        }
        
        .log-header {
            padding: 10px 15px;
            background: #1a1a28;
            border-bottom: 1px solid #2a2a4a;
            font-size: 0.85rem;
            color: #fbbf24;
            display: flex;
            justify-content: space-between;
        }
        
        .log-header button {
            background: #3a3a5a;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            color: #888;
            cursor: pointer;
            font-size: 0.7rem;
        }
        
        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 0.75rem;
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2a;
        }
        
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #34d399; }
        .log-entry.warn { color: #fbbf24; }
        .log-entry.error { color: #ef4444; }
        .log-entry.anim { color: #a78bfa; }
        
        .log-time { color: #555; margin-right: 6px; }
        
        /* JSON Î∑∞Ïñ¥ */
        .json-viewer {
            background: #0f0f18;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.7rem;
            color: #888;
            white-space: pre-wrap;
        }
        
        .json-viewer .key { color: #a78bfa; }
        .json-viewer .string { color: #34d399; }
        .json-viewer .number { color: #60a5fa; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé¨ JSON Animation Player</h1>
        <button class="header-btn" onclick="location.href='index.html'">üéÆ Í≤åÏûÑÏúºÎ°ú</button>
    </div>
    
    <div class="main-container">
        <!-- ÏôºÏ™Ω: JSON Ïï†ÎãàÎ©îÏù¥ÏÖò Î™©Î°ù -->
        <div class="control-panel">
            <div class="panel-section">
                <h3>üìÅ JSON Animations</h3>
                <div id="animList" class="anim-list">
                    <!-- ÎèôÏ†ÅÏúºÎ°ú Ï±ÑÏõåÏßê -->
                </div>
            </div>
            
            <div class="panel-section">
                <h3>‚öôÔ∏è ÏÑ§Ï†ï</h3>
                <div class="speed-control">
                    <label>ÏÜçÎèÑ</label>
                    <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1" onchange="updateSpeed()">
                    <span class="value" id="speedValue">1.0x</span>
                </div>
                <div class="speed-control">
                    <label>VFX</label>
                    <input type="checkbox" id="vfxToggle" checked>
                </div>
            </div>
            
            <div class="panel-section">
                <h3>üìã ÌòÑÏû¨ JSON</h3>
                <div id="jsonViewer" class="json-viewer">ÏÑ†ÌÉùÎêú Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÜÏùå</div>
            </div>
        </div>
        
        <!-- Ï§ëÏïô: Ïä§ÌÖåÏù¥ÏßÄ -->
        <div class="stage-container">
            <div id="pixiContainer"></div>
            <canvas id="vfxCanvas"></canvas>
            
            <div class="stage-overlay" id="statsOverlay">
                <div class="stat-row">
                    <span>Player X:</span>
                    <span class="value" id="playerX">0</span>
                </div>
                <div class="stat-row">
                    <span>Player Scale:</span>
                    <span class="value" id="playerScale">1.0</span>
                </div>
                <div class="stat-row">
                    <span>Enemy X:</span>
                    <span class="value" id="enemyX">0</span>
                </div>
                <div class="stat-row">
                    <span>FPS:</span>
                    <span class="value" id="fpsValue">60</span>
                </div>
            </div>
        </div>
        
        <!-- Ïò§Î•∏Ï™Ω: Î°úÍ∑∏ -->
        <div class="log-panel">
            <div class="log-header">
                <span>üìú Ïã§Ìñâ Î°úÍ∑∏</span>
                <button onclick="clearLog()">ÏßÄÏö∞Í∏∞</button>
            </div>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>

    <script>
        // ========== Ï†ÑÏó≠ Î≥ÄÏàò ==========
        let app = null;
        let playerContainer, playerSprite;
        let enemyContainer, enemySprite;
        let vfxCanvas, vfxCtx;
        
        const config = {
            speed: 1,
            vfx: true,
            playerBaseX: 0,
            enemyBaseX: 0,
            baseY: 0
        };
        
        const animCache = new Map();
        const ANIM_FILES = [
            'player.attack', 'player.dash', 'player.defend', 'player.hit', 'player.return', 'player.stab',
            'enemy.attack', 'enemy.dash', 'enemy.hit',
            'card.strike', 'card.bash', 'card.flurry', 'card.flurryP'
        ];
        
        // ========== Ï¥àÍ∏∞Ìôî ==========
        document.addEventListener('DOMContentLoaded', async () => {
            log('info', 'üé¨ Animation Player Ï¥àÍ∏∞Ìôî...');
            await initPixi();
            await loadAllAnimations();
            renderAnimList();
            startUpdateLoop();
            log('success', '‚úÖ Ï§ÄÎπÑ ÏôÑÎ£å!');
        });
        
        async function initPixi() {
            const container = document.getElementById('pixiContainer');
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 600;
            
            app = new PIXI.Application({
                width: width,
                height: height,
                backgroundColor: 0x0a0a12,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            container.appendChild(app.view);
            
            // VFX Ï∫îÎ≤ÑÏä§
            vfxCanvas = document.getElementById('vfxCanvas');
            vfxCanvas.width = width;
            vfxCanvas.height = height;
            vfxCtx = vfxCanvas.getContext('2d');
            
            // Î∞∞Í≤Ω Í∑∏Î¶¨Í∏∞
            drawBackground(width, height);
            
            // Ï∫êÎ¶≠ÌÑ∞ ÏÉùÏÑ±
            await createCharacters(width, height);
            
            log('info', `PixiJS Ï¥àÍ∏∞Ìôî ÏôÑÎ£å (${width}x${height})`);
        }
        
        function drawBackground(width, height) {
            const bg = new PIXI.Graphics();
            
            // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Î∞∞Í≤Ω (Í∞ÑÎã®Ìïú ÏÉâÏÉÅ Î∏îÎ°ù)
            bg.beginFill(0x1a1a28);
            bg.drawRect(0, 0, width, height);
            bg.endFill();
            
            // Î∞îÎã•ÏÑ†
            const groundY = height * 0.65;
            bg.lineStyle(2, 0x3a3a5a, 0.5);
            bg.moveTo(0, groundY);
            bg.lineTo(width, groundY);
            
            // Ï§ëÏïôÏÑ†
            bg.lineStyle(1, 0x2a2a4a, 0.3);
            bg.moveTo(width / 2, 0);
            bg.lineTo(width / 2, height);
            
            app.stage.addChild(bg);
        }
        
        async function createCharacters(width, height) {
            const groundY = height * 0.65;
            config.baseY = groundY;
            config.playerBaseX = width * 0.3;
            config.enemyBaseX = width * 0.7;
            
            // ÌîåÎ†àÏù¥Ïñ¥
            playerContainer = new PIXI.Container();
            playerContainer.x = config.playerBaseX;
            playerContainer.y = groundY;
            
            try {
                const texture = await PIXI.Assets.load('hero.png');
                playerSprite = new PIXI.Sprite(texture);
                playerSprite.anchor.set(0.5, 1);
                playerSprite.scale.set(0.8);
                log('success', '‚úÖ hero.png Î°úÎìú');
            } catch (e) {
                playerSprite = createFallbackSprite(0x60a5fa, 'P');
                log('warn', '‚ö†Ô∏è hero.png Ìè¥Î∞± ÏÇ¨Ïö©');
            }
            playerContainer.addChild(playerSprite);
            app.stage.addChild(playerContainer);
            
            // Ï†Å
            enemyContainer = new PIXI.Container();
            enemyContainer.x = config.enemyBaseX;
            enemyContainer.y = groundY;
            
            try {
                const texture = await PIXI.Assets.load('goblinarcher.png');
                enemySprite = new PIXI.Sprite(texture);
                enemySprite.anchor.set(0.5, 1);
                enemySprite.scale.set(0.8);
                log('success', '‚úÖ goblinarcher.png Î°úÎìú');
            } catch (e) {
                enemySprite = createFallbackSprite(0xef4444, 'E');
                log('warn', '‚ö†Ô∏è goblinarcher.png Ìè¥Î∞± ÏÇ¨Ïö©');
            }
            enemyContainer.addChild(enemySprite);
            app.stage.addChild(enemyContainer);
            
            // Ïà®Ïâ¨Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
            startBreathing();
        }
        
        function createFallbackSprite(color, letter) {
            const container = new PIXI.Container();
            
            const body = new PIXI.Graphics();
            body.beginFill(color);
            body.drawRoundedRect(-30, -100, 60, 100, 8);
            body.endFill();
            
            const text = new PIXI.Text(letter, {
                fontFamily: 'Arial',
                fontSize: 32,
                fill: 0xffffff,
                fontWeight: 'bold'
            });
            text.anchor.set(0.5);
            text.y = -50;
            
            container.addChild(body);
            container.addChild(text);
            return container;
        }
        
        function startBreathing() {
            // ÌîåÎ†àÏù¥Ïñ¥ Ïà®Ïâ¨Í∏∞
            gsap.to(playerSprite.scale, {
                y: 0.82,
                duration: 1.5,
                repeat: -1,
                yoyo: true,
                ease: 'sine.inOut'
            });
            
            // Ï†Å Ïà®Ïâ¨Í∏∞
            gsap.to(enemySprite.scale, {
                y: 0.82,
                duration: 1.3,
                repeat: -1,
                yoyo: true,
                ease: 'sine.inOut'
            });
        }
        
        // ========== JSON Î°úÎìú ==========
        async function loadAllAnimations() {
            log('info', 'üìÅ JSON Ïï†ÎãàÎ©îÏù¥ÏÖò Î°úÎìú Ï§ë...');
            
            for (const id of ANIM_FILES) {
                try {
                    const response = await fetch(`anim/${id}.json`);
                    if (response.ok) {
                        const data = await response.json();
                        animCache.set(id, data);
                        log('success', `‚úÖ ${id}.json`);
                    }
                } catch (e) {
                    log('warn', `‚ö†Ô∏è ${id}.json Î°úÎìú Ïã§Ìå®`);
                }
            }
            
            log('info', `Ï¥ù ${animCache.size}Í∞ú Ïï†ÎãàÎ©îÏù¥ÏÖò Î°úÎìúÎê®`);
        }
        
        function renderAnimList() {
            const container = document.getElementById('animList');
            container.innerHTML = '';
            
            animCache.forEach((data, id) => {
                const type = id.split('.')[0];
                const name = id.split('.')[1];
                const duration = calculateDuration(data);
                
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = id;
                item.innerHTML = `
                    <span class="type ${type}">${type}</span>
                    <span class="name">${name}</span>
                    <span class="duration">${duration}ms</span>
                `;
                item.onclick = () => playAnimation(id);
                container.appendChild(item);
            });
        }
        
        function calculateDuration(data) {
            if (data.keyframes) {
                return data.keyframes.reduce((sum, kf) => sum + (kf.duration || 100), 0);
            }
            if (data.steps) {
                return data.steps.reduce((sum, step) => sum + (step.delay || 0), 0);
            }
            return data.duration || 500;
        }
        
        // ========== Ïï†ÎãàÎ©îÏù¥ÏÖò Ïû¨ÏÉù ==========
        async function playAnimation(id) {
            const data = animCache.get(id);
            if (!data) {
                log('error', `‚ùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÜÏùå: ${id}`);
                return;
            }
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            document.querySelectorAll('.anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`.anim-item[data-id="${id}"]`)?.classList.add('playing');
            
            // JSON ÌëúÏãú
            document.getElementById('jsonViewer').innerHTML = syntaxHighlight(JSON.stringify(data, null, 2));
            
            log('anim', `‚ñ∂Ô∏è Ïû¨ÏÉù: ${id}`);
            
            // Ï∫êÎ¶≠ÌÑ∞ Î¶¨ÏÖã
            resetCharacters();
            await delay(50);
            
            const target = data.target || (id.startsWith('enemy') ? 'enemy' : 'player');
            const container = target === 'player' ? playerContainer : enemyContainer;
            const sprite = target === 'player' ? playerSprite : enemySprite;
            const baseX = target === 'player' ? config.playerBaseX : config.enemyBaseX;
            const direction = target === 'player' ? 1 : -1;
            
            // Ïù¥Ï†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÇ¨
            gsap.killTweensOf(container);
            gsap.killTweensOf(container.scale);
            gsap.killTweensOf(sprite);
            gsap.killTweensOf(sprite.scale);
            
            // ÏãúÌÄÄÏä§ ÌÉÄÏûÖ
            if (data.type === 'sequence' && data.steps) {
                await playSequence(data, container, sprite, baseX, direction);
                return;
            }
            
            // ÌÇ§ÌîÑÎ†àÏûÑ ÌÉÄÏûÖ
            if (data.keyframes) {
                await playKeyframes(data, container, sprite, baseX, direction);
            }
        }
        
        async function playSequence(data, container, sprite, baseX, direction) {
            log('anim', `üé¨ ÏãúÌÄÄÏä§ ÏãúÏûë: ${data.id}`);
            
            for (const step of data.steps) {
                if (step.delay) {
                    await delay(step.delay / config.speed);
                    continue;
                }
                
                if (step.anim) {
                    log('info', `  ‚Üí ${step.anim}`);
                    await playAnimation(step.anim);
                }
                
                if (step.vfx && config.vfx) {
                    showVFX(step.vfx, container);
                }
            }
            
            log('success', `‚úÖ ÏãúÌÄÄÏä§ ÏôÑÎ£å: ${data.id}`);
        }
        
        async function playKeyframes(data, container, sprite, baseX, direction) {
            return new Promise((resolve) => {
                const tl = gsap.timeline({
                    timeScale: config.speed,
                    onComplete: () => {
                        log('success', `‚úÖ ÏôÑÎ£å: ${data.id}`);
                        resolve();
                    }
                });
                
                data.keyframes.forEach((kf, index) => {
                    if (index === 0) return; // Ï≤´ ÌîÑÎ†àÏûÑÏùÄ Ï¥àÍ∏∞Í∞í
                    
                    const duration = (kf.duration || 100) / 1000;
                    const ease = kf.ease || 'power2.out';
                    
                    const props = {};
                    
                    // ÏúÑÏπò
                    if (kf.x !== undefined) props.x = baseX + (kf.x * direction);
                    if (kf.y !== undefined) props.y = config.baseY + kf.y;
                    
                    // Ïä§ÏºÄÏùº
                    if (kf.scaleX !== undefined || kf.scaleY !== undefined) {
                        const scaleProps = {};
                        if (kf.scaleX !== undefined) scaleProps.x = kf.scaleX * 0.8;
                        if (kf.scaleY !== undefined) scaleProps.y = kf.scaleY * 0.8;
                        tl.to(sprite.scale, { ...scaleProps, duration, ease }, '<');
                    }
                    
                    // ÏïåÌåå
                    if (kf.alpha !== undefined) props.alpha = kf.alpha;
                    
                    // ÌöåÏ†Ñ
                    if (kf.rotation !== undefined) {
                        tl.to(sprite, { rotation: kf.rotation * direction, duration, ease }, '<');
                    }
                    
                    // Ïª®ÌÖåÏù¥ÎÑà Ïù¥Îèô
                    if (Object.keys(props).length > 0) {
                        tl.to(container, { ...props, duration, ease }, index === 1 ? 0 : '>');
                    }
                    
                    // VFX
                    if (kf.vfx && config.vfx) {
                        tl.call(() => showVFX(kf.vfx, container), null, '<');
                    }
                });
            });
        }
        
        function resetCharacters() {
            gsap.killTweensOf(playerContainer);
            gsap.killTweensOf(playerSprite);
            gsap.killTweensOf(playerSprite.scale);
            gsap.killTweensOf(enemyContainer);
            gsap.killTweensOf(enemySprite);
            gsap.killTweensOf(enemySprite.scale);
            
            playerContainer.x = config.playerBaseX;
            playerContainer.y = config.baseY;
            playerContainer.alpha = 1;
            playerSprite.rotation = 0;
            playerSprite.scale.set(0.8);
            
            enemyContainer.x = config.enemyBaseX;
            enemyContainer.y = config.baseY;
            enemyContainer.alpha = 1;
            enemySprite.rotation = 0;
            enemySprite.scale.set(0.8);
            
            startBreathing();
        }
        
        // ========== VFX ==========
        function showVFX(type, container) {
            if (!config.vfx) return;
            
            const x = container.x;
            const y = container.y - 50;
            
            switch (type) {
                case 'slash':
                    drawSlash(x, y);
                    break;
                case 'hit':
                    drawHit(x, y);
                    break;
                case 'spark':
                    drawSparks(x, y);
                    break;
            }
        }
        
        function drawSlash(x, y) {
            vfxCtx.save();
            vfxCtx.strokeStyle = '#fff';
            vfxCtx.lineWidth = 3;
            vfxCtx.shadowColor = '#60a5fa';
            vfxCtx.shadowBlur = 15;
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(x - 40, y + 30);
            vfxCtx.lineTo(x + 40, y - 30);
            vfxCtx.stroke();
            vfxCtx.restore();
            
            setTimeout(() => clearVFX(), 150);
        }
        
        function drawHit(x, y) {
            vfxCtx.save();
            vfxCtx.fillStyle = '#ef4444';
            vfxCtx.shadowColor = '#ef4444';
            vfxCtx.shadowBlur = 20;
            
            vfxCtx.beginPath();
            vfxCtx.arc(x, y, 20, 0, Math.PI * 2);
            vfxCtx.fill();
            vfxCtx.restore();
            
            setTimeout(() => clearVFX(), 100);
        }
        
        function drawSparks(x, y) {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                const len = 20 + Math.random() * 20;
                
                vfxCtx.save();
                vfxCtx.strokeStyle = '#fbbf24';
                vfxCtx.lineWidth = 2;
                vfxCtx.shadowColor = '#fbbf24';
                vfxCtx.shadowBlur = 10;
                
                vfxCtx.beginPath();
                vfxCtx.moveTo(x, y);
                vfxCtx.lineTo(x + Math.cos(angle) * len, y + Math.sin(angle) * len);
                vfxCtx.stroke();
                vfxCtx.restore();
            }
            
            setTimeout(() => clearVFX(), 150);
        }
        
        function clearVFX() {
            vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
        }
        
        // ========== Ïú†Ìã∏ ==========
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function updateSpeed() {
            config.speed = parseFloat(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = config.speed.toFixed(1) + 'x';
        }
        
        function log(type, message) {
            const container = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString('ko-KR', { hour12: false });
            
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${message}`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
        }
        
        function syntaxHighlight(json) {
            return json
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?)/g, (match) => {
                    if (/:$/.test(match)) {
                        return `<span class="key">${match}</span>`;
                    }
                    return `<span class="string">${match}</span>`;
                })
                .replace(/\b(-?\d+\.?\d*)\b/g, '<span class="number">$1</span>');
        }
        
        function startUpdateLoop() {
            setInterval(() => {
                if (!playerContainer || !enemyContainer) return;
                
                document.getElementById('playerX').textContent = playerContainer.x.toFixed(0);
                document.getElementById('playerScale').textContent = playerSprite.scale.x.toFixed(2);
                document.getElementById('enemyX').textContent = enemyContainer.x.toFixed(0);
                document.getElementById('fpsValue').textContent = Math.round(app.ticker.FPS);
            }, 100);
        }
    </script>
</body>
</html>
