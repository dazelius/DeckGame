<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ® DDOO Action Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="background-3d.js"></script>
    <script src="ddoo-action.js"></script>
    <!-- ğŸ ë²ˆë“¤ (fetch ì—†ì´ ì¦‰ì‹œ ë¡œë“œ!) -->
    <script src="anim-bundle.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        .header {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            border-bottom: 2px solid #fbbf24;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        .header h1 {
            font-family: 'Cinzel', serif;
            color: #fbbf24;
            font-size: 1.2rem;
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
        }
        .header-btn {
            background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%);
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
        }
        .main-container {
            display: flex;
            height: 100vh;
            padding-top: 50px;
        }
        .control-panel {
            width: 280px;
            background: #0f0f18;
            border-right: 1px solid #2a2a3a;
            overflow-y: auto;
            padding: 12px;
        }
        .panel-section {
            background: #1a1a28;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .panel-section h3 {
            color: #fbbf24;
            font-size: 0.85rem;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3a3a5a;
        }
        .anim-list { display: flex; flex-direction: column; gap: 4px; }
        .anim-item {
            background: #252535;
            border: 1px solid #3a3a5a;
            padding: 8px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }
        .anim-item:hover { background: #353550; border-color: #60a5fa; }
        .anim-item.playing { background: #1e3a5f; border-color: #60a5fa; }
        .anim-item .type {
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: bold;
        }
        .anim-item .type.player { background: #3b82f6; }
        .anim-item .type.enemy { background: #ef4444; }
        .anim-item .type.card { background: #a855f7; }
        .anim-item .name { flex: 1; }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .speed-control label { color: #888; font-size: 0.75rem; }
        .speed-control input { flex: 1; }
        .speed-control .value { color: #60a5fa; font-size: 0.75rem; }
        .stage-container {
            flex: 1;
            position: relative;
            background: #0a0a12;
            overflow: hidden;
        }
        #pixiContainer { 
            width: 100%; 
            height: 100%;
            position: relative;
        }
        #bg3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        #pixiContainer canvas {
            position: relative;
            z-index: 1;
        }
        #vfxCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .stage-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #3a3a5a;
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.7rem;
            z-index: 20;
        }
        .stat-row { display: flex; justify-content: space-between; gap: 15px; color: #666; margin-bottom: 2px; }
        .stat-row .value { color: #60a5fa; }
        .log-panel {
            width: 260px;
            background: #0f0f18;
            border-left: 1px solid #2a2a3a;
            display: flex;
            flex-direction: column;
        }
        .log-header {
            padding: 8px 12px;
            background: #1a1a28;
            border-bottom: 1px solid #2a2a4a;
            font-size: 0.8rem;
            color: #fbbf24;
            display: flex;
            justify-content: space-between;
        }
        .log-header button {
            background: #3a3a5a;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            color: #888;
            cursor: pointer;
            font-size: 0.65rem;
        }
        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-family: monospace;
            font-size: 0.7rem;
        }
        .log-entry { padding: 3px 0; border-bottom: 1px solid #1a1a2a; }
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #34d399; }
        .log-entry.warn { color: #fbbf24; }
        .log-entry.error { color: #ef4444; }
        .log-entry.anim { color: #a78bfa; }
        .log-entry.vfx { color: #f472b6; }
        .log-time { color: #444; margin-right: 5px; }
        
        /* ==================== íƒ€ì„ë¼ì¸ íŒ¨ë„ ==================== */
        .timeline-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: #0d0d15;
            border-top: 2px solid #fbbf24;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 12px;
            background: #1a1a2e;
            border-bottom: 1px solid #2a2a4a;
        }
        .timeline-header h3 { color: #fbbf24; font-size: 0.8rem; margin: 0; }
        .timeline-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .timeline-btn {
            background: #3a3a5a;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            color: #ddd;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .timeline-btn:hover { background: #4a4a6a; }
        .timeline-btn.active { background: #60a5fa; color: #000; }
        .timeline-time {
            font-family: monospace;
            color: #60a5fa;
            font-size: 0.8rem;
            min-width: 80px;
        }
        .timeline-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        .timeline-tracks {
            width: 120px;
            background: #12121a;
            border-right: 1px solid #2a2a4a;
            flex-shrink: 0;
        }
        .timeline-track-header {
            height: 32px;
            padding: 0 10px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #1a1a2a;
            font-size: 0.7rem;
            color: #888;
        }
        .timeline-track-header.player { color: #60a5fa; }
        .timeline-track-header.enemy { color: #ef4444; }
        .timeline-track-header.vfx { color: #a855f7; }
        .timeline-track-header.shake { color: #fbbf24; }
        .timeline-content {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }
        .timeline-ruler {
            height: 24px;
            background: #1a1a28;
            border-bottom: 1px solid #2a2a4a;
            position: relative;
        }
        .timeline-ruler-mark {
            position: absolute;
            top: 0;
            height: 100%;
            border-left: 1px solid #3a3a5a;
            font-size: 0.6rem;
            color: #666;
            padding-left: 3px;
            padding-top: 2px;
        }
        .timeline-ruler-mark.major { border-color: #5a5a7a; color: #888; }
        .timeline-lanes {
            position: relative;
        }
        .timeline-lane {
            height: 32px;
            border-bottom: 1px solid #1a1a2a;
            position: relative;
        }
        .timeline-keyframe {
            position: absolute;
            height: 24px;
            top: 4px;
            border-radius: 3px;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            padding: 0 4px;
            cursor: pointer;
            overflow: hidden;
            white-space: nowrap;
        }
        .timeline-keyframe.player {
            background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%);
            border: 1px solid #60a5fa;
        }
        .timeline-keyframe.enemy {
            background: linear-gradient(180deg, #ef4444 0%, #b91c1c 100%);
            border: 1px solid #f87171;
        }
        .timeline-keyframe.vfx {
            background: linear-gradient(180deg, #a855f7 0%, #7c3aed 100%);
            border: 1px solid #c084fc;
            height: 18px;
            top: 7px;
        }
        .timeline-keyframe.shake {
            background: linear-gradient(180deg, #fbbf24 0%, #d97706 100%);
            border: 1px solid #fcd34d;
            height: 14px;
            top: 9px;
        }
        .timeline-keyframe.hitstop {
            background: linear-gradient(180deg, #10b981 0%, #059669 100%);
            border: 1px solid #34d399;
            height: 14px;
            top: 9px;
        }
        .timeline-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 100;
            pointer-events: none;
        }
        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -5px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #ef4444;
        }
        .timeline-empty {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #555;
            font-size: 0.8rem;
        }
        /* ë©”ì¸ ì»¨í…Œì´ë„ˆ ë†’ì´ ì¡°ì • */
        .main-container { height: calc(100vh - 200px); }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® DDOO Action Studio v1.0</h1>
        <button class="header-btn" onclick="location.href='index.html'">ğŸ® ê²Œì„ìœ¼ë¡œ</button>
    </div>
    
    <div class="main-container">
        <div class="control-panel">
            <div class="panel-section">
                <h3>ğŸ“ Animations</h3>
                <div id="animList" class="anim-list"></div>
            </div>
            <div class="panel-section">
                <h3>âš™ï¸ Settings</h3>
                <div class="speed-control">
                    <label>Speed</label>
                    <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1" onchange="updateSpeed()">
                    <span class="value" id="speedValue">1.0x</span>
                </div>
            </div>
        </div>
        
        <div class="stage-container">
            <div id="pixiContainer"></div>
            <canvas id="vfxCanvas"></canvas>
            <div class="stage-overlay" id="statsOverlay">
                <div class="stat-row"><span>Player:</span><span class="value" id="playerPos">0, 0</span></div>
                <div class="stat-row"><span>Enemy:</span><span class="value" id="enemyPos">0, 0</span></div>
                <div class="stat-row"><span>FPS:</span><span class="value" id="fpsValue">60</span></div>
            </div>
        </div>
        
        <div class="log-panel">
            <div class="log-header">
                <span>ğŸ“œ Log</span>
                <button onclick="clearLog()">Clear</button>
            </div>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>
    
    <!-- ğŸ¬ íƒ€ì„ë¼ì¸ íŒ¨ë„ -->
    <div class="timeline-panel" id="timelinePanel">
        <div class="timeline-header">
            <h3>ğŸ¬ Timeline</h3>
            <div class="timeline-controls">
                <button class="timeline-btn" onclick="timelineZoom(-1)">â–</button>
                <button class="timeline-btn" onclick="timelineZoom(1)">â•</button>
                <span class="timeline-time" id="timelineTime">0.000s</span>
                <button class="timeline-btn" onclick="toggleTimeline()">â–¼ ìˆ¨ê¸°ê¸°</button>
            </div>
        </div>
        <div class="timeline-body">
            <div class="timeline-tracks">
                <div class="timeline-track-header player">ğŸ® Player</div>
                <div class="timeline-track-header enemy">ğŸ‘¹ Enemy</div>
                <div class="timeline-track-header vfx">âœ¨ VFX</div>
                <div class="timeline-track-header shake">ğŸ“³ Shake/Stop</div>
            </div>
            <div class="timeline-content" id="timelineContent">
                <div class="timeline-ruler" id="timelineRuler"></div>
                <div class="timeline-lanes" id="timelineLanes">
                    <div class="timeline-lane" id="playerLane"></div>
                    <div class="timeline-lane" id="enemyLane"></div>
                    <div class="timeline-lane" id="vfxLane"></div>
                    <div class="timeline-lane" id="shakeLane"></div>
                </div>
                <div class="timeline-playhead" id="timelinePlayhead" style="left: 0;"></div>
            </div>
        </div>
    </div>

    <script>
        // ==================== ì „ì—­ ë³€ìˆ˜ ====================
        let app, vfxCanvas, vfxCtx;
        let playerContainer, playerSprite, enemyContainer, enemySprite;
        let stageContainer; // ì‰ì´í¬ìš©
        
        const config = {
            speed: 1,
            playerBaseX: 0,
            enemyBaseX: 0,
            baseY: 0,
            // ìºë¦­í„° í¬ê¸° ì •ë³´
            charHeight: 120,    // ê¸°ë³¸ ìºë¦­í„° ë†’ì´
            charWidth: 60,      // ê¸°ë³¸ ìºë¦­í„° ë„ˆë¹„
            vfxScale: 1.0       // VFX ìŠ¤ì¼€ì¼
        };
        
        let animCache = new Map();
        let vfxCache = new Map();
        
        // ë™ì ìœ¼ë¡œ index.jsonì—ì„œ ë¡œë“œ
        let ANIM_FILES = [];
        let VFX_FILES = [];
        
        // VFX íŒŒí‹°í´ í’€
        const particles = [];
        let animationFrame = null;
        
        // ==================== ì´ˆê¸°í™” ====================
        document.addEventListener('DOMContentLoaded', async () => {
            log('info', 'ğŸ® DDOO Action Studio ì´ˆê¸°í™”...');
            await initPixi();
            await loadAllVFX();
            await loadAllAnimations();
            renderAnimList();
            startVFXLoop();
            startUpdateLoop();
            log('success', 'âœ… ì¤€ë¹„ ì™„ë£Œ! ì• ë‹ˆë©”ì´ì…˜ì„ ì„ íƒí•˜ì„¸ìš”.');
        });
        
        async function initPixi() {
            const container = document.getElementById('pixiContainer');
            const width = container.clientWidth || 900;
            const height = container.clientHeight || 600;
            
            // ğŸ¥ 3D ë°°ê²½ ì´ˆê¸°í™” (Background3D)
            if (typeof Background3D !== 'undefined') {
                log('info', 'ğŸ¥ 3D ë°°ê²½ ì´ˆê¸°í™” ì¤‘...');
                // ì»¨í…Œì´ë„ˆ ì„¤ì • (pixiContainer ì•ˆì— ë Œë”ë§)
                Background3D.createContainer = function() {
                    const old = document.getElementById('bg3d');
                    if (old) old.remove();
                    
                    this.container = document.createElement('div');
                    this.container.id = 'bg3d';
                    this.container.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        z-index: 0;
                        pointer-events: none;
                    `;
                    container.appendChild(this.container);
                };
                
                await Background3D.init();
                Background3D.setAutoZoom(false);  // ìë™ ì¤Œ ë¹„í™œì„±í™”
                log('success', 'âœ… 3D ë°°ê²½ ì´ˆê¸°í™” ì™„ë£Œ');
            }
            
            app = new PIXI.Application({
                width, height,
                backgroundAlpha: 0,  // íˆ¬ëª… ë°°ê²½ (3D ë°°ê²½ ë³´ì´ê²Œ)
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            container.appendChild(app.view);
            app.view.style.position = 'relative';
            app.view.style.zIndex = '1';
            
            vfxCanvas = document.getElementById('vfxCanvas');
            vfxCanvas.width = width;
            vfxCanvas.height = height;
            vfxCtx = vfxCanvas.getContext('2d');
            
            // ìŠ¤í…Œì´ì§€ ì»¨í…Œì´ë„ˆ (ì‰ì´í¬ìš©)
            stageContainer = new PIXI.Container();
            app.stage.addChild(stageContainer);
            
            // 3D ë°°ê²½ì´ ì—†ìœ¼ë©´ í´ë°± ë°°ê²½ ê·¸ë¦¬ê¸°
            if (typeof Background3D === 'undefined' || !Background3D.isInitialized) {
                drawBackground(width, height);
            }
            
            // DDOOAction ì—”ì§„ ì´ˆê¸°í™” (ì»¨í…Œì´ë„ˆ/ì• ë‹ˆë©”ì´ì…˜/VFX ë¡œë“œ) - ìºë¦­í„° ìƒì„± ì „ì—!
            if (typeof DDOOAction !== 'undefined') {
                await DDOOAction.init(app, stageContainer);
                log('success', 'âœ… DDOOAction ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
                
                // DDOOActionì˜ animCacheë¥¼ test_animationì—ì„œë„ ì‚¬ìš©
                animCache = DDOOAction.animCache;
                vfxCache = DDOOAction.vfxCache;
            }
            
            await createCharacters(width, height);
            
            log('info', `Stage: ${width}x${height}`);
        }
        
        function drawBackground(width, height) {
            const bg = new PIXI.Graphics();
            
            // ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼
            for (let i = 0; i < 10; i++) {
                const alpha = 0.03 + (i * 0.01);
                bg.beginFill(0x1a1a2e, alpha);
                bg.drawRect(0, height * (i / 10), width, height / 10);
                bg.endFill();
            }
            
            // ë°”ë‹¥ ë¼ì¸
            const groundY = height * 0.7;
            bg.lineStyle(2, 0x3a3a5a, 0.6);
            bg.moveTo(0, groundY);
            bg.lineTo(width, groundY);
            
            // ê·¸ë¦¬ë“œ
            bg.lineStyle(1, 0x2a2a3a, 0.2);
            for (let x = 0; x < width; x += 100) {
                bg.moveTo(x, 0);
                bg.lineTo(x, height);
            }
            
            stageContainer.addChild(bg);
        }
        
        async function createCharacters(width, height) {
            const groundY = height * 0.7;
            config.baseY = groundY;
            config.playerBaseX = width * 0.28;
            config.enemyBaseX = width * 0.72;
            
            // ğŸ® DDOOAction ì—”ì§„ ì‚¬ìš©!
            const useDDOOEngine = typeof DDOOAction !== 'undefined';
            
            if (useDDOOEngine && DDOOAction.initialized) {
                log('info', 'ğŸ® DDOOAction ì—”ì§„ìœ¼ë¡œ ìºë¦­í„° ìƒì„±...');
                
                // ì•„ì›ƒë¼ì¸ ì„¤ì • ì¡°ì • (ë„ˆë¬´ ë‘ê»ì§€ ì•Šê²Œ)
                DDOOAction.config.character.outlineThickness = 1;
                DDOOAction.config.enableOutline = false;  // í…ŒìŠ¤íŠ¸ìš© ë¹„í™œì„±í™”
                
                // í”Œë ˆì´ì–´ í…ìŠ¤ì²˜ ë¡œë“œ
                let playerTex;
                try {
                    playerTex = await PIXI.Assets.load('hero.png');
                    log('success', `âœ… hero.png (${playerTex.width}x${playerTex.height})`);
                } catch (e) {
                    playerTex = createFallbackTexture(0x60a5fa, 'P');
                    log('warn', 'âš ï¸ hero.png fallback');
                }
                
                // DDOOActionìœ¼ë¡œ í”Œë ˆì´ì–´ ìƒì„± (ê·¸ë¦¼ì, ì•„ì›ƒë¼ì¸, ë¸Œë ˆì‹± í¬í•¨!)
                const playerData = DDOOAction.createCharacter('player', {
                    texture: playerTex,
                    x: config.playerBaseX,
                    y: groundY,
                    scale: 1.0,
                    team: 'player',
                    enableEffects: true
                });
                playerContainer = playerData.container;
                playerSprite = playerData.sprite;
                
                // ì  í…ìŠ¤ì²˜ ë¡œë“œ
                let enemyTex;
                try {
                    enemyTex = await PIXI.Assets.load('goblinarcher.png');
                    log('success', `âœ… goblinarcher.png (${enemyTex.width}x${enemyTex.height})`);
                } catch (e) {
                    enemyTex = createFallbackTexture(0xef4444, 'E');
                    log('warn', 'âš ï¸ goblinarcher.png fallback');
                }
                
                // DDOOActionìœ¼ë¡œ ì  ìƒì„±
                const enemyData = DDOOAction.createCharacter('enemy', {
                    texture: enemyTex,
                    x: config.enemyBaseX,
                    y: groundY,
                    scale: 1.0,
                    team: 'enemy',
                    enableEffects: true
                });
                enemyContainer = enemyData.container;
                enemySprite = enemyData.sprite;
                
                log('success', 'âœ… DDOOAction ìºë¦­í„° ìƒì„± ì™„ë£Œ (ê·¸ë¦¼ì, ì•„ì›ƒë¼ì¸, ë¸Œë ˆì‹±)');
                
            } else {
                // í´ë°±: ê¸°ì¡´ ë°©ì‹
                log('warn', 'âš ï¸ DDOOAction ì—†ìŒ, ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©');
                
                // í”Œë ˆì´ì–´
                playerContainer = new PIXI.Container();
                playerContainer.x = config.playerBaseX;
                playerContainer.y = groundY;
                
                try {
                    const tex = await PIXI.Assets.load('hero.png');
                    playerSprite = new PIXI.Sprite(tex);
                    playerSprite.anchor.set(0.5, 1);
                    playerSprite.scale.set(1.0);
                } catch (e) {
                    playerSprite = createFallback(0x60a5fa, 'P');
                }
                playerContainer.addChild(playerSprite);
                stageContainer.addChild(playerContainer);
                
                // ì 
                enemyContainer = new PIXI.Container();
                enemyContainer.x = config.enemyBaseX;
                enemyContainer.y = groundY;
                
                try {
                    const tex = await PIXI.Assets.load('goblinarcher.png');
                    enemySprite = new PIXI.Sprite(tex);
                    enemySprite.anchor.set(0.5, 1);
                    enemySprite.scale.set(1.0);
                } catch (e) {
                    enemySprite = createFallback(0xef4444, 'E');
                }
                enemyContainer.addChild(enemySprite);
                stageContainer.addChild(enemyContainer);
                
                initAfterimageSystem();
                startBreathing();
            }
            
            // ìºë¦­í„° í¬ê¸° ì €ì¥
            updateCharacterInfo();
        }
        
        // í´ë°± í…ìŠ¤ì²˜ ìƒì„±
        function createFallbackTexture(color, letter) {
            const g = new PIXI.Graphics();
            g.beginFill(color);
            g.drawRoundedRect(0, 0, 70, 120, 10);
            g.endFill();
            return app.renderer.generateTexture(g);
        }
        
        function updateCharacterInfo() {
            // í”Œë ˆì´ì–´ ë°”ìš´ë“œ
            const pBounds = playerSprite.getBounds();
            config.playerHeight = pBounds.height;
            config.playerWidth = pBounds.width;
            
            // ì  ë°”ìš´ë“œ
            const eBounds = enemySprite.getBounds();
            config.enemyHeight = eBounds.height;
            config.enemyWidth = eBounds.width;
            
            log('info', `Player: ${config.playerWidth.toFixed(0)}x${config.playerHeight.toFixed(0)}`);
            log('info', `Enemy: ${config.enemyWidth.toFixed(0)}x${config.enemyHeight.toFixed(0)}`);
        }
        
        function createFallback(color, letter) {
            const c = new PIXI.Container();
            const body = new PIXI.Graphics();
            body.beginFill(color);
            body.drawRoundedRect(-35, -120, 70, 120, 10);
            body.endFill();
            const text = new PIXI.Text(letter, { fontFamily: 'Arial', fontSize: 40, fill: 0xffffff, fontWeight: 'bold' });
            text.anchor.set(0.5);
            text.y = -60;
            c.addChild(body);
            c.addChild(text);
            return c;
        }
        
        function startBreathing() {
            gsap.to(playerSprite.scale, { y: 1.02, duration: 1.8, repeat: -1, yoyo: true, ease: 'sine.inOut' });
            gsap.to(enemySprite.scale, { y: 1.02, duration: 1.5, repeat: -1, yoyo: true, ease: 'sine.inOut' });
        }
        
        // ==================== ì”ìƒ ì‹œìŠ¤í…œ ====================
        const afterimages = [];
        let afterimageContainer = null;
        
        function initAfterimageSystem() {
            afterimageContainer = new PIXI.Container();
            stageContainer.addChildAt(afterimageContainer, 0); // ìºë¦­í„° ë’¤ì— ë°°ì¹˜
        }
        
        function createAfterimage(sourceSprite, sourceContainer, alpha = 0.6, tint = 0x8888ff) {
            if (!afterimageContainer || !sourceSprite.texture) return;
            
            const ghost = new PIXI.Sprite(sourceSprite.texture);
            ghost.anchor.set(sourceSprite.anchor.x, sourceSprite.anchor.y);
            ghost.x = sourceContainer.x;
            ghost.y = sourceContainer.y;
            ghost.scale.set(sourceSprite.scale.x, sourceSprite.scale.y);
            ghost.rotation = sourceSprite.rotation;
            ghost.alpha = alpha;
            ghost.tint = tint;
            
            afterimageContainer.addChild(ghost);
            
            // ì”ìƒ ë°ì´í„° ì €ì¥
            afterimages.push({
                sprite: ghost,
                life: 150,
                maxLife: 150,
                fadeSpeed: 1
            });
        }
        
        function updateAfterimages(delta) {
            for (let i = afterimages.length - 1; i >= 0; i--) {
                const ai = afterimages[i];
                ai.life -= delta * 16;
                
                const progress = ai.life / ai.maxLife;
                ai.sprite.alpha = progress * 0.6;
                ai.sprite.scale.x *= 0.995;
                ai.sprite.scale.y *= 0.995;
                
                if (ai.life <= 0) {
                    afterimageContainer.removeChild(ai.sprite);
                    ai.sprite.destroy();
                    afterimages.splice(i, 1);
                }
            }
        }
        
        function clearAfterimages() {
            afterimages.forEach(ai => {
                afterimageContainer.removeChild(ai.sprite);
                ai.sprite.destroy();
            });
            afterimages.length = 0;
        }
        
        // ==================== JSON ë¡œë“œ (ë²ˆë“¤ ìš°ì„ , fetch í´ë°±) ====================
        async function loadAllVFX() {
            log('info', 'ğŸ’¥ Loading VFX...');
            
            // ğŸ ë²ˆë“¤ì´ ìˆìœ¼ë©´ ì¦‰ì‹œ ì‚¬ìš©!
            if (window.VFX_BUNDLE) {
                log('success', 'ğŸ VFX ë²ˆë“¤ ì‚¬ìš© (fetch ìŠ¤í‚µ!)');
                Object.entries(window.VFX_BUNDLE).forEach(([id, data]) => {
                    vfxCache.set(id, data);
                });
                VFX_FILES = Object.keys(window.VFX_BUNDLE);
                log('success', `âœ… VFX ë¡œë“œ ì™„ë£Œ: ${vfxCache.size}ê°œ (ë²ˆë“¤)`);
                return;
            }
            
            // í´ë°±: fetchë¡œ ë¡œë“œ
            try {
                const indexRes = await fetch('vfx/index.json');
                if (indexRes.ok) {
                    VFX_FILES = await indexRes.json();
                    log('info', `ğŸ“‹ vfx/index.json: ${VFX_FILES.length}ê°œ ë°œê²¬`);
                }
            } catch (e) {
                log('warn', 'âš ï¸ vfx/index.json ì—†ìŒ, ê¸°ë³¸ ëª©ë¡ ì‚¬ìš©');
                VFX_FILES = ['slash', 'hit', 'spark', 'dash', 'stab', 'critical', 'block'];
            }
            
            for (const id of VFX_FILES) {
                try {
                    const res = await fetch(`vfx/${id}.json`);
                    if (res.ok) {
                        vfxCache.set(id, await res.json());
                    }
                } catch (e) {
                    log('warn', `âš ï¸ vfx/${id} failed`);
                }
            }
            log('success', `âœ… VFX ë¡œë“œ ì™„ë£Œ: ${vfxCache.size}ê°œ`);
        }
        
        async function loadAllAnimations() {
            log('info', 'ğŸ“ Loading animations...');
            
            // ğŸ ë²ˆë“¤ì´ ìˆìœ¼ë©´ ì¦‰ì‹œ ì‚¬ìš©!
            if (window.ANIM_BUNDLE) {
                log('success', 'ğŸ Anim ë²ˆë“¤ ì‚¬ìš© (fetch ìŠ¤í‚µ!)');
                Object.entries(window.ANIM_BUNDLE).forEach(([id, data]) => {
                    animCache.set(id, data);
                });
                ANIM_FILES = Object.keys(window.ANIM_BUNDLE);
                log('success', `âœ… ì• ë‹ˆë©”ì´ì…˜ ë¡œë“œ ì™„ë£Œ: ${animCache.size}ê°œ (ë²ˆë“¤)`);
                return;
            }
            
            // í´ë°±: fetchë¡œ ë¡œë“œ
            try {
                const indexRes = await fetch('anim/index.json');
                if (indexRes.ok) {
                    ANIM_FILES = await indexRes.json();
                    log('info', `ğŸ“‹ anim/index.json: ${ANIM_FILES.length}ê°œ ë°œê²¬`);
                }
            } catch (e) {
                log('warn', 'âš ï¸ anim/index.json ì—†ìŒ, ê¸°ë³¸ ëª©ë¡ ì‚¬ìš©');
                ANIM_FILES = ['player.attack', 'player.hit', 'enemy.attack', 'enemy.hit'];
            }
            
            for (const id of ANIM_FILES) {
                try {
                    const res = await fetch(`anim/${id}.json`);
                    if (res.ok) {
                        animCache.set(id, await res.json());
                    }
                } catch (e) {
                    log('warn', `âš ï¸ anim/${id} failed`);
                }
            }
            log('success', `âœ… ì• ë‹ˆë©”ì´ì…˜ ë¡œë“œ ì™„ë£Œ: ${animCache.size}ê°œ`);
        }
        
        function renderAnimList() {
            const container = document.getElementById('animList');
            container.innerHTML = '';
            animCache.forEach((data, id) => {
                const type = id.split('.')[0];
                const name = id.split('.')[1];
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = id;
                item.innerHTML = `<span class="type ${type}">${type}</span><span class="name">${name}</span>`;
                item.onclick = () => playAnimation(id);
                container.appendChild(item);
            });
        }
        
        // ==================== ë©”ì¸ ì¬ìƒ ====================
        async function playAnimation(id, skipReset = false) {
            const data = animCache.get(id);
            if (!data) { log('error', `âŒ Not found: ${id}`); return; }
            
            document.querySelectorAll('.anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`.anim-item[data-id="${id}"]`)?.classList.add('playing');
            
            log('anim', `â–¶ï¸ ${id}`);
            
            if (!skipReset) {
                resetCharacters();
                await delay(100);
            }
            
            const target = data.target || (id.startsWith('enemy') ? 'enemy' : 'player');
            const container = target === 'player' ? playerContainer : enemyContainer;
            const sprite = target === 'player' ? playerSprite : enemySprite;
            const baseX = target === 'player' ? config.playerBaseX : config.enemyBaseX;
            const dir = target === 'player' ? 1 : -1;
            
            // ğŸ® DDOOAction ì—”ì§„ ì‚¬ìš©!
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized) {
                await DDOOAction.play(id, {
                    container,
                    sprite,
                    baseX,
                    baseY: config.baseY,
                    dir,
                    isRelative: false,
                    onComplete: () => log('success', `âœ… ${id} ì™„ë£Œ`),
                    onHit: (kf) => log('info', `ğŸ’¥ íˆíŠ¸! ${kf.vfx || ''}`),
                    getHitPoint: () => {
                        // ì  íƒ€ê²©ì 
                        const ec = DDOOAction.getCharacter('enemy');
                        if (ec) {
                            return { x: ec.container.x, y: ec.container.y - (config.enemyHeight || 100) / 2 };
                        }
                        return { x: enemyContainer.x, y: config.baseY - 60 };
                    }
                });
                return;
            }
            
            // í´ë°±: ê¸°ì¡´ ë°©ì‹
            if (data.type === 'sequence' && data.steps) {
                await playSequence(data);
            } else if (data.keyframes) {
                await playKeyframes(data, container, sprite, baseX, dir, false);
            }
        }
        
        // ==================== ì‹œí€€ìŠ¤ ì¬ìƒ ====================
        async function playSequence(data) {
            log('anim', `ğŸ¬ Sequence: ${data.id}`);
            
            for (const step of data.steps) {
                if (step.delay && !step.anim) {
                    await delay(step.delay / config.speed);
                    continue;
                }
                
                if (step.anim) {
                    const animData = animCache.get(step.anim);
                    if (!animData) { log('warn', `âš ï¸ ${step.anim} not found`); continue; }
                    
                    log('info', `  â†’ ${step.anim}`);
                    
                    const target = animData.target || (step.anim.startsWith('enemy') ? 'enemy' : 'player');
                    const container = target === 'player' ? playerContainer : enemyContainer;
                    const sprite = target === 'player' ? playerSprite : enemySprite;
                    const dir = target === 'player' ? 1 : -1;
                    
                    if (step.delay) await delay(step.delay / config.speed);
                    
                    if (animData.keyframes) {
                        const promise = playKeyframes(animData, container, sprite, container.x, dir, true);
                        if (step.wait) await promise;
                    }
                }
            }
            
            log('success', `âœ… Sequence done: ${data.id}`);
        }
        
        // ==================== í‚¤í”„ë ˆì„ ì¬ìƒ (FGO ìŠ¤íƒ€ì¼) ====================
        async function playKeyframes(data, container, sprite, startX, dir, isRelative) {
            return new Promise((resolve) => {
                const baseScale = 1.0;
                const returnToBase = data.returnToBase;
                const targetBaseX = dir === 1 ? config.playerBaseX : config.enemyBaseX;
                
                gsap.killTweensOf(container);
                gsap.killTweensOf(sprite);
                gsap.killTweensOf(sprite.scale);
                
                const tl = gsap.timeline({
                    timeScale: config.speed,
                    onComplete: () => {
                        if (returnToBase) {
                            gsap.to(container, {
                                x: targetBaseX,
                                duration: 0.25,
                                ease: 'power2.inOut',
                                onComplete: resolve
                            });
                        } else {
                            resolve();
                        }
                    }
                });
                
                data.keyframes.forEach((kf, idx) => {
                    if (idx === 0) return;
                    
                    const dur = (kf.duration || 100) / 1000;
                    const ease = kf.ease || 'power2.out';
                    const pos = idx === 1 ? 0 : '>';
                    
                    // ì»¨í…Œì´ë„ˆ ì´ë™
                    if (kf.x !== undefined) {
                        const targetX = isRelative ? startX + (kf.x * dir) : config.playerBaseX + (kf.x * dir);
                        tl.to(container, { x: targetX, duration: dur, ease }, pos);
                    }
                    
                    if (kf.y !== undefined) {
                        tl.to(container, { y: config.baseY + kf.y, duration: dur, ease }, '<');
                    }
                    
                    // ìŠ¤ì¼€ì¼ (ìŠ¤ì¿¼ì‹œ/ìŠ¤íŠ¸ë ˆì¹˜)
                    if (kf.scaleX !== undefined || kf.scaleY !== undefined) {
                        const scaleX = (kf.scaleX ?? 1) * baseScale;
                        const scaleY = (kf.scaleY ?? 1) * baseScale;
                        tl.to(sprite.scale, { x: scaleX, y: scaleY, duration: dur, ease }, '<');
                    }
                    
                    // íšŒì „
                    if (kf.rotation !== undefined) {
                        tl.to(sprite, { rotation: kf.rotation * dir, duration: dur, ease }, '<');
                    }
                    
                    // ì•ŒíŒŒ
                    if (kf.alpha !== undefined) {
                        tl.to(sprite, { alpha: kf.alpha, duration: dur, ease }, '<');
                    }
                    
                    // ========== VFX íŠ¸ë¦¬ê±° ==========
                    if (kf.vfx) {
                        tl.call(() => triggerVFX(kf.vfx, container, dir), null, '<');
                    }
                    
                    // ========== íˆíŠ¸ìŠ¤í†± ==========
                    if (kf.hitstop) {
                        tl.call(() => {
                            tl.pause();
                            setTimeout(() => tl.resume(), kf.hitstop / config.speed);
                        }, null, '>');
                    }
                    
                    // ========== ìŠ¤í¬ë¦°ì‰ì´í¬ ==========
                    if (kf.shake) {
                        tl.call(() => screenShake(kf.shake), null, '<');
                    }
                    
                    // ========== ì”ìƒ ìƒì„± ==========
                    if (kf.afterimage) {
                        tl.call(() => {
                            const tint = data.target === 'player' ? 0x60a5fa : 0xef4444;
                            createAfterimage(sprite, container, 0.7, tint);
                        }, null, '<');
                    }
                });
            });
        }
        
        function resetCharacters() {
            gsap.killTweensOf(playerContainer);
            gsap.killTweensOf(playerSprite);
            gsap.killTweensOf(playerSprite.scale);
            gsap.killTweensOf(enemyContainer);
            gsap.killTweensOf(enemySprite);
            gsap.killTweensOf(enemySprite.scale);
            gsap.killTweensOf(stageContainer);
            
            playerContainer.x = config.playerBaseX;
            playerContainer.y = config.baseY;
            playerSprite.rotation = 0;
            playerSprite.scale.set(1.0);
            playerSprite.alpha = 1;
            
            enemyContainer.x = config.enemyBaseX;
            enemyContainer.y = config.baseY;
            enemySprite.rotation = 0;
            enemySprite.scale.set(1.0);
            enemySprite.alpha = 1;
            
            stageContainer.x = 0;
            stageContainer.y = 0;
            stageContainer.scale.set(1, 1);  // âš ï¸ ìŠ¤ì¼€ì¼ë„ ë³µì›!
            stageContainer.alpha = 1;  // âš ï¸ ìŠ¤í…Œì´ì§€ ì•ŒíŒŒë„ ë³µì›!
            
            // âš ï¸ DDOOAction ì¹´ë©”ë¼/ì´í™íŠ¸ ë¦¬ì…‹!
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized) {
                DDOOAction.resetCameraImmediate();
                DDOOAction.resetColorGradeImmediate();
                DDOOAction.resetSlowmoImmediate();
                
                const playerChar = DDOOAction.characters.get('player');
                if (playerChar) {
                    playerChar.sprite.alpha = 1;
                    playerChar.sprite.rotation = 0;
                    playerChar.sprite.scale.set(1, 1);
                    playerChar.container.x = config.playerBaseX;
                    playerChar.container.y = config.baseY;
                }
                const enemyChar = DDOOAction.characters.get('enemy');
                if (enemyChar) {
                    enemyChar.sprite.alpha = 1;
                    enemyChar.sprite.rotation = 0;
                    enemyChar.sprite.scale.set(1, 1);
                    enemyChar.container.x = config.enemyBaseX;
                    enemyChar.container.y = config.baseY;
                }
            }
            
            // ğŸ¥ 3D ë°°ê²½ ì¹´ë©”ë¼ë„ ë¦¬ì…‹
            if (typeof Background3D !== 'undefined' && Background3D.isInitialized && Background3D.autoZoom) {
                const baseZ = Background3D.cameraDefaults?.posZ || 15;
                Background3D.autoZoom.targetZ = baseZ;
                Background3D.autoZoom.currentZ = baseZ;
            }
            
            clearVFX();
            clearAfterimages();
            startBreathing();
        }
        
        // ==================== VFX ì‹œìŠ¤í…œ (JSON ê¸°ë°˜) ====================
        
        // ìºë¦­í„°ì˜ ì‹¤ì œ ë°”ìš´ë“œ ê³„ì‚°
        function getCharacterBounds(container) {
            const sprite = container.children[0];
            if (!sprite) return { width: 60, height: 120, centerY: -60 };
            
            const bounds = sprite.getBounds();
            const scale = sprite.scale.x;
            
            return {
                width: bounds.width,
                height: bounds.height,
                centerY: -bounds.height / 2,  // ì¤‘ì‹¬ì  Y
                scale: scale
            };
        }
        
        // íƒ€ê²©ì  ê³„ì‚° (ì  ìœ„ì¹˜ ê¸°ì¤€)
        function getHitPoint(attackerContainer, targetContainer) {
            const targetBounds = getCharacterBounds(targetContainer);
            
            // íƒ€ê²©ì ì€ íƒ€ê²Ÿ ìºë¦­í„°ì˜ ì¤‘ì‹¬
            return {
                x: targetContainer.x,
                y: targetContainer.y + targetBounds.centerY,
                scale: targetBounds.scale
            };
        }
        
        function triggerVFX(vfxId, container, dir) {
            const vfxData = vfxCache.get(vfxId);
            if (!vfxData) {
                log('warn', `âš ï¸ VFX not found: ${vfxId}`);
                return;
            }
            
            // íƒ€ê²©ì  ê³„ì‚°: ê³µê²©ìê°€ í”Œë ˆì´ì–´ë©´ ì ì—ê²Œ, ì ì´ë©´ í”Œë ˆì´ì–´ì—ê²Œ
            const isPlayer = container === playerContainer;
            const targetContainer = isPlayer ? enemyContainer : playerContainer;
            const hitPoint = getHitPoint(container, targetContainer);
            
            // VFX íƒ€ì…ì— ë”°ë¥¸ ìœ„ì¹˜ ê²°ì •
            let vfxX, vfxY, vfxScale;
            
            if (vfxId === 'dash' || vfxId === 'trail') {
                // ëŒ€ì‹œ/íŠ¸ë ˆì¼ì€ ìì‹  ìœ„ì¹˜
                const bounds = getCharacterBounds(container);
                vfxX = container.x;
                vfxY = container.y + bounds.centerY;
                vfxScale = bounds.scale;
            } else {
                // ê³µê²© ì´í™íŠ¸ëŠ” íƒ€ê²©ì  (íƒ€ê²Ÿ ìœ„ì¹˜)
                vfxX = hitPoint.x;
                vfxY = hitPoint.y;
                vfxScale = hitPoint.scale;
            }
            
            log('vfx', `ğŸ’¥ ${vfxId} at (${vfxX.toFixed(0)}, ${vfxY.toFixed(0)}) scale:${vfxScale.toFixed(2)}`);
            
            // VFXì— ì •ì˜ëœ shake ì‹¤í–‰
            if (vfxData.shake) {
                screenShake(vfxData.shake);
            }
            
            // ê° íŒŒí‹°í´ ì •ì˜ ì²˜ë¦¬
            for (const pDef of vfxData.particles) {
                spawnParticlesFromDef(pDef, vfxX, vfxY, dir, container, vfxScale);
            }
        }
        
        // JSON ì •ì˜ì—ì„œ íŒŒí‹°í´ ìƒì„± (ìŠ¤ì¼€ì¼ ì ìš©)
        function spawnParticlesFromDef(def, x, y, dir, container, scale = 1.0) {
            const count = def.count || 1;
            const delayBetween = def.delay || 0;
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    switch (def.type) {
                        case 'slash':
                        case 'thrust':
                            spawnSlashParticle(def, x, y, dir, i, scale);
                            break;
                        case 'arrow':
                        case 'wedge':
                            spawnArrowParticle(def, x, y, dir, i, scale);
                            break;
                        case 'spark':
                            spawnSparkParticle(def, x, y, scale);
                            break;
                        case 'flash':
                            spawnFlashParticle(def, x, y, scale);
                            break;
                        case 'ring':
                            spawnRingParticle(def, x, y, scale);
                            break;
                        case 'line':
                            spawnLineParticle(def, x, y, i, scale);
                            break;
                        case 'debris':
                            spawnDebrisParticle(def, x, y, scale);
                            break;
                        case 'trail':
                            spawnTrailParticle(def, container, i, scale);
                            break;
                        case 'projectile':
                            spawnProjectileParticle(def, x, y, dir, scale, container);
                            break;
                    }
                }, i * delayBetween);
            }
        }
        
        function spawnSlashParticle(def, x, y, dir, index, scale) {
            const angles = Array.isArray(def.angle) ? def.angle : [def.angle || 0];
            const angle = angles[index % angles.length] || (Math.random() - 0.5) * 60;
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 8) * scale;
            
            spawnParticle({
                type: 'slash',
                x, y,
                angle: angle * dir,
                length: length,
                width: width,
                color: def.color || '#ffffff',
                glow: def.glow || '#60a5fa',
                life: def.life || 150
            });
        }
        
        // ">" ëª¨ì–‘ í™”ì‚´í‘œ ì´í™íŠ¸
        function spawnArrowParticle(def, x, y, dir, index, scale) {
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 60) * scale;
            const tipAngle = def.tipAngle || 35; // í™”ì‚´ì´‰ ê°ë„
            
            const p = {
                type: 'arrow',
                x, y,
                dir: dir,
                startLength: length,
                startWidth: width,
                tipAngle: tipAngle,
                color: def.color || '#ffffff',
                glow: def.glow || '#a78bfa',
                innerColor: def.innerColor || 'rgba(167, 139, 250, 0.5)',
                life: def.life || 120
            };
            spawnParticle(p);
        }
        
        function spawnSparkParticle(def, x, y, scale) {
            const spread = (def.spread || 50) * scale;
            const speed = getRandValue(def.speed) * scale;
            const size = getRandValue(def.size) * scale;
            const angle = Math.random() * Math.PI * 2;
            const colors = def.colors || [def.color || '#fbbf24'];
            
            spawnParticle({
                type: 'spark',
                x: x + (Math.random() - 0.5) * spread,
                y: y + (Math.random() - 0.5) * spread,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2,
                size: size,
                color: colors[Math.floor(Math.random() * colors.length)],
                life: getRandValue(def.life)
            });
        }
        
        function spawnFlashParticle(def, x, y, scale) {
            spawnParticle({
                type: 'flash',
                x, y,
                size: (def.size || 80) * scale,
                color: def.color || '#ffffff',
                life: def.life || 80
            });
        }
        
        function spawnRingParticle(def, x, y, scale) {
            spawnParticle({
                type: 'ring',
                x, y,
                size: (def.size || 20) * scale,
                maxSize: (def.maxSize || 100) * scale,
                color: def.color || '#ef4444',
                life: def.life || 200
            });
        }
        
        function spawnLineParticle(def, x, y, index, scale) {
            const angleStep = def.angleStep || 30;
            const angle = index * angleStep;
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 3) * scale;
            
            spawnParticle({
                type: 'line',
                x, y,
                angle: angle,
                length: length,
                width: width,
                color: def.color || '#fbbf24',
                life: def.life || 150
            });
        }
        
        function spawnDebrisParticle(def, x, y, scale) {
            const speed = getRandValue(def.speed) * scale;
            const size = getRandValue(def.size) * scale;
            const angle = Math.random() * Math.PI * 2;
            const colors = def.colors || [def.color || '#ef4444'];
            
            spawnParticle({
                type: 'debris',
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 5,
                size: size,
                color: colors[Math.floor(Math.random() * colors.length)],
                gravity: def.gravity || 0.3,
                life: getRandValue(def.life)
            });
        }
        
        function spawnTrailParticle(def, container, index, scale) {
            const bounds = getCharacterBounds(container);
            const offsetX = (def.offsetX || -20) * index * scale;
            const size = (getRandValue(def.size) - index * 5) * scale;
            
            spawnParticle({
                type: 'trail',
                x: container.x + offsetX,
                y: container.y + bounds.centerY,
                size: Math.max(size, 10),
                color: def.color || 'rgba(96, 165, 250, 0.3)',
                life: def.life || 150
            });
        }
        
        function spawnProjectileParticle(def, startX, startY, dir, scale, container) {
            // ì‹œì‘ì  (í”Œë ˆì´ì–´) â†’ ëì  (ì )
            const targetContainer = container === playerContainer ? enemyContainer : playerContainer;
            const targetBounds = getCharacterBounds(targetContainer);
            const endX = targetContainer.x;
            const endY = targetContainer.y + targetBounds.centerY;
            
            spawnParticle({
                type: 'projectile',
                x: startX,
                y: startY,
                targetX: endX,
                targetY: endY,
                speed: (def.speed || 20) * scale,
                rotation: def.rotation || 0,
                size: (def.size || 15) * scale,
                shape: def.shape || 'circle',
                color: def.color || '#94a3b8',
                glow: def.glow || '#60a5fa',
                life: def.life || 300,
                dir: dir
            });
        }
        
        // ìœ í‹¸: ë°°ì—´ì´ë©´ ëœë¤ ë²”ìœ„, ì•„ë‹ˆë©´ ê·¸ëŒ€ë¡œ
        function getRandValue(val) {
            if (Array.isArray(val)) {
                return val[0] + Math.random() * (val[1] - val[0]);
            }
            return val || 0;
        }
        
        // íŒŒí‹°í´ ìŠ¤í°
        function spawnParticle(config) {
            particles.push({
                ...config,
                startLife: config.life,
                startSize: config.size || 10,
                startLength: config.length || 50,
                born: performance.now()
            });
        }
        
        // VFX ë Œë” ë£¨í”„
        function startVFXLoop() {
            let lastTime = performance.now();
            
            function render() {
                const now = performance.now();
                const delta = (now - lastTime) / 16.67; // 60fps ê¸°ì¤€
                lastTime = now;
                
                // ì”ìƒ ì—…ë°ì´íŠ¸
                updateAfterimages(delta);
                
                vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const age = now - p.born;
                    const progress = age / p.startLife;
                    
                    if (progress >= 1) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    const alpha = 1 - progress;
                    
                    vfxCtx.save();
                    
                    switch (p.type) {
                        case 'slash':
                            drawSlashParticle(p, alpha, progress);
                            break;
                        case 'arrow':
                            drawArrowParticle(p, alpha, progress);
                            break;
                        case 'spark':
                            p.x += p.vx || 0;
                            p.y += p.vy || 0;
                            if (p.gravity) p.vy += p.gravity;
                            drawSparkParticle(p, alpha);
                            break;
                        case 'flash':
                            drawFlashParticle(p, alpha, progress);
                            break;
                        case 'ring':
                            drawRingParticle(p, alpha, progress);
                            break;
                        case 'line':
                            drawLineParticle(p, alpha, progress);
                            break;
                        case 'debris':
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += p.gravity;
                            drawDebrisParticle(p, alpha);
                            break;
                        case 'trail':
                            drawTrailParticle(p, alpha);
                            break;
                        case 'projectile':
                            updateAndDrawProjectile(p, alpha, progress);
                            break;
                    }
                    
                    vfxCtx.restore();
                }
                
                animationFrame = requestAnimationFrame(render);
            }
            render();
        }
        
        function drawSlashParticle(p, alpha, progress) {
            const rad = p.angle * Math.PI / 180;
            const len = p.startLength * (1 - progress * 0.3);
            
            vfxCtx.translate(p.x, p.y);
            vfxCtx.rotate(rad);
            
            // ê¸€ë¡œìš°
            if (p.glow) {
                vfxCtx.shadowColor = p.glow;
                vfxCtx.shadowBlur = 20;
            }
            
            // ê·¸ë¼ë°ì´ì…˜ ìŠ¬ë˜ì‹œ
            const grad = vfxCtx.createLinearGradient(-len/2, 0, len/2, 0);
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(0.3, p.color);
            grad.addColorStop(0.7, p.color);
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.strokeStyle = grad;
            vfxCtx.lineWidth = p.width * alpha;
            vfxCtx.lineCap = 'round';
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(-len/2, 0);
            vfxCtx.lineTo(len/2, 0);
            vfxCtx.stroke();
        }
        
        // ">" í™”ì‚´í‘œ ëª¨ì–‘ ê·¸ë¦¬ê¸°
        function drawArrowParticle(p, alpha, progress) {
            const len = p.startLength * (1 - progress * 0.4);
            const width = p.startWidth * (1 - progress * 0.3);
            const tipRad = (p.tipAngle || 35) * Math.PI / 180;
            
            // í™”ì‚´í‘œ ë°©í–¥ (dir: 1 = ì˜¤ë¥¸ìª½, -1 = ì™¼ìª½)
            const dir = p.dir || 1;
            
            vfxCtx.translate(p.x, p.y);
            if (dir < 0) vfxCtx.scale(-1, 1);
            
            // ê¸€ë¡œìš°
            if (p.glow) {
                vfxCtx.shadowColor = p.glow;
                vfxCtx.shadowBlur = 25;
            }
            vfxCtx.globalAlpha = alpha;
            
            // ë‚´ë¶€ ì±„ìš°ê¸° (ë°˜íˆ¬ëª…)
            if (p.innerColor) {
                vfxCtx.fillStyle = p.innerColor;
                vfxCtx.beginPath();
                vfxCtx.moveTo(len, 0);                          // ë¾°ì¡±í•œ ë
                vfxCtx.lineTo(0, -width * Math.sin(tipRad));    // ìœ„ìª½ ë‚ ê°œ
                vfxCtx.lineTo(len * 0.3, 0);                    // ì•ˆìª½ êº¾ì„
                vfxCtx.lineTo(0, width * Math.sin(tipRad));     // ì•„ë˜ìª½ ë‚ ê°œ
                vfxCtx.closePath();
                vfxCtx.fill();
            }
            
            // ì™¸ê³½ì„  (ë°ì€ ìƒ‰)
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = 3 * alpha;
            vfxCtx.lineCap = 'round';
            vfxCtx.lineJoin = 'round';
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(0, -width * Math.sin(tipRad));  // ìœ„ìª½ ë‚ ê°œ
            vfxCtx.lineTo(len, 0);                         // ë¾°ì¡±í•œ ë
            vfxCtx.lineTo(0, width * Math.sin(tipRad));   // ì•„ë˜ìª½ ë‚ ê°œ
            vfxCtx.stroke();
            
            // ì¤‘ì•™ ê°•ì¡°ì„ 
            vfxCtx.strokeStyle = '#ffffff';
            vfxCtx.lineWidth = 2 * alpha;
            vfxCtx.beginPath();
            vfxCtx.moveTo(len * 0.2, 0);
            vfxCtx.lineTo(len * 0.9, 0);
            vfxCtx.stroke();
        }
        
        function drawSparkParticle(p, alpha) {
            vfxCtx.fillStyle = p.color;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 8;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawFlashParticle(p, alpha, progress) {
            const size = p.startSize * (1 + progress);
            const grad = vfxCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
            grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
            grad.addColorStop(0.5, `rgba(255,255,255,${alpha * 0.5})`);
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.fillStyle = grad;
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawRingParticle(p, alpha, progress) {
            const size = p.size + (p.maxSize - p.size) * progress;
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = 4 * alpha;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 15;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
            vfxCtx.stroke();
        }
        
        function drawLineParticle(p, alpha, progress) {
            const rad = p.angle * Math.PI / 180;
            const len = p.startLength * (1 - progress * 0.5);
            const startOffset = p.startLength * progress * 0.3;
            
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = p.width * alpha;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.lineCap = 'round';
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 8;
            
            const sx = p.x + Math.cos(rad) * startOffset;
            const sy = p.y + Math.sin(rad) * startOffset;
            const ex = p.x + Math.cos(rad) * (startOffset + len);
            const ey = p.y + Math.sin(rad) * (startOffset + len);
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(sx, sy);
            vfxCtx.lineTo(ex, ey);
            vfxCtx.stroke();
        }
        
        function drawDebrisParticle(p, alpha) {
            vfxCtx.fillStyle = p.color;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 5;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawTrailParticle(p, alpha) {
            // NaN/Infinity ì²´í¬
            if (!isFinite(p.x) || !isFinite(p.y) || !isFinite(p.size) || p.size <= 0) {
                return;
            }
            
            const grad = vfxCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
            grad.addColorStop(0, p.color.replace('0.3', String(0.3 * alpha)));
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.fillStyle = grad;
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function updateAndDrawProjectile(p, alpha, progress) {
            // íˆ¬ì‚¬ì²´ ì´ë™ (ì‹œì‘ì  â†’ íƒ€ê²Ÿ)
            const dx = p.targetX - p.x;
            const dy = p.targetY - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > p.speed) {
                p.x += (dx / dist) * p.speed;
                p.y += (dy / dist) * p.speed;
            }
            
            // íšŒì „ ì—…ë°ì´íŠ¸
            if (p.rotation) {
                p.currentRotation = (p.currentRotation || 0) + (p.rotation * Math.PI / 180) * 0.016;
            }
            
            vfxCtx.save();
            vfxCtx.translate(p.x, p.y);
            vfxCtx.rotate(p.currentRotation || 0);
            
            // ê¸€ë¡œìš°
            vfxCtx.shadowColor = p.glow;
            vfxCtx.shadowBlur = 12;
            vfxCtx.globalAlpha = alpha;
            
            // ë‹¨ê²€ ê·¸ë¦¬ê¸°
            if (p.shape === 'dagger') {
                // ë‹¨ê²€ ë¸”ë ˆì´ë“œ
                vfxCtx.fillStyle = p.color;
                vfxCtx.beginPath();
                vfxCtx.moveTo(p.size, 0);           // ë
                vfxCtx.lineTo(0, -p.size * 0.3);    // ìœ„
                vfxCtx.lineTo(-p.size * 0.5, 0);    // ì†ì¡ì´
                vfxCtx.lineTo(0, p.size * 0.3);     // ì•„ë˜
                vfxCtx.closePath();
                vfxCtx.fill();
                
                // í•˜ì´ë¼ì´íŠ¸
                vfxCtx.fillStyle = '#ffffff';
                vfxCtx.globalAlpha = alpha * 0.6;
                vfxCtx.beginPath();
                vfxCtx.moveTo(p.size * 0.8, 0);
                vfxCtx.lineTo(0, -p.size * 0.15);
                vfxCtx.lineTo(-p.size * 0.2, 0);
                vfxCtx.closePath();
                vfxCtx.fill();
            } else {
                // ê¸°ë³¸ ì›í˜•
                vfxCtx.fillStyle = p.color;
                vfxCtx.beginPath();
                vfxCtx.arc(0, 0, p.size, 0, Math.PI * 2);
                vfxCtx.fill();
            }
            
            vfxCtx.restore();
            
            // ì”ìƒ íŠ¸ë ˆì¼ ìƒì„± (dist > 0 ì¼ ë•Œë§Œ)
            if (dist > 0.1 && Math.random() > 0.6) {
                spawnParticle({
                    type: 'trail',
                    x: p.x - (dx / dist) * 10,
                    y: p.y - (dy / dist) * 10,
                    size: p.size * 0.5,
                    color: 'rgba(148, 163, 184, 0.2)',
                    life: 80
                });
            }
        }
        
        
        // ìŠ¤í¬ë¦°ì‰ì´í¬
        function screenShake(intensity) {
            const duration = 150;
            const startTime = performance.now();
            
            function shake() {
                const elapsed = performance.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    stageContainer.x = 0;
                    stageContainer.y = 0;
                    return;
                }
                
                const decay = 1 - progress;
                const offsetX = (Math.random() - 0.5) * intensity * decay;
                const offsetY = (Math.random() - 0.5) * intensity * decay;
                
                stageContainer.x = offsetX;
                stageContainer.y = offsetY;
                
                requestAnimationFrame(shake);
            }
            shake();
        }
        
        function clearVFX() {
            particles.length = 0;
            vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
        }
        
        // ==================== ìœ í‹¸ ====================
        function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
        
        function updateSpeed() {
            config.speed = parseFloat(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = config.speed.toFixed(1) + 'x';
        }
        
        function log(type, msg) {
            const c = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString('ko-KR', { hour12: false });
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${msg}`;
            c.appendChild(entry);
            c.scrollTop = c.scrollHeight;
        }
        
        function clearLog() { document.getElementById('logContainer').innerHTML = ''; }
        
        function startUpdateLoop() {
            setInterval(() => {
                if (!playerContainer) return;
                document.getElementById('playerPos').textContent = `${playerContainer.x.toFixed(0)}, ${playerContainer.y.toFixed(0)}`;
                document.getElementById('enemyPos').textContent = `${enemyContainer.x.toFixed(0)}, ${enemyContainer.y.toFixed(0)}`;
                document.getElementById('fpsValue').textContent = Math.round(app.ticker.FPS);
            }, 100);
        }
        
        // ==================== ğŸ¬ íƒ€ì„ë¼ì¸ ì‹œìŠ¤í…œ ====================
        const Timeline = {
            scale: 0.3,          // 1ms = 0.3px
            duration: 2000,      // ê¸°ë³¸ 2ì´ˆ
            currentTime: 0,
            isPlaying: false,
            tracks: {
                player: [],
                enemy: [],
                vfx: [],
                shake: []
            },
            
            init() {
                this.renderRuler();
                this.setupScrollSync();
            },
            
            // ëˆˆê¸ˆì ë Œë”ë§
            renderRuler() {
                const ruler = document.getElementById('timelineRuler');
                ruler.innerHTML = '';
                ruler.style.width = (this.duration * this.scale) + 'px';
                
                // 100ms ë‹¨ìœ„ë¡œ ëˆˆê¸ˆ
                for (let t = 0; t <= this.duration; t += 100) {
                    const mark = document.createElement('div');
                    mark.className = 'timeline-ruler-mark' + (t % 500 === 0 ? ' major' : '');
                    mark.style.left = (t * this.scale) + 'px';
                    if (t % 500 === 0) {
                        mark.textContent = (t / 1000).toFixed(1) + 's';
                    }
                    ruler.appendChild(mark);
                }
            },
            
            // ìŠ¤í¬ë¡¤ ë™ê¸°í™”
            setupScrollSync() {
                const content = document.getElementById('timelineContent');
                content.addEventListener('scroll', () => {
                    // í”Œë ˆì´í—¤ë“œ ìœ„ì¹˜ ìœ ì§€
                });
            },
            
            // ì• ë‹ˆë©”ì´ì…˜ ë¶„ì„í•˜ì—¬ íƒ€ì„ë¼ì¸ì— ì¶”ê°€
            analyzeAnimation(animId) {
                const data = animCache.get(animId);
                if (!data) return;
                
                this.clear();
                
                // ì‹œí€€ìŠ¤ íƒ€ì…ì¸ ê²½ìš°
                if (data.type === 'sequence' && data.steps) {
                    this.analyzeSequence(data);
                } else if (data.keyframes) {
                    this.analyzeKeyframes(data, 0);
                }
                
                this.render();
            },
            
            // ì‹œí€€ìŠ¤ ë¶„ì„
            analyzeSequence(data) {
                let currentTime = 0;
                
                data.steps.forEach((step, idx) => {
                    if (step.delay && !step.anim) {
                        currentTime += step.delay;
                        return;
                    }
                    
                    if (step.anim) {
                        const animData = animCache.get(step.anim);
                        if (!animData) return;
                        
                        if (step.delay) currentTime += step.delay;
                        
                        // í‚¤í”„ë ˆì„ ë¶„ì„
                        this.analyzeKeyframes(animData, currentTime);
                        
                        // ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ ê³„ì‚°
                        if (animData.keyframes && step.wait) {
                            const lastKf = animData.keyframes[animData.keyframes.length - 1];
                            currentTime += lastKf.time || 0;
                        }
                    }
                });
                
                this.duration = Math.max(this.duration, currentTime + 500);
                this.renderRuler();
            },
            
            // í‚¤í”„ë ˆì„ ë¶„ì„
            analyzeKeyframes(data, startTime) {
                const target = data.target || (data.id?.startsWith('enemy') ? 'enemy' : 'player');
                const trackName = target;
                
                if (!data.keyframes) return;
                
                data.keyframes.forEach((kf, idx) => {
                    const time = startTime + (kf.time || 0);
                    const duration = kf.duration || 50;
                    
                    // ë©”ì¸ í‚¤í”„ë ˆì„
                    this.tracks[trackName].push({
                        time,
                        duration,
                        label: this.getKeyframeLabel(kf, idx),
                        type: trackName,
                        data: kf
                    });
                    
                    // VFX
                    if (kf.vfx) {
                        this.tracks.vfx.push({
                            time,
                            duration: 150,
                            label: kf.vfx,
                            type: 'vfx',
                            data: kf
                        });
                    }
                    
                    // Shake
                    if (kf.shake) {
                        this.tracks.shake.push({
                            time,
                            duration: kf.shake.duration || 100,
                            label: 'ğŸ“³ Shake',
                            type: 'shake',
                            data: kf
                        });
                    }
                    
                    // Hitstop
                    if (kf.hitstop) {
                        this.tracks.shake.push({
                            time,
                            duration: kf.hitstop,
                            label: 'â¸ï¸ Stop ' + kf.hitstop + 'ms',
                            type: 'hitstop',
                            data: kf
                        });
                    }
                });
            },
            
            // í‚¤í”„ë ˆì„ ë ˆì´ë¸” ìƒì„±
            getKeyframeLabel(kf, idx) {
                const parts = [];
                if (kf.x !== undefined) parts.push(`X:${kf.x}`);
                if (kf.y !== undefined) parts.push(`Y:${kf.y}`);
                if (kf.scaleX !== undefined || kf.scaleY !== undefined) {
                    parts.push(`S:${(kf.scaleX || 1).toFixed(2)},${(kf.scaleY || 1).toFixed(2)}`);
                }
                if (kf.rotation !== undefined) parts.push(`R:${kf.rotation.toFixed(2)}`);
                if (kf.alpha !== undefined) parts.push(`Î±:${kf.alpha}`);
                if (kf.afterimage) parts.push('ğŸ‘¤');
                
                return parts.length > 0 ? parts.join(' ') : `KF ${idx}`;
            },
            
            // ë Œë”ë§
            render() {
                this.renderTrack('player', 'playerLane');
                this.renderTrack('enemy', 'enemyLane');
                this.renderTrack('vfx', 'vfxLane');
                this.renderTrack('shake', 'shakeLane');
                
                // ë ˆì¸ ë„ˆë¹„ ì„¤ì •
                const lanes = document.getElementById('timelineLanes');
                lanes.style.width = (this.duration * this.scale) + 'px';
            },
            
            renderTrack(trackName, laneId) {
                const lane = document.getElementById(laneId);
                lane.innerHTML = '';
                
                this.tracks[trackName].forEach(item => {
                    const kf = document.createElement('div');
                    kf.className = `timeline-keyframe ${item.type}`;
                    kf.style.left = (item.time * this.scale) + 'px';
                    kf.style.width = Math.max(item.duration * this.scale, 30) + 'px';
                    kf.textContent = item.label;
                    kf.title = JSON.stringify(item.data, null, 2);
                    
                    kf.onclick = () => this.onKeyframeClick(item);
                    
                    lane.appendChild(kf);
                });
            },
            
            onKeyframeClick(item) {
                log('info', `ğŸ¯ í‚¤í”„ë ˆì„: ${item.label} @ ${item.time}ms`);
                console.log('Keyframe data:', item.data);
            },
            
            // í”Œë ˆì´í—¤ë“œ ì´ë™
            setPlayhead(time) {
                this.currentTime = time;
                const playhead = document.getElementById('timelinePlayhead');
                playhead.style.left = (time * this.scale) + 'px';
                document.getElementById('timelineTime').textContent = (time / 1000).toFixed(3) + 's';
            },
            
            // í´ë¦¬ì–´
            clear() {
                this.tracks = { player: [], enemy: [], vfx: [], shake: [] };
                this.duration = 2000;
                this.setPlayhead(0);
            }
        };
        
        // ì¤Œ ì¸/ì•„ì›ƒ
        function timelineZoom(dir) {
            Timeline.scale = Math.max(0.1, Math.min(2, Timeline.scale + dir * 0.1));
            Timeline.renderRuler();
            Timeline.render();
            log('info', `íƒ€ì„ë¼ì¸ ì¤Œ: ${Timeline.scale.toFixed(1)}x`);
        }
        
        // íƒ€ì„ë¼ì¸ ìˆ¨ê¸°ê¸°/ë³´ì´ê¸°
        let timelineVisible = true;
        function toggleTimeline() {
            timelineVisible = !timelineVisible;
            const panel = document.getElementById('timelinePanel');
            const btn = event.target;
            
            if (timelineVisible) {
                panel.style.height = '200px';
                btn.textContent = 'â–¼ ìˆ¨ê¸°ê¸°';
                document.querySelector('.main-container').style.height = 'calc(100vh - 200px)';
            } else {
                panel.style.height = '32px';
                btn.textContent = 'â–² í¼ì¹˜ê¸°';
                document.querySelector('.main-container').style.height = 'calc(100vh - 32px)';
            }
        }
        
        // ì›ë³¸ playAnimationì„ ë˜í•‘í•˜ì—¬ íƒ€ì„ë¼ì¸ ì—°ë™
        const _originalPlayAnimation = playAnimation;
        playAnimation = async function(id, skipReset) {
            // íƒ€ì„ë¼ì¸ ë¶„ì„
            Timeline.analyzeAnimation(id);
            
            // í”Œë ˆì´í—¤ë“œ ì• ë‹ˆë©”ì´ì…˜
            Timeline.setPlayhead(0);
            const startTime = performance.now();
            
            const updatePlayhead = () => {
                const elapsed = performance.now() - startTime;
                Timeline.setPlayhead(elapsed / config.speed);
                
                if (elapsed / config.speed < Timeline.duration) {
                    requestAnimationFrame(updatePlayhead);
                }
            };
            requestAnimationFrame(updatePlayhead);
            
            // ì›ë³¸ ì‹¤í–‰
            return _originalPlayAnimation(id, skipReset);
        };
        
        // íƒ€ì„ë¼ì¸ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => Timeline.init(), 100);
        });
    </script>
</body>
</html>
