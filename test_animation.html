<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ DDOO Action Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        .header {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            border-bottom: 2px solid #fbbf24;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        .header h1 {
            font-family: 'Cinzel', serif;
            color: #fbbf24;
            font-size: 1.2rem;
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
        }
        .header-btn {
            background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%);
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
        }
        .main-container {
            display: flex;
            height: 100vh;
            padding-top: 50px;
        }
        .control-panel {
            width: 280px;
            background: #0f0f18;
            border-right: 1px solid #2a2a3a;
            overflow-y: auto;
            padding: 12px;
        }
        .panel-section {
            background: #1a1a28;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .panel-section h3 {
            color: #fbbf24;
            font-size: 0.85rem;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3a3a5a;
        }
        .anim-list { display: flex; flex-direction: column; gap: 4px; }
        .anim-item {
            background: #252535;
            border: 1px solid #3a3a5a;
            padding: 8px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }
        .anim-item:hover { background: #353550; border-color: #60a5fa; }
        .anim-item.playing { background: #1e3a5f; border-color: #60a5fa; }
        .anim-item .type {
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: bold;
        }
        .anim-item .type.player { background: #3b82f6; }
        .anim-item .type.enemy { background: #ef4444; }
        .anim-item .type.card { background: #a855f7; }
        .anim-item .name { flex: 1; }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .speed-control label { color: #888; font-size: 0.75rem; }
        .speed-control input { flex: 1; }
        .speed-control .value { color: #60a5fa; font-size: 0.75rem; }
        .stage-container {
            flex: 1;
            position: relative;
            background: #0a0a12;
        }
        #pixiContainer { width: 100%; height: 100%; }
        #vfxCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .stage-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #3a3a5a;
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.7rem;
            z-index: 20;
        }
        .stat-row { display: flex; justify-content: space-between; gap: 15px; color: #666; margin-bottom: 2px; }
        .stat-row .value { color: #60a5fa; }
        .log-panel {
            width: 260px;
            background: #0f0f18;
            border-left: 1px solid #2a2a3a;
            display: flex;
            flex-direction: column;
        }
        .log-header {
            padding: 8px 12px;
            background: #1a1a28;
            border-bottom: 1px solid #2a2a4a;
            font-size: 0.8rem;
            color: #fbbf24;
            display: flex;
            justify-content: space-between;
        }
        .log-header button {
            background: #3a3a5a;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            color: #888;
            cursor: pointer;
            font-size: 0.65rem;
        }
        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-family: monospace;
            font-size: 0.7rem;
        }
        .log-entry { padding: 3px 0; border-bottom: 1px solid #1a1a2a; }
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #34d399; }
        .log-entry.warn { color: #fbbf24; }
        .log-entry.error { color: #ef4444; }
        .log-entry.anim { color: #a78bfa; }
        .log-entry.vfx { color: #f472b6; }
        .log-time { color: #444; margin-right: 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéÆ DDOO Action Studio v1.0</h1>
        <button class="header-btn" onclick="location.href='index.html'">üéÆ Í≤åÏûÑÏúºÎ°ú</button>
    </div>
    
    <div class="main-container">
        <div class="control-panel">
            <div class="panel-section">
                <h3>üìÅ Animations</h3>
                <div id="animList" class="anim-list"></div>
            </div>
            <div class="panel-section">
                <h3>‚öôÔ∏è Settings</h3>
                <div class="speed-control">
                    <label>Speed</label>
                    <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1" onchange="updateSpeed()">
                    <span class="value" id="speedValue">1.0x</span>
                </div>
            </div>
        </div>
        
        <div class="stage-container">
            <div id="pixiContainer"></div>
            <canvas id="vfxCanvas"></canvas>
            <div class="stage-overlay" id="statsOverlay">
                <div class="stat-row"><span>Player:</span><span class="value" id="playerPos">0, 0</span></div>
                <div class="stat-row"><span>Enemy:</span><span class="value" id="enemyPos">0, 0</span></div>
                <div class="stat-row"><span>FPS:</span><span class="value" id="fpsValue">60</span></div>
            </div>
        </div>
        
        <div class="log-panel">
            <div class="log-header">
                <span>üìú Log</span>
                <button onclick="clearLog()">Clear</button>
            </div>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>

    <script>
        // ==================== Ï†ÑÏó≠ Î≥ÄÏàò ====================
        let app, vfxCanvas, vfxCtx;
        let playerContainer, playerSprite, enemyContainer, enemySprite;
        let stageContainer; // ÏâêÏù¥ÌÅ¨Ïö©
        
        const config = {
            speed: 1,
            playerBaseX: 0,
            enemyBaseX: 0,
            baseY: 0,
            // Ï∫êÎ¶≠ÌÑ∞ ÌÅ¨Í∏∞ Ï†ïÎ≥¥
            charHeight: 120,    // Í∏∞Î≥∏ Ï∫êÎ¶≠ÌÑ∞ ÎÜíÏù¥
            charWidth: 60,      // Í∏∞Î≥∏ Ï∫êÎ¶≠ÌÑ∞ ÎÑàÎπÑ
            vfxScale: 1.0       // VFX Ïä§ÏºÄÏùº
        };
        
        const animCache = new Map();
        const vfxCache = new Map();
        
        // ÎèôÏ†ÅÏúºÎ°ú index.jsonÏóêÏÑú Î°úÎìú
        let ANIM_FILES = [];
        let VFX_FILES = [];
        
        // VFX ÌååÌã∞ÌÅ¥ ÌíÄ
        const particles = [];
        let animationFrame = null;
        
        // ==================== Ï¥àÍ∏∞Ìôî ====================
        document.addEventListener('DOMContentLoaded', async () => {
            log('info', 'üéÆ DDOO Action Studio Ï¥àÍ∏∞Ìôî...');
            await initPixi();
            await loadAllVFX();
            await loadAllAnimations();
            renderAnimList();
            startVFXLoop();
            startUpdateLoop();
            log('success', '‚úÖ Ï§ÄÎπÑ ÏôÑÎ£å! Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.');
        });
        
        async function initPixi() {
            const container = document.getElementById('pixiContainer');
            const width = container.clientWidth || 900;
            const height = container.clientHeight || 600;
            
            app = new PIXI.Application({
                width, height,
                backgroundColor: 0x0a0a12,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            container.appendChild(app.view);
            
            vfxCanvas = document.getElementById('vfxCanvas');
            vfxCanvas.width = width;
            vfxCanvas.height = height;
            vfxCtx = vfxCanvas.getContext('2d');
            
            // Ïä§ÌÖåÏù¥ÏßÄ Ïª®ÌÖåÏù¥ÎÑà (ÏâêÏù¥ÌÅ¨Ïö©)
            stageContainer = new PIXI.Container();
            app.stage.addChild(stageContainer);
            
            drawBackground(width, height);
            await createCharacters(width, height);
            
            log('info', `Stage: ${width}x${height}`);
        }
        
        function drawBackground(width, height) {
            const bg = new PIXI.Graphics();
            
            // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º
            for (let i = 0; i < 10; i++) {
                const alpha = 0.03 + (i * 0.01);
                bg.beginFill(0x1a1a2e, alpha);
                bg.drawRect(0, height * (i / 10), width, height / 10);
                bg.endFill();
            }
            
            // Î∞îÎã• ÎùºÏù∏
            const groundY = height * 0.7;
            bg.lineStyle(2, 0x3a3a5a, 0.6);
            bg.moveTo(0, groundY);
            bg.lineTo(width, groundY);
            
            // Í∑∏Î¶¨Îìú
            bg.lineStyle(1, 0x2a2a3a, 0.2);
            for (let x = 0; x < width; x += 100) {
                bg.moveTo(x, 0);
                bg.lineTo(x, height);
            }
            
            stageContainer.addChild(bg);
        }
        
        async function createCharacters(width, height) {
            const groundY = height * 0.7;
            config.baseY = groundY;
            config.playerBaseX = width * 0.28;
            config.enemyBaseX = width * 0.72;
            
            // ÌîåÎ†àÏù¥Ïñ¥
            playerContainer = new PIXI.Container();
            playerContainer.x = config.playerBaseX;
            playerContainer.y = groundY;
            
            try {
                const tex = await PIXI.Assets.load('hero.png');
                playerSprite = new PIXI.Sprite(tex);
                playerSprite.anchor.set(0.5, 1);
                playerSprite.scale.set(1.0);
                log('success', `‚úÖ hero.png (${tex.width}x${tex.height})`);
            } catch (e) {
                playerSprite = createFallback(0x60a5fa, 'P');
                log('warn', '‚ö†Ô∏è hero.png fallback');
            }
            playerContainer.addChild(playerSprite);
            stageContainer.addChild(playerContainer);
            
            // Ï†Å
            enemyContainer = new PIXI.Container();
            enemyContainer.x = config.enemyBaseX;
            enemyContainer.y = groundY;
            
            try {
                const tex = await PIXI.Assets.load('goblinarcher.png');
                enemySprite = new PIXI.Sprite(tex);
                enemySprite.anchor.set(0.5, 1);
                enemySprite.scale.set(1.0);
                log('success', `‚úÖ goblinarcher.png (${tex.width}x${tex.height})`);
            } catch (e) {
                enemySprite = createFallback(0xef4444, 'E');
                log('warn', '‚ö†Ô∏è goblinarcher.png fallback');
            }
            enemyContainer.addChild(enemySprite);
            stageContainer.addChild(enemyContainer);
            
            // Ï∫êÎ¶≠ÌÑ∞ ÌÅ¨Í∏∞ Ï†ÄÏû•
            updateCharacterInfo();
            
            // ÏûîÏÉÅ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
            initAfterimageSystem();
            
            startBreathing();
        }
        
        function updateCharacterInfo() {
            // ÌîåÎ†àÏù¥Ïñ¥ Î∞îÏö¥Îìú
            const pBounds = playerSprite.getBounds();
            config.playerHeight = pBounds.height;
            config.playerWidth = pBounds.width;
            
            // Ï†Å Î∞îÏö¥Îìú
            const eBounds = enemySprite.getBounds();
            config.enemyHeight = eBounds.height;
            config.enemyWidth = eBounds.width;
            
            log('info', `Player: ${config.playerWidth.toFixed(0)}x${config.playerHeight.toFixed(0)}`);
            log('info', `Enemy: ${config.enemyWidth.toFixed(0)}x${config.enemyHeight.toFixed(0)}`);
        }
        
        function createFallback(color, letter) {
            const c = new PIXI.Container();
            const body = new PIXI.Graphics();
            body.beginFill(color);
            body.drawRoundedRect(-35, -120, 70, 120, 10);
            body.endFill();
            const text = new PIXI.Text(letter, { fontFamily: 'Arial', fontSize: 40, fill: 0xffffff, fontWeight: 'bold' });
            text.anchor.set(0.5);
            text.y = -60;
            c.addChild(body);
            c.addChild(text);
            return c;
        }
        
        function startBreathing() {
            gsap.to(playerSprite.scale, { y: 1.02, duration: 1.8, repeat: -1, yoyo: true, ease: 'sine.inOut' });
            gsap.to(enemySprite.scale, { y: 1.02, duration: 1.5, repeat: -1, yoyo: true, ease: 'sine.inOut' });
        }
        
        // ==================== ÏûîÏÉÅ ÏãúÏä§ÌÖú ====================
        const afterimages = [];
        let afterimageContainer = null;
        
        function initAfterimageSystem() {
            afterimageContainer = new PIXI.Container();
            stageContainer.addChildAt(afterimageContainer, 0); // Ï∫êÎ¶≠ÌÑ∞ Îí§Ïóê Î∞∞Ïπò
        }
        
        function createAfterimage(sourceSprite, sourceContainer, alpha = 0.6, tint = 0x8888ff) {
            if (!afterimageContainer || !sourceSprite.texture) return;
            
            const ghost = new PIXI.Sprite(sourceSprite.texture);
            ghost.anchor.set(sourceSprite.anchor.x, sourceSprite.anchor.y);
            ghost.x = sourceContainer.x;
            ghost.y = sourceContainer.y;
            ghost.scale.set(sourceSprite.scale.x, sourceSprite.scale.y);
            ghost.rotation = sourceSprite.rotation;
            ghost.alpha = alpha;
            ghost.tint = tint;
            
            afterimageContainer.addChild(ghost);
            
            // ÏûîÏÉÅ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
            afterimages.push({
                sprite: ghost,
                life: 150,
                maxLife: 150,
                fadeSpeed: 1
            });
        }
        
        function updateAfterimages(delta) {
            for (let i = afterimages.length - 1; i >= 0; i--) {
                const ai = afterimages[i];
                ai.life -= delta * 16;
                
                const progress = ai.life / ai.maxLife;
                ai.sprite.alpha = progress * 0.6;
                ai.sprite.scale.x *= 0.995;
                ai.sprite.scale.y *= 0.995;
                
                if (ai.life <= 0) {
                    afterimageContainer.removeChild(ai.sprite);
                    ai.sprite.destroy();
                    afterimages.splice(i, 1);
                }
            }
        }
        
        function clearAfterimages() {
            afterimages.forEach(ai => {
                afterimageContainer.removeChild(ai.sprite);
                ai.sprite.destroy();
            });
            afterimages.length = 0;
        }
        
        // ==================== JSON Î°úÎìú (ÎèôÏ†Å) ====================
        async function loadAllVFX() {
            log('info', 'üí• Loading VFX...');
            
            // index.jsonÏóêÏÑú ÌååÏùº Î™©Î°ù Î°úÎìú
            try {
                const indexRes = await fetch('vfx/index.json');
                if (indexRes.ok) {
                    VFX_FILES = await indexRes.json();
                    log('info', `üìã vfx/index.json: ${VFX_FILES.length}Í∞ú Î∞úÍ≤¨`);
                }
            } catch (e) {
                log('warn', '‚ö†Ô∏è vfx/index.json ÏóÜÏùå, Í∏∞Î≥∏ Î™©Î°ù ÏÇ¨Ïö©');
                VFX_FILES = ['slash', 'hit', 'spark', 'dash', 'stab', 'critical', 'block'];
            }
            
            // Í∞Å VFX Î°úÎìú
            for (const id of VFX_FILES) {
                try {
                    const res = await fetch(`vfx/${id}.json`);
                    if (res.ok) {
                        vfxCache.set(id, await res.json());
                    }
                } catch (e) {
                    log('warn', `‚ö†Ô∏è vfx/${id} failed`);
                }
            }
            log('success', `‚úÖ VFX Î°úÎìú ÏôÑÎ£å: ${vfxCache.size}Í∞ú`);
        }
        
        async function loadAllAnimations() {
            log('info', 'üìÅ Loading animations...');
            
            // index.jsonÏóêÏÑú ÌååÏùº Î™©Î°ù Î°úÎìú
            try {
                const indexRes = await fetch('anim/index.json');
                if (indexRes.ok) {
                    ANIM_FILES = await indexRes.json();
                    log('info', `üìã anim/index.json: ${ANIM_FILES.length}Í∞ú Î∞úÍ≤¨`);
                }
            } catch (e) {
                log('warn', '‚ö†Ô∏è anim/index.json ÏóÜÏùå, Í∏∞Î≥∏ Î™©Î°ù ÏÇ¨Ïö©');
                ANIM_FILES = ['player.attack', 'player.hit', 'enemy.attack', 'enemy.hit'];
            }
            
            // Í∞Å Ïï†ÎãàÎ©îÏù¥ÏÖò Î°úÎìú
            for (const id of ANIM_FILES) {
                try {
                    const res = await fetch(`anim/${id}.json`);
                    if (res.ok) {
                        animCache.set(id, await res.json());
                    }
                } catch (e) {
                    log('warn', `‚ö†Ô∏è anim/${id} failed`);
                }
            }
            log('success', `‚úÖ Ïï†ÎãàÎ©îÏù¥ÏÖò Î°úÎìú ÏôÑÎ£å: ${animCache.size}Í∞ú`);
        }
        
        function renderAnimList() {
            const container = document.getElementById('animList');
            container.innerHTML = '';
            animCache.forEach((data, id) => {
                const type = id.split('.')[0];
                const name = id.split('.')[1];
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = id;
                item.innerHTML = `<span class="type ${type}">${type}</span><span class="name">${name}</span>`;
                item.onclick = () => playAnimation(id);
                container.appendChild(item);
            });
        }
        
        // ==================== Î©îÏù∏ Ïû¨ÏÉù ====================
        async function playAnimation(id, skipReset = false) {
            const data = animCache.get(id);
            if (!data) { log('error', `‚ùå Not found: ${id}`); return; }
            
            document.querySelectorAll('.anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`.anim-item[data-id="${id}"]`)?.classList.add('playing');
            
            log('anim', `‚ñ∂Ô∏è ${id}`);
            
            if (!skipReset) {
                resetCharacters();
                await delay(100);
            }
            
            const target = data.target || (id.startsWith('enemy') ? 'enemy' : 'player');
            const container = target === 'player' ? playerContainer : enemyContainer;
            const sprite = target === 'player' ? playerSprite : enemySprite;
            const baseX = target === 'player' ? config.playerBaseX : config.enemyBaseX;
            const dir = target === 'player' ? 1 : -1;
            
            if (data.type === 'sequence' && data.steps) {
                await playSequence(data);
            } else if (data.keyframes) {
                await playKeyframes(data, container, sprite, baseX, dir, false);
            }
        }
        
        // ==================== ÏãúÌÄÄÏä§ Ïû¨ÏÉù ====================
        async function playSequence(data) {
            log('anim', `üé¨ Sequence: ${data.id}`);
            
            for (const step of data.steps) {
                if (step.delay && !step.anim) {
                    await delay(step.delay / config.speed);
                    continue;
                }
                
                if (step.anim) {
                    const animData = animCache.get(step.anim);
                    if (!animData) { log('warn', `‚ö†Ô∏è ${step.anim} not found`); continue; }
                    
                    log('info', `  ‚Üí ${step.anim}`);
                    
                    const target = animData.target || (step.anim.startsWith('enemy') ? 'enemy' : 'player');
                    const container = target === 'player' ? playerContainer : enemyContainer;
                    const sprite = target === 'player' ? playerSprite : enemySprite;
                    const dir = target === 'player' ? 1 : -1;
                    
                    if (step.delay) await delay(step.delay / config.speed);
                    
                    if (animData.keyframes) {
                        const promise = playKeyframes(animData, container, sprite, container.x, dir, true);
                        if (step.wait) await promise;
                    }
                }
            }
            
            log('success', `‚úÖ Sequence done: ${data.id}`);
        }
        
        // ==================== ÌÇ§ÌîÑÎ†àÏûÑ Ïû¨ÏÉù (FGO Ïä§ÌÉÄÏùº) ====================
        async function playKeyframes(data, container, sprite, startX, dir, isRelative) {
            return new Promise((resolve) => {
                const baseScale = 1.0;
                const returnToBase = data.returnToBase;
                const targetBaseX = dir === 1 ? config.playerBaseX : config.enemyBaseX;
                
                gsap.killTweensOf(container);
                gsap.killTweensOf(sprite);
                gsap.killTweensOf(sprite.scale);
                
                const tl = gsap.timeline({
                    timeScale: config.speed,
                    onComplete: () => {
                        if (returnToBase) {
                            gsap.to(container, {
                                x: targetBaseX,
                                duration: 0.25,
                                ease: 'power2.inOut',
                                onComplete: resolve
                            });
                        } else {
                            resolve();
                        }
                    }
                });
                
                data.keyframes.forEach((kf, idx) => {
                    if (idx === 0) return;
                    
                    const dur = (kf.duration || 100) / 1000;
                    const ease = kf.ease || 'power2.out';
                    const pos = idx === 1 ? 0 : '>';
                    
                    // Ïª®ÌÖåÏù¥ÎÑà Ïù¥Îèô
                    if (kf.x !== undefined) {
                        const targetX = isRelative ? startX + (kf.x * dir) : config.playerBaseX + (kf.x * dir);
                        tl.to(container, { x: targetX, duration: dur, ease }, pos);
                    }
                    
                    if (kf.y !== undefined) {
                        tl.to(container, { y: config.baseY + kf.y, duration: dur, ease }, '<');
                    }
                    
                    // Ïä§ÏºÄÏùº (Ïä§ÏøºÏãú/Ïä§Ìä∏Î†àÏπò)
                    if (kf.scaleX !== undefined || kf.scaleY !== undefined) {
                        const scaleX = (kf.scaleX ?? 1) * baseScale;
                        const scaleY = (kf.scaleY ?? 1) * baseScale;
                        tl.to(sprite.scale, { x: scaleX, y: scaleY, duration: dur, ease }, '<');
                    }
                    
                    // ÌöåÏ†Ñ
                    if (kf.rotation !== undefined) {
                        tl.to(sprite, { rotation: kf.rotation * dir, duration: dur, ease }, '<');
                    }
                    
                    // ÏïåÌåå
                    if (kf.alpha !== undefined) {
                        tl.to(sprite, { alpha: kf.alpha, duration: dur, ease }, '<');
                    }
                    
                    // ========== VFX Ìä∏Î¶¨Í±∞ ==========
                    if (kf.vfx) {
                        tl.call(() => triggerVFX(kf.vfx, container, dir), null, '<');
                    }
                    
                    // ========== ÌûàÌä∏Ïä§ÌÜ± ==========
                    if (kf.hitstop) {
                        tl.call(() => {
                            tl.pause();
                            setTimeout(() => tl.resume(), kf.hitstop / config.speed);
                        }, null, '>');
                    }
                    
                    // ========== Ïä§ÌÅ¨Î¶∞ÏâêÏù¥ÌÅ¨ ==========
                    if (kf.shake) {
                        tl.call(() => screenShake(kf.shake), null, '<');
                    }
                    
                    // ========== ÏûîÏÉÅ ÏÉùÏÑ± ==========
                    if (kf.afterimage) {
                        tl.call(() => {
                            const tint = data.target === 'player' ? 0x60a5fa : 0xef4444;
                            createAfterimage(sprite, container, 0.7, tint);
                        }, null, '<');
                    }
                });
            });
        }
        
        function resetCharacters() {
            gsap.killTweensOf(playerContainer);
            gsap.killTweensOf(playerSprite);
            gsap.killTweensOf(playerSprite.scale);
            gsap.killTweensOf(enemyContainer);
            gsap.killTweensOf(enemySprite);
            gsap.killTweensOf(enemySprite.scale);
            gsap.killTweensOf(stageContainer);
            
            playerContainer.x = config.playerBaseX;
            playerContainer.y = config.baseY;
            playerSprite.rotation = 0;
            playerSprite.scale.set(1.0);
            playerSprite.alpha = 1;
            
            enemyContainer.x = config.enemyBaseX;
            enemyContainer.y = config.baseY;
            enemySprite.rotation = 0;
            enemySprite.scale.set(1.0);
            enemySprite.alpha = 1;
            
            stageContainer.x = 0;
            stageContainer.y = 0;
            
            clearVFX();
            clearAfterimages();
            startBreathing();
        }
        
        // ==================== VFX ÏãúÏä§ÌÖú (JSON Í∏∞Î∞ò) ====================
        
        // Ï∫êÎ¶≠ÌÑ∞Ïùò Ïã§Ï†ú Î∞îÏö¥Îìú Í≥ÑÏÇ∞
        function getCharacterBounds(container) {
            const sprite = container.children[0];
            if (!sprite) return { width: 60, height: 120, centerY: -60 };
            
            const bounds = sprite.getBounds();
            const scale = sprite.scale.x;
            
            return {
                width: bounds.width,
                height: bounds.height,
                centerY: -bounds.height / 2,  // Ï§ëÏã¨Ï†ê Y
                scale: scale
            };
        }
        
        // ÌÉÄÍ≤©Ï†ê Í≥ÑÏÇ∞ (Ï†Å ÏúÑÏπò Í∏∞Ï§Ä)
        function getHitPoint(attackerContainer, targetContainer) {
            const targetBounds = getCharacterBounds(targetContainer);
            
            // ÌÉÄÍ≤©Ï†êÏùÄ ÌÉÄÍ≤ü Ï∫êÎ¶≠ÌÑ∞Ïùò Ï§ëÏã¨
            return {
                x: targetContainer.x,
                y: targetContainer.y + targetBounds.centerY,
                scale: targetBounds.scale
            };
        }
        
        function triggerVFX(vfxId, container, dir) {
            const vfxData = vfxCache.get(vfxId);
            if (!vfxData) {
                log('warn', `‚ö†Ô∏è VFX not found: ${vfxId}`);
                return;
            }
            
            // ÌÉÄÍ≤©Ï†ê Í≥ÑÏÇ∞: Í≥µÍ≤©ÏûêÍ∞Ä ÌîåÎ†àÏù¥Ïñ¥Î©¥ Ï†ÅÏóêÍ≤å, Ï†ÅÏù¥Î©¥ ÌîåÎ†àÏù¥Ïñ¥ÏóêÍ≤å
            const isPlayer = container === playerContainer;
            const targetContainer = isPlayer ? enemyContainer : playerContainer;
            const hitPoint = getHitPoint(container, targetContainer);
            
            // VFX ÌÉÄÏûÖÏóê Îî∞Î•∏ ÏúÑÏπò Í≤∞Ï†ï
            let vfxX, vfxY, vfxScale;
            
            if (vfxId === 'dash' || vfxId === 'trail') {
                // ÎåÄÏãú/Ìä∏Î†àÏùºÏùÄ ÏûêÏã† ÏúÑÏπò
                const bounds = getCharacterBounds(container);
                vfxX = container.x;
                vfxY = container.y + bounds.centerY;
                vfxScale = bounds.scale;
            } else {
                // Í≥µÍ≤© Ïù¥ÌéôÌä∏Îäî ÌÉÄÍ≤©Ï†ê (ÌÉÄÍ≤ü ÏúÑÏπò)
                vfxX = hitPoint.x;
                vfxY = hitPoint.y;
                vfxScale = hitPoint.scale;
            }
            
            log('vfx', `üí• ${vfxId} at (${vfxX.toFixed(0)}, ${vfxY.toFixed(0)}) scale:${vfxScale.toFixed(2)}`);
            
            // VFXÏóê Ï†ïÏùòÎêú shake Ïã§Ìñâ
            if (vfxData.shake) {
                screenShake(vfxData.shake);
            }
            
            // Í∞Å ÌååÌã∞ÌÅ¥ Ï†ïÏùò Ï≤òÎ¶¨
            for (const pDef of vfxData.particles) {
                spawnParticlesFromDef(pDef, vfxX, vfxY, dir, container, vfxScale);
            }
        }
        
        // JSON Ï†ïÏùòÏóêÏÑú ÌååÌã∞ÌÅ¥ ÏÉùÏÑ± (Ïä§ÏºÄÏùº Ï†ÅÏö©)
        function spawnParticlesFromDef(def, x, y, dir, container, scale = 1.0) {
            const count = def.count || 1;
            const delayBetween = def.delay || 0;
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    switch (def.type) {
                        case 'slash':
                        case 'thrust':
                            spawnSlashParticle(def, x, y, dir, i, scale);
                            break;
                        case 'arrow':
                        case 'wedge':
                            spawnArrowParticle(def, x, y, dir, i, scale);
                            break;
                        case 'spark':
                            spawnSparkParticle(def, x, y, scale);
                            break;
                        case 'flash':
                            spawnFlashParticle(def, x, y, scale);
                            break;
                        case 'ring':
                            spawnRingParticle(def, x, y, scale);
                            break;
                        case 'line':
                            spawnLineParticle(def, x, y, i, scale);
                            break;
                        case 'debris':
                            spawnDebrisParticle(def, x, y, scale);
                            break;
                        case 'trail':
                            spawnTrailParticle(def, container, i, scale);
                            break;
                        case 'projectile':
                            spawnProjectileParticle(def, x, y, dir, scale, container);
                            break;
                    }
                }, i * delayBetween);
            }
        }
        
        function spawnSlashParticle(def, x, y, dir, index, scale) {
            const angles = Array.isArray(def.angle) ? def.angle : [def.angle || 0];
            const angle = angles[index % angles.length] || (Math.random() - 0.5) * 60;
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 8) * scale;
            
            spawnParticle({
                type: 'slash',
                x, y,
                angle: angle * dir,
                length: length,
                width: width,
                color: def.color || '#ffffff',
                glow: def.glow || '#60a5fa',
                life: def.life || 150
            });
        }
        
        // ">" Î™®Ïñë ÌôîÏÇ¥Ìëú Ïù¥ÌéôÌä∏
        function spawnArrowParticle(def, x, y, dir, index, scale) {
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 60) * scale;
            const tipAngle = def.tipAngle || 35; // ÌôîÏÇ¥Ï¥â Í∞ÅÎèÑ
            
            const p = {
                type: 'arrow',
                x, y,
                dir: dir,
                startLength: length,
                startWidth: width,
                tipAngle: tipAngle,
                color: def.color || '#ffffff',
                glow: def.glow || '#a78bfa',
                innerColor: def.innerColor || 'rgba(167, 139, 250, 0.5)',
                life: def.life || 120
            };
            spawnParticle(p);
        }
        
        function spawnSparkParticle(def, x, y, scale) {
            const spread = (def.spread || 50) * scale;
            const speed = getRandValue(def.speed) * scale;
            const size = getRandValue(def.size) * scale;
            const angle = Math.random() * Math.PI * 2;
            const colors = def.colors || [def.color || '#fbbf24'];
            
            spawnParticle({
                type: 'spark',
                x: x + (Math.random() - 0.5) * spread,
                y: y + (Math.random() - 0.5) * spread,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2,
                size: size,
                color: colors[Math.floor(Math.random() * colors.length)],
                life: getRandValue(def.life)
            });
        }
        
        function spawnFlashParticle(def, x, y, scale) {
            spawnParticle({
                type: 'flash',
                x, y,
                size: (def.size || 80) * scale,
                color: def.color || '#ffffff',
                life: def.life || 80
            });
        }
        
        function spawnRingParticle(def, x, y, scale) {
            spawnParticle({
                type: 'ring',
                x, y,
                size: (def.size || 20) * scale,
                maxSize: (def.maxSize || 100) * scale,
                color: def.color || '#ef4444',
                life: def.life || 200
            });
        }
        
        function spawnLineParticle(def, x, y, index, scale) {
            const angleStep = def.angleStep || 30;
            const angle = index * angleStep;
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 3) * scale;
            
            spawnParticle({
                type: 'line',
                x, y,
                angle: angle,
                length: length,
                width: width,
                color: def.color || '#fbbf24',
                life: def.life || 150
            });
        }
        
        function spawnDebrisParticle(def, x, y, scale) {
            const speed = getRandValue(def.speed) * scale;
            const size = getRandValue(def.size) * scale;
            const angle = Math.random() * Math.PI * 2;
            const colors = def.colors || [def.color || '#ef4444'];
            
            spawnParticle({
                type: 'debris',
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 5,
                size: size,
                color: colors[Math.floor(Math.random() * colors.length)],
                gravity: def.gravity || 0.3,
                life: getRandValue(def.life)
            });
        }
        
        function spawnTrailParticle(def, container, index, scale) {
            const bounds = getCharacterBounds(container);
            const offsetX = (def.offsetX || -20) * index * scale;
            const size = (getRandValue(def.size) - index * 5) * scale;
            
            spawnParticle({
                type: 'trail',
                x: container.x + offsetX,
                y: container.y + bounds.centerY,
                size: Math.max(size, 10),
                color: def.color || 'rgba(96, 165, 250, 0.3)',
                life: def.life || 150
            });
        }
        
        function spawnProjectileParticle(def, startX, startY, dir, scale, container) {
            // ÏãúÏûëÏ†ê (ÌîåÎ†àÏù¥Ïñ¥) ‚Üí ÎÅùÏ†ê (Ï†Å)
            const targetContainer = container === playerContainer ? enemyContainer : playerContainer;
            const targetBounds = getCharacterBounds(targetContainer);
            const endX = targetContainer.x;
            const endY = targetContainer.y + targetBounds.centerY;
            
            spawnParticle({
                type: 'projectile',
                x: startX,
                y: startY,
                targetX: endX,
                targetY: endY,
                speed: (def.speed || 20) * scale,
                rotation: def.rotation || 0,
                size: (def.size || 15) * scale,
                shape: def.shape || 'circle',
                color: def.color || '#94a3b8',
                glow: def.glow || '#60a5fa',
                life: def.life || 300,
                dir: dir
            });
        }
        
        // Ïú†Ìã∏: Î∞∞Ïó¥Ïù¥Î©¥ ÎûúÎç§ Î≤îÏúÑ, ÏïÑÎãàÎ©¥ Í∑∏ÎåÄÎ°ú
        function getRandValue(val) {
            if (Array.isArray(val)) {
                return val[0] + Math.random() * (val[1] - val[0]);
            }
            return val || 0;
        }
        
        // ÌååÌã∞ÌÅ¥ Ïä§Ìè∞
        function spawnParticle(config) {
            particles.push({
                ...config,
                startLife: config.life,
                startSize: config.size || 10,
                startLength: config.length || 50,
                born: performance.now()
            });
        }
        
        // VFX Î†åÎçî Î£®ÌîÑ
        function startVFXLoop() {
            let lastTime = performance.now();
            
            function render() {
                const now = performance.now();
                const delta = (now - lastTime) / 16.67; // 60fps Í∏∞Ï§Ä
                lastTime = now;
                
                // ÏûîÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏
                updateAfterimages(delta);
                
                vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const age = now - p.born;
                    const progress = age / p.startLife;
                    
                    if (progress >= 1) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    const alpha = 1 - progress;
                    
                    vfxCtx.save();
                    
                    switch (p.type) {
                        case 'slash':
                            drawSlashParticle(p, alpha, progress);
                            break;
                        case 'arrow':
                            drawArrowParticle(p, alpha, progress);
                            break;
                        case 'spark':
                            p.x += p.vx || 0;
                            p.y += p.vy || 0;
                            if (p.gravity) p.vy += p.gravity;
                            drawSparkParticle(p, alpha);
                            break;
                        case 'flash':
                            drawFlashParticle(p, alpha, progress);
                            break;
                        case 'ring':
                            drawRingParticle(p, alpha, progress);
                            break;
                        case 'line':
                            drawLineParticle(p, alpha, progress);
                            break;
                        case 'debris':
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += p.gravity;
                            drawDebrisParticle(p, alpha);
                            break;
                        case 'trail':
                            drawTrailParticle(p, alpha);
                            break;
                        case 'projectile':
                            updateAndDrawProjectile(p, alpha, progress);
                            break;
                    }
                    
                    vfxCtx.restore();
                }
                
                animationFrame = requestAnimationFrame(render);
            }
            render();
        }
        
        function drawSlashParticle(p, alpha, progress) {
            const rad = p.angle * Math.PI / 180;
            const len = p.startLength * (1 - progress * 0.3);
            
            vfxCtx.translate(p.x, p.y);
            vfxCtx.rotate(rad);
            
            // Í∏ÄÎ°úÏö∞
            if (p.glow) {
                vfxCtx.shadowColor = p.glow;
                vfxCtx.shadowBlur = 20;
            }
            
            // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ïä¨ÎûòÏãú
            const grad = vfxCtx.createLinearGradient(-len/2, 0, len/2, 0);
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(0.3, p.color);
            grad.addColorStop(0.7, p.color);
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.strokeStyle = grad;
            vfxCtx.lineWidth = p.width * alpha;
            vfxCtx.lineCap = 'round';
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(-len/2, 0);
            vfxCtx.lineTo(len/2, 0);
            vfxCtx.stroke();
        }
        
        // ">" ÌôîÏÇ¥Ìëú Î™®Ïñë Í∑∏Î¶¨Í∏∞
        function drawArrowParticle(p, alpha, progress) {
            const len = p.startLength * (1 - progress * 0.4);
            const width = p.startWidth * (1 - progress * 0.3);
            const tipRad = (p.tipAngle || 35) * Math.PI / 180;
            
            // ÌôîÏÇ¥Ìëú Î∞©Ìñ• (dir: 1 = Ïò§Î•∏Ï™Ω, -1 = ÏôºÏ™Ω)
            const dir = p.dir || 1;
            
            vfxCtx.translate(p.x, p.y);
            if (dir < 0) vfxCtx.scale(-1, 1);
            
            // Í∏ÄÎ°úÏö∞
            if (p.glow) {
                vfxCtx.shadowColor = p.glow;
                vfxCtx.shadowBlur = 25;
            }
            vfxCtx.globalAlpha = alpha;
            
            // ÎÇ¥Î∂Ä Ï±ÑÏö∞Í∏∞ (Î∞òÌà¨Î™Ö)
            if (p.innerColor) {
                vfxCtx.fillStyle = p.innerColor;
                vfxCtx.beginPath();
                vfxCtx.moveTo(len, 0);                          // Îæ∞Ï°±Ìïú ÎÅù
                vfxCtx.lineTo(0, -width * Math.sin(tipRad));    // ÏúÑÏ™Ω ÎÇ†Í∞ú
                vfxCtx.lineTo(len * 0.3, 0);                    // ÏïàÏ™Ω Í∫æÏûÑ
                vfxCtx.lineTo(0, width * Math.sin(tipRad));     // ÏïÑÎûòÏ™Ω ÎÇ†Í∞ú
                vfxCtx.closePath();
                vfxCtx.fill();
            }
            
            // Ïô∏Í≥ΩÏÑ† (Î∞ùÏùÄ ÏÉâ)
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = 3 * alpha;
            vfxCtx.lineCap = 'round';
            vfxCtx.lineJoin = 'round';
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(0, -width * Math.sin(tipRad));  // ÏúÑÏ™Ω ÎÇ†Í∞ú
            vfxCtx.lineTo(len, 0);                         // Îæ∞Ï°±Ìïú ÎÅù
            vfxCtx.lineTo(0, width * Math.sin(tipRad));   // ÏïÑÎûòÏ™Ω ÎÇ†Í∞ú
            vfxCtx.stroke();
            
            // Ï§ëÏïô Í∞ïÏ°∞ÏÑ†
            vfxCtx.strokeStyle = '#ffffff';
            vfxCtx.lineWidth = 2 * alpha;
            vfxCtx.beginPath();
            vfxCtx.moveTo(len * 0.2, 0);
            vfxCtx.lineTo(len * 0.9, 0);
            vfxCtx.stroke();
        }
        
        function drawSparkParticle(p, alpha) {
            vfxCtx.fillStyle = p.color;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 8;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawFlashParticle(p, alpha, progress) {
            const size = p.startSize * (1 + progress);
            const grad = vfxCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
            grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
            grad.addColorStop(0.5, `rgba(255,255,255,${alpha * 0.5})`);
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.fillStyle = grad;
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawRingParticle(p, alpha, progress) {
            const size = p.size + (p.maxSize - p.size) * progress;
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = 4 * alpha;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 15;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
            vfxCtx.stroke();
        }
        
        function drawLineParticle(p, alpha, progress) {
            const rad = p.angle * Math.PI / 180;
            const len = p.startLength * (1 - progress * 0.5);
            const startOffset = p.startLength * progress * 0.3;
            
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = p.width * alpha;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.lineCap = 'round';
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 8;
            
            const sx = p.x + Math.cos(rad) * startOffset;
            const sy = p.y + Math.sin(rad) * startOffset;
            const ex = p.x + Math.cos(rad) * (startOffset + len);
            const ey = p.y + Math.sin(rad) * (startOffset + len);
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(sx, sy);
            vfxCtx.lineTo(ex, ey);
            vfxCtx.stroke();
        }
        
        function drawDebrisParticle(p, alpha) {
            vfxCtx.fillStyle = p.color;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 5;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawTrailParticle(p, alpha) {
            // NaN/Infinity Ï≤¥ÌÅ¨
            if (!isFinite(p.x) || !isFinite(p.y) || !isFinite(p.size) || p.size <= 0) {
                return;
            }
            
            const grad = vfxCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
            grad.addColorStop(0, p.color.replace('0.3', String(0.3 * alpha)));
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.fillStyle = grad;
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function updateAndDrawProjectile(p, alpha, progress) {
            // Ìà¨ÏÇ¨Ï≤¥ Ïù¥Îèô (ÏãúÏûëÏ†ê ‚Üí ÌÉÄÍ≤ü)
            const dx = p.targetX - p.x;
            const dy = p.targetY - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > p.speed) {
                p.x += (dx / dist) * p.speed;
                p.y += (dy / dist) * p.speed;
            }
            
            // ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏
            if (p.rotation) {
                p.currentRotation = (p.currentRotation || 0) + (p.rotation * Math.PI / 180) * 0.016;
            }
            
            vfxCtx.save();
            vfxCtx.translate(p.x, p.y);
            vfxCtx.rotate(p.currentRotation || 0);
            
            // Í∏ÄÎ°úÏö∞
            vfxCtx.shadowColor = p.glow;
            vfxCtx.shadowBlur = 12;
            vfxCtx.globalAlpha = alpha;
            
            // Îã®Í≤Ä Í∑∏Î¶¨Í∏∞
            if (p.shape === 'dagger') {
                // Îã®Í≤Ä Î∏îÎ†àÏù¥Îìú
                vfxCtx.fillStyle = p.color;
                vfxCtx.beginPath();
                vfxCtx.moveTo(p.size, 0);           // ÎÅù
                vfxCtx.lineTo(0, -p.size * 0.3);    // ÏúÑ
                vfxCtx.lineTo(-p.size * 0.5, 0);    // ÏÜêÏû°Ïù¥
                vfxCtx.lineTo(0, p.size * 0.3);     // ÏïÑÎûò
                vfxCtx.closePath();
                vfxCtx.fill();
                
                // ÌïòÏù¥ÎùºÏù¥Ìä∏
                vfxCtx.fillStyle = '#ffffff';
                vfxCtx.globalAlpha = alpha * 0.6;
                vfxCtx.beginPath();
                vfxCtx.moveTo(p.size * 0.8, 0);
                vfxCtx.lineTo(0, -p.size * 0.15);
                vfxCtx.lineTo(-p.size * 0.2, 0);
                vfxCtx.closePath();
                vfxCtx.fill();
            } else {
                // Í∏∞Î≥∏ ÏõêÌòï
                vfxCtx.fillStyle = p.color;
                vfxCtx.beginPath();
                vfxCtx.arc(0, 0, p.size, 0, Math.PI * 2);
                vfxCtx.fill();
            }
            
            vfxCtx.restore();
            
            // ÏûîÏÉÅ Ìä∏Î†àÏùº ÏÉùÏÑ± (dist > 0 Ïùº ÎïåÎßå)
            if (dist > 0.1 && Math.random() > 0.6) {
                spawnParticle({
                    type: 'trail',
                    x: p.x - (dx / dist) * 10,
                    y: p.y - (dy / dist) * 10,
                    size: p.size * 0.5,
                    color: 'rgba(148, 163, 184, 0.2)',
                    life: 80
                });
            }
        }
        
        
        // Ïä§ÌÅ¨Î¶∞ÏâêÏù¥ÌÅ¨
        function screenShake(intensity) {
            const duration = 150;
            const startTime = performance.now();
            
            function shake() {
                const elapsed = performance.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    stageContainer.x = 0;
                    stageContainer.y = 0;
                    return;
                }
                
                const decay = 1 - progress;
                const offsetX = (Math.random() - 0.5) * intensity * decay;
                const offsetY = (Math.random() - 0.5) * intensity * decay;
                
                stageContainer.x = offsetX;
                stageContainer.y = offsetY;
                
                requestAnimationFrame(shake);
            }
            shake();
        }
        
        function clearVFX() {
            particles.length = 0;
            vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
        }
        
        // ==================== Ïú†Ìã∏ ====================
        function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
        
        function updateSpeed() {
            config.speed = parseFloat(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = config.speed.toFixed(1) + 'x';
        }
        
        function log(type, msg) {
            const c = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString('ko-KR', { hour12: false });
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${msg}`;
            c.appendChild(entry);
            c.scrollTop = c.scrollHeight;
        }
        
        function clearLog() { document.getElementById('logContainer').innerHTML = ''; }
        
        function startUpdateLoop() {
            setInterval(() => {
                if (!playerContainer) return;
                document.getElementById('playerPos').textContent = `${playerContainer.x.toFixed(0)}, ${playerContainer.y.toFixed(0)}`;
                document.getElementById('enemyPos').textContent = `${enemyContainer.x.toFixed(0)}, ${enemyContainer.y.toFixed(0)}`;
                document.getElementById('fpsValue').textContent = Math.round(app.ticker.FPS);
            }, 100);
        }
    </script>
</body>
</html>
