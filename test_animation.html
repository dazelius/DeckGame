<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ® DDOO Action Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi-filters/5.2.1/pixi-filters.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="background-3d.js?v=3"></script>
    <!-- DDOO Action Engine v3.2 + ëª¨ë“ˆ -->
    <script src="ddoo-utils.js?v=3"></script>
    <script src="ddoo-draw.js?v=4"></script>
    <script src="ddoo-chakram.js?v=2"></script>
    <script src="ddoo-renderer.js?v=1"></script>
    <script src="ddoo-action.js?v=60"></script>
    <script src="ddoo-vfx-3d.js?v=3"></script>
    <!-- ğŸ ë²ˆë“¤ (fetch ì—†ì´ ì¦‰ì‹œ ë¡œë“œ!) -->
    <script src="anim-bundle.js?v=27"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        .header {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            border-bottom: 2px solid #fbbf24;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        .header h1 {
            font-family: 'Cinzel', serif;
            color: #fbbf24;
            font-size: 1.2rem;
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
        }
        .header-btn {
            background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%);
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
        }
        .main-container {
            display: flex;
            height: 100vh;
            padding-top: 50px;
        }
        .control-panel {
            width: 280px;
            background: #0f0f18;
            border-right: 1px solid #2a2a3a;
            overflow-y: auto;
            padding: 12px;
        }
        .panel-section {
            background: #1a1a28;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .panel-section h3 {
            color: #fbbf24;
            font-size: 0.85rem;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3a3a5a;
        }
        .anim-list { display: flex; flex-direction: column; gap: 4px; }
        .anim-item {
            background: #252535;
            border: 1px solid #3a3a5a;
            padding: 8px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }
        .anim-item:hover { background: #353550; border-color: #60a5fa; }
        .anim-item.playing { background: #1e3a5f; border-color: #60a5fa; }
        .anim-item .type {
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: bold;
        }
        .anim-item .type.player { background: #3b82f6; }
        .anim-item .type.enemy { background: #ef4444; }
        .anim-item .type.card { background: #a855f7; }
        .anim-item .name { flex: 1; }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .speed-control label { color: #888; font-size: 0.75rem; }
        .speed-control input { flex: 1; }
        .speed-control .value { color: #60a5fa; font-size: 0.75rem; }
        
        /* íƒ­ ë„¤ë¹„ê²Œì´ì…˜ */
        .panel-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
            background: #0a0a12;
            padding: 4px;
            border-radius: 6px;
        }
        .panel-tab {
            flex: 1;
            background: #1a1a28;
            border: 1px solid #2a2a4a;
            padding: 8px 4px;
            border-radius: 4px;
            color: #888;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            transition: all 0.15s;
        }
        .panel-tab:hover { background: #252538; color: #ccc; }
        .panel-tab.active { 
            background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
            color: #fff; 
            border-color: #60a5fa;
        }
        .tab-content { max-height: calc(100vh - 380px); overflow-y: auto; }
        
        /* Draw ì„¤ì • */
        .draw-settings { display: flex; flex-direction: column; gap: 8px; }
        .setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .setting-row label { 
            color: #888; 
            font-size: 0.7rem; 
            min-width: 45px;
        }
        .setting-row input[type="color"] {
            width: 40px;
            height: 24px;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }
        .setting-row input[type="range"] { flex: 1; }
        .setting-row .value { 
            color: #60a5fa; 
            font-size: 0.7rem; 
            min-width: 40px;
            text-align: right;
        }
        
        /* VFX/Draw ì•„ì´í…œ íƒ€ì… ë°°ì§€ */
        .anim-item .type.vfx { background: #a855f7; }
        .anim-item .type.draw { background: #f472b6; }
        .anim-item .type.particle { background: #06b6d4; }
        .anim-item .type.effect-3d { 
            background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%); 
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .stage-container {
            flex: 1;
            position: relative;
            background: #0a0a12;
            overflow: hidden;
        }
        #pixiContainer { 
            width: 100%; 
            height: 100%;
            position: relative;
        }
        #bg3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        #pixiContainer canvas {
            position: relative;
            z-index: 1;
        }
        #vfxCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .stage-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #3a3a5a;
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.7rem;
            z-index: 20;
        }
        .stat-row { display: flex; justify-content: space-between; gap: 15px; color: #666; margin-bottom: 2px; }
        .stat-row .value { color: #60a5fa; }
        .log-panel {
            width: 260px;
            background: #0f0f18;
            border-left: 1px solid #2a2a3a;
            display: flex;
            flex-direction: column;
        }
        .log-header {
            padding: 8px 12px;
            background: #1a1a28;
            border-bottom: 1px solid #2a2a4a;
            font-size: 0.8rem;
            color: #fbbf24;
            display: flex;
            justify-content: space-between;
        }
        .log-header button {
            background: #3a3a5a;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            color: #888;
            cursor: pointer;
            font-size: 0.65rem;
        }
        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-family: monospace;
            font-size: 0.7rem;
        }
        .log-entry { padding: 3px 0; border-bottom: 1px solid #1a1a2a; }
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #34d399; }
        .log-entry.warn { color: #fbbf24; }
        .log-entry.error { color: #ef4444; }
        .log-entry.anim { color: #a78bfa; }
        .log-entry.vfx { color: #f472b6; }
        .log-time { color: #444; margin-right: 5px; }
        
        /* ==================== íƒ€ì„ë¼ì¸ íŒ¨ë„ (ê°œì„ ) ==================== */
        .timeline-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 240px;
            background: #0a0a12;
            border-top: 2px solid #fbbf24;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: height 0.2s ease;
        }
        .timeline-panel.collapsed { height: 32px; }
        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 12px;
            background: linear-gradient(180deg, #1a1a2e 0%, #12121f 100%);
            border-bottom: 1px solid #2a2a4a;
            min-height: 32px;
        }
        .timeline-header h3 { color: #fbbf24; font-size: 0.75rem; margin: 0; display: flex; align-items: center; gap: 8px; }
        .timeline-header h3 .anim-name { color: #60a5fa; font-weight: normal; }
        .timeline-controls { display: flex; gap: 6px; align-items: center; }
        .timeline-btn {
            background: #2a2a4a;
            border: 1px solid #3a3a5a;
            padding: 3px 8px;
            border-radius: 3px;
            color: #ccc;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.1s;
        }
        .timeline-btn:hover { background: #3a3a5a; border-color: #60a5fa; }
        .timeline-btn.active { background: #3b82f6; color: #fff; border-color: #60a5fa; }
        .timeline-btn.play { background: #22c55e; color: #000; border-color: #4ade80; }
        .timeline-btn.play:hover { background: #16a34a; }
        .timeline-time { font-family: 'Consolas', monospace; color: #60a5fa; font-size: 0.75rem; min-width: 100px; text-align: right; }
        .timeline-body { flex: 1; display: flex; overflow: hidden; }
        .timeline-tracks {
            width: 100px;
            background: #0d0d18;
            border-right: 1px solid #2a2a4a;
            flex-shrink: 0;
            overflow-y: auto;
        }
        .timeline-track-header {
            height: 26px;
            padding: 0 8px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #1a1a2a;
            font-size: 0.65rem;
            color: #666;
            gap: 4px;
        }
        .timeline-track-header .icon { font-size: 0.7rem; }
        .timeline-track-header.player { color: #60a5fa; }
        .timeline-track-header.enemy { color: #ef4444; }
        .timeline-track-header.vfx { color: #a855f7; }
        .timeline-track-header.camera { color: #06b6d4; }
        .timeline-track-header.effects { color: #f59e0b; }
        .timeline-track-header.damage { color: #ef4444; }
        .timeline-content {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            cursor: grab;
        }
        .timeline-content:active { cursor: grabbing; }
        .timeline-ruler {
            height: 22px;
            background: #12121f;
            border-bottom: 1px solid #2a2a4a;
            position: sticky;
            top: 0;
            z-index: 50;
        }
        .timeline-ruler-mark {
            position: absolute;
            top: 0;
            height: 100%;
            border-left: 1px solid #252535;
            font-size: 0.55rem;
            color: #444;
            padding-left: 2px;
            padding-top: 1px;
            user-select: none;
        }
        .timeline-ruler-mark.major { border-color: #3a3a5a; color: #666; }
        .timeline-lanes { position: relative; min-height: 156px; }
        .timeline-lane {
            height: 26px;
            border-bottom: 1px solid #151520;
            position: relative;
        }
        .timeline-lane:nth-child(odd) { background: rgba(255,255,255,0.01); }
        .timeline-keyframe {
            position: absolute;
            height: 20px;
            top: 3px;
            border-radius: 2px;
            font-size: 0.55rem;
            display: flex;
            align-items: center;
            padding: 0 3px;
            cursor: pointer;
            overflow: hidden;
            white-space: nowrap;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .timeline-keyframe:hover { transform: translateY(-1px); box-shadow: 0 2px 6px rgba(0,0,0,0.5); z-index: 10; }
        .timeline-keyframe.player { background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%); border: 1px solid #60a5fa; }
        .timeline-keyframe.enemy { background: linear-gradient(180deg, #ef4444 0%, #b91c1c 100%); border: 1px solid #f87171; }
        .timeline-keyframe.vfx { background: linear-gradient(180deg, #a855f7 0%, #7c3aed 100%); border: 1px solid #c084fc; }
        .timeline-keyframe.camera { background: linear-gradient(180deg, #06b6d4 0%, #0891b2 100%); border: 1px solid #22d3ee; }
        .timeline-keyframe.shake { background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%); border: 1px solid #fbbf24; }
        .timeline-keyframe.hitstop { background: linear-gradient(180deg, #10b981 0%, #059669 100%); border: 1px solid #34d399; }
        .timeline-keyframe.slowmo { background: linear-gradient(180deg, #8b5cf6 0%, #6d28d9 100%); border: 1px solid #a78bfa; }
        .timeline-keyframe.color { background: linear-gradient(180deg, #ec4899 0%, #be185d 100%); border: 1px solid #f472b6; }
        .timeline-keyframe.damage { background: linear-gradient(180deg, #dc2626 0%, #991b1b 100%); border: 1px solid #f87171; }
        .timeline-keyframe.shatter { background: linear-gradient(180deg, #14b8a6 0%, #0d9488 100%); border: 1px solid #2dd4bf; }
        .timeline-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(239,68,68,0.6);
        }
        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -4px;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid #ef4444;
        }
        .timeline-empty { display: flex; align-items: center; justify-content: center; height: 100%; color: #444; font-size: 0.75rem; }
        .timeline-tooltip {
            position: fixed;
            background: #1a1a2e;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 0.65rem;
            color: #ddd;
            z-index: 2000;
            pointer-events: none;
            max-width: 250px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .timeline-tooltip .tt-title { color: #fbbf24; font-weight: bold; margin-bottom: 4px; }
        .timeline-tooltip .tt-row { display: flex; gap: 8px; color: #999; }
        .timeline-tooltip .tt-row span:first-child { color: #666; min-width: 50px; }
        /* ë©”ì¸ ì»¨í…Œì´ë„ˆ ë†’ì´ ì¡°ì • */
        .main-container { height: calc(100vh - 240px); transition: height 0.2s ease; }
        .main-container.timeline-collapsed { height: calc(100vh - 32px); }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® DDOO Action Studio v1.0</h1>
        <button class="header-btn" onclick="location.href='index.html'">ğŸ® ê²Œì„ìœ¼ë¡œ</button>
    </div>
    
    <div class="main-container">
        <div class="control-panel">
            <!-- íƒ­ ë„¤ë¹„ê²Œì´ì…˜ -->
            <div class="panel-tabs">
                <button class="panel-tab active" data-tab="anim" onclick="switchTab('anim')">ğŸ¬ Anim</button>
                <button class="panel-tab" data-tab="vfx" onclick="switchTab('vfx')">âœ¨ VFX</button>
                <button class="panel-tab" data-tab="draw" onclick="switchTab('draw')">ğŸ¨ Draw</button>
                <button class="panel-tab" data-tab="render" onclick="switchTab('render')">ğŸ–¼ï¸ Render</button>
            </div>
            
            <!-- ì• ë‹ˆë©”ì´ì…˜ íƒ­ -->
            <div class="tab-content" id="tab-anim">
                <div class="panel-section">
                    <h3>ğŸ“ Animations</h3>
                    <div id="animList" class="anim-list"></div>
                </div>
            </div>
            
            <!-- VFX íƒ­ -->
            <div class="tab-content" id="tab-vfx" style="display:none;">
                <div class="panel-section">
                    <h3>âœ¨ VFX Effects</h3>
                    <div id="vfxList" class="anim-list"></div>
                </div>
            </div>
            
            <!-- Draw íƒ­ -->
            <div class="tab-content" id="tab-draw" style="display:none;">
                <div class="panel-section">
                    <h3>ğŸ¨ Draw Particles</h3>
                    <div id="drawList" class="anim-list"></div>
                </div>
                <div class="panel-section">
                    <h3>ğŸ›ï¸ Draw Settings</h3>
                    <div class="draw-settings">
                        <div class="setting-row">
                            <label>Color</label>
                            <input type="color" id="drawColor" value="#60a5fa">
                        </div>
                        <div class="setting-row">
                            <label>Glow</label>
                            <input type="color" id="drawGlow" value="#3b82f6">
                        </div>
                        <div class="setting-row">
                            <label>Size</label>
                            <input type="range" id="drawSize" min="50" max="300" value="150">
                            <span class="value" id="drawSizeValue">150</span>
                        </div>
                        <div class="setting-row">
                            <label>Angle</label>
                            <input type="range" id="drawAngle" min="-180" max="180" value="-30">
                            <span class="value" id="drawAngleValue">-30Â°</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ğŸ–¼ï¸ Renderer íƒ­ -->
            <div class="tab-content" id="tab-render" style="display:none;">
                <div class="panel-section">
                    <h3>ğŸ“ ìŠ¤í”„ë¼ì´íŠ¸ ì„ íƒ</h3>
                    <div class="setting-row">
                        <label>ì´ë¯¸ì§€</label>
                        <input type="text" id="render-sprite-path" value="goblin.png" style="flex:1; padding:5px; background:#1a1a28; border:1px solid #333; color:#fff; border-radius:4px;">
                    </div>
                    <div class="setting-row" style="margin-top:8px;">
                        <label>í”„ë¦¬ì…‹</label>
                        <select id="render-preset" style="flex:1; padding:5px; background:#1a1a28; border:1px solid #333; color:#fff; border-radius:4px;">
                            <option value="player">ğŸ® Player</option>
                            <option value="enemy" selected>ğŸ‘¹ Enemy</option>
                            <option value="boss">ğŸ’€ Boss</option>
                            <option value="npc">ğŸ§™ NPC</option>
                            <option value="object">ğŸ“¦ Object</option>
                        </select>
                    </div>
                    <button class="play-btn" style="margin-top:10px; width:100%;" onclick="loadRendererPreview()">ğŸ”„ í”„ë¦¬ë·° ë¡œë“œ</button>
                </div>
                
                <div class="panel-section">
                    <h3>âœï¸ ì•„ì›ƒë¼ì¸</h3>
                    <div class="setting-row">
                        <label>í™œì„±í™”</label>
                        <input type="checkbox" id="render-outline-enabled" checked style="width:18px; height:18px;">
                    </div>
                    <div class="setting-row">
                        <label>ìƒ‰ìƒ</label>
                        <input type="color" id="render-outline-color" value="#000000" style="width:50px; height:28px; border:none; border-radius:4px;">
                    </div>
                    <div class="setting-row">
                        <label>ë‘ê»˜</label>
                        <input type="range" id="render-outline-thickness" min="1" max="6" value="2" style="flex:1;">
                        <span class="value" id="render-outline-val">2</span>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3>ğŸŒ‘ ê·¸ë¦¼ì</h3>
                    <div class="setting-row">
                        <label>í™œì„±í™”</label>
                        <input type="checkbox" id="render-shadow-enabled" checked style="width:18px; height:18px;">
                    </div>
                    <div class="setting-row">
                        <label>ë¶ˆíˆ¬ëª…ë„</label>
                        <input type="range" id="render-shadow-alpha" min="0" max="100" value="40" style="flex:1;">
                        <span class="value" id="render-shadow-val">0.4</span>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3>ğŸ¬ ìƒíƒœ í…ŒìŠ¤íŠ¸</h3>
                    <div style="display:flex; flex-wrap:wrap; gap:5px;">
                        <button class="play-btn" style="flex:1; min-width:80px;" onclick="testRendererState('idle')">ğŸ˜Š Idle</button>
                        <button class="play-btn" style="flex:1; min-width:80px; background:#ef4444;" onclick="testRendererHit()">ğŸ’¥ Hit</button>
                        <button class="play-btn" style="flex:1; min-width:80px; background:#6366f1;" onclick="testRendererState('stunned')">ğŸ˜µ Stun</button>
                        <button class="play-btn" style="flex:1; min-width:80px; background:#f59e0b;" onclick="testRendererState('buffed')">âœ¨ Buff</button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3>ğŸ–¼ï¸ í”„ë¦¬ë·°</h3>
                    <div id="renderer-preview-container" style="background:#1a1a28; border-radius:8px; min-height:200px; display:flex; align-items:center; justify-content:center; color:#666;">
                        í”„ë¦¬ë·° ë¡œë“œ ëŒ€ê¸°ì¤‘...
                    </div>
                </div>
            </div>
            
            <!-- ì„¤ì • ì„¹ì…˜ (ê³µí†µ) -->
            <div class="panel-section">
                <h3>âš™ï¸ Settings</h3>
                <div class="speed-control">
                    <label>Speed</label>
                    <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1" onchange="updateSpeed()">
                    <span class="value" id="speedValue">1.0x</span>
                </div>
            </div>
        </div>
        
        <div class="stage-container">
            <div id="pixiContainer"></div>
            <canvas id="vfxCanvas"></canvas>
            <div class="stage-overlay" id="statsOverlay">
                <div class="stat-row"><span>Player:</span><span class="value" id="playerPos">0, 0</span></div>
                <div class="stat-row"><span>Enemy:</span><span class="value" id="enemyPos">0, 0</span></div>
                <div class="stat-row"><span>FPS:</span><span class="value" id="fpsValue">60</span></div>
            </div>
        </div>
        
        <div class="log-panel">
            <div class="log-header">
                <span>ğŸ“œ Log</span>
                <button onclick="clearLog()">Clear</button>
            </div>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>
    
    <!-- ğŸ¬ íƒ€ì„ë¼ì¸ íŒ¨ë„ (ê°œì„ ) -->
    <div class="timeline-panel" id="timelinePanel">
        <div class="timeline-header">
            <h3>ğŸ¬ Timeline <span class="anim-name" id="tlAnimName"></span></h3>
            <div class="timeline-controls">
                <button class="timeline-btn play" id="tlPlayBtn" onclick="Timeline.togglePlay()">â–¶</button>
                <button class="timeline-btn" onclick="Timeline.stop()">â¹</button>
                <button class="timeline-btn" onclick="Timeline.zoom(-0.1)">âˆ’</button>
                <button class="timeline-btn" onclick="Timeline.zoom(0.1)">+</button>
                <span class="timeline-time" id="timelineTime">0.000s / 0.000s</span>
                <button class="timeline-btn" id="tlLoopBtn" onclick="Timeline.toggleLoop()">ğŸ”</button>
                <button class="timeline-btn" id="tlToggleBtn" onclick="Timeline.toggle()">â–¼</button>
            </div>
        </div>
        <div class="timeline-body">
            <div class="timeline-tracks">
                <div class="timeline-track-header player"><span class="icon">ğŸ®</span>Player</div>
                <div class="timeline-track-header enemy"><span class="icon">ğŸ‘¹</span>Enemy</div>
                <div class="timeline-track-header vfx"><span class="icon">âœ¨</span>VFX</div>
                <div class="timeline-track-header camera"><span class="icon">ğŸ“·</span>Camera</div>
                <div class="timeline-track-header effects"><span class="icon">âš¡</span>Effects</div>
                <div class="timeline-track-header damage"><span class="icon">ğŸ’¥</span>Damage</div>
            </div>
            <div class="timeline-content" id="timelineContent">
                <div class="timeline-ruler" id="timelineRuler"></div>
                <div class="timeline-lanes" id="timelineLanes">
                    <div class="timeline-lane" id="playerLane"></div>
                    <div class="timeline-lane" id="enemyLane"></div>
                    <div class="timeline-lane" id="vfxLane"></div>
                    <div class="timeline-lane" id="cameraLane"></div>
                    <div class="timeline-lane" id="effectsLane"></div>
                    <div class="timeline-lane" id="damageLane"></div>
                </div>
                <div class="timeline-playhead" id="timelinePlayhead"></div>
            </div>
        </div>
    </div>
    <div class="timeline-tooltip" id="tlTooltip" style="display:none;"></div>

    <script>
        // ==================== ì „ì—­ ë³€ìˆ˜ ====================
        let app, vfxCanvas, vfxCtx;
        let playerContainer, playerSprite, enemyContainer, enemySprite;
        let stageContainer; // ì‰ì´í¬ìš©
        
        // ë‹¤ì¤‘ ì  ì§€ì›
        let enemies = [];  // [{container, sprite, baseX}]
        let currentTargetIndex = 0;
        
        const config = {
            speed: 1,
            playerBaseX: 0,
            enemyBaseX: 0,
            baseY: 0,
            // ìºë¦­í„° í¬ê¸° ì •ë³´
            charHeight: 120,    // ê¸°ë³¸ ìºë¦­í„° ë†’ì´
            charWidth: 60,      // ê¸°ë³¸ ìºë¦­í„° ë„ˆë¹„
            vfxScale: 1.0,      // VFX ìŠ¤ì¼€ì¼
            enemyCount: 3       // ì  ìˆ˜
        };
        
        let animCache = new Map();
        let vfxCache = new Map();
        
        // ë™ì ìœ¼ë¡œ index.jsonì—ì„œ ë¡œë“œ
        let ANIM_FILES = [];
        let VFX_FILES = [];
        
        // VFX íŒŒí‹°í´ í’€
        const particles = [];
        let animationFrame = null;
        
        // ==================== ì´ˆê¸°í™” ====================
        document.addEventListener('DOMContentLoaded', async () => {
            log('info', 'ğŸ® DDOO Action Studio ì´ˆê¸°í™”...');
            await initPixi();
            await loadAllVFX();
            await loadAllAnimations();
            renderAnimList();
            startVFXLoop();
            startUpdateLoop();
            log('success', 'âœ… ì¤€ë¹„ ì™„ë£Œ! ì• ë‹ˆë©”ì´ì…˜ì„ ì„ íƒí•˜ì„¸ìš”.');
        });
        
        async function initPixi() {
            const container = document.getElementById('pixiContainer');
            const width = container.clientWidth || 900;
            const height = container.clientHeight || 600;
            
            // ğŸ¥ 3D ë°°ê²½ ì´ˆê¸°í™” (Background3D)
            if (typeof Background3D !== 'undefined') {
                log('info', 'ğŸ¥ 3D ë°°ê²½ ì´ˆê¸°í™” ì¤‘...');
                // ì»¨í…Œì´ë„ˆ ì„¤ì • (pixiContainer ì•ˆì— ë Œë”ë§)
                Background3D.createContainer = function() {
                    const old = document.getElementById('bg3d');
                    if (old) old.remove();
                    
                    this.container = document.createElement('div');
                    this.container.id = 'bg3d';
                    this.container.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        z-index: 0;
                        pointer-events: none;
                    `;
                    container.appendChild(this.container);
                };
                
                await Background3D.init();
                Background3D.setAutoZoom(false);  // ìë™ ì¤Œ ë¹„í™œì„±í™”
                log('success', 'âœ… 3D ë°°ê²½ ì´ˆê¸°í™” ì™„ë£Œ');
            }
            
            app = new PIXI.Application({
                width, height,
                backgroundAlpha: 0,  // íˆ¬ëª… ë°°ê²½ (3D ë°°ê²½ ë³´ì´ê²Œ)
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            container.appendChild(app.view);
            app.view.style.position = 'relative';
            app.view.style.zIndex = '1';
            
            vfxCanvas = document.getElementById('vfxCanvas');
            vfxCanvas.width = width;
            vfxCanvas.height = height;
            vfxCtx = vfxCanvas.getContext('2d');
            
            // ìŠ¤í…Œì´ì§€ ì»¨í…Œì´ë„ˆ (ì‰ì´í¬ìš©)
            stageContainer = new PIXI.Container();
            stageContainer.sortableChildren = true;  // zIndex ì •ë ¬ í™œì„±í™”!
            app.stage.addChild(stageContainer);
            
            // 3D ë°°ê²½ì´ ì—†ìœ¼ë©´ í´ë°± ë°°ê²½ ê·¸ë¦¬ê¸°
            if (typeof Background3D === 'undefined' || !Background3D.isInitialized) {
                drawBackground(width, height);
            }
            
            // DDOOAction ì—”ì§„ ì´ˆê¸°í™” (ì»¨í…Œì´ë„ˆ/ì• ë‹ˆë©”ì´ì…˜/VFX ë¡œë“œ) - ìºë¦­í„° ìƒì„± ì „ì—!
            if (typeof DDOOAction !== 'undefined') {
                await DDOOAction.init(app, stageContainer);
                log('success', 'âœ… DDOOAction ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
                
                // DDOOActionì˜ animCacheë¥¼ test_animationì—ì„œë„ ì‚¬ìš©
                animCache = DDOOAction.animCache;
                vfxCache = DDOOAction.vfxCache;
            }
            
            await createCharacters(width, height);
            
            log('info', `Stage: ${width}x${height}`);
            
            // ğŸ”„ ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ëŸ¬
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => handleResize(), 100);
            });
        }
        
        // ğŸ”„ ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
        function handleResize() {
            const container = document.getElementById('pixiContainer');
            if (!container || !app) return;
            
            const width = container.clientWidth || 900;
            const height = container.clientHeight || 600;
            
            // PixiJS ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ
            app.renderer.resize(width, height);
            
            // VFX ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ
            const vfxCanvas = document.getElementById('vfxCanvas');
            if (vfxCanvas) {
                vfxCanvas.width = width;
                vfxCanvas.height = height;
            }
            
            // ìºë¦­í„° ìœ„ì¹˜ ì¬ê³„ì‚°
            const groundY = height * 0.78;  // ë°”ë‹¥ ìœ„ì¹˜
            config.baseY = groundY;
            config.playerBaseX = width * 0.12;  // í”Œë ˆì´ì–´ ì™¼ìª½ ë
            const enemyStartX = width * 0.50;   // ì  ì‹œì‘ ìœ„ì¹˜ (ì¤‘ì•™)
            const enemySpacing = width * 0.18;  // ì  ê°„ê²© (ë„“ê²Œ)
            
            // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            if (playerContainer) {
                playerContainer.x = config.playerBaseX;
                playerContainer.y = groundY;
                
                const playerChar = DDOOAction?.characters?.get('player');
                if (playerChar) {
                    playerChar.baseX = config.playerBaseX;
                    playerChar.baseY = groundY;
                    if (playerChar.shadow) {
                        playerChar.shadow.x = config.playerBaseX;
                        playerChar.shadow.y = groundY + 5;
                    }
                }
            }
            
            // ì  ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            enemies.forEach((e, i) => {
                const newX = enemyStartX + (i * enemySpacing);
                const newY = groundY - (i * 15);
                
                e.container.x = newX;
                e.container.y = newY;
                e.baseX = newX;
                e.baseY = newY;
                
                const charData = DDOOAction?.characters?.get(e.id);
                if (charData) {
                    charData.baseX = newX;
                    charData.baseY = newY;
                    if (charData.shadow) {
                        charData.shadow.x = newX;
                        charData.shadow.y = newY + 5;
                    }
                }
            });
            
            // ë°°ê²½ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
            if (stageContainer && stageContainer.children.length > 0) {
                const bg = stageContainer.children[0];
                if (bg instanceof PIXI.Graphics) {
                    bg.clear();
                    drawBackgroundGraphics(bg, width, height);
                }
            }
            
            // 3D ë°°ê²½ ë¦¬ì‚¬ì´ì¦ˆ
            if (typeof Background3D !== 'undefined' && Background3D.handleResize) {
                Background3D.handleResize();
            }
            
            // íƒ€ê²Ÿ ì„ íƒ UI ì—…ë°ì´íŠ¸
            const currentEnemy = enemies[currentTargetIndex];
            if (currentEnemy) {
                config.enemyBaseX = currentEnemy.baseX;
                enemyContainer = currentEnemy.container;
            }
            
            log('info', `ğŸ“ ë¦¬ì‚¬ì´ì¦ˆ: ${width}x${height}`);
        }
        
        function drawBackgroundGraphics(bg, width, height) {
            // ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼
            for (let i = 0; i < 10; i++) {
                const alpha = 0.03 + (i * 0.01);
                bg.beginFill(0x1a1a2e, alpha);
                bg.drawRect(0, height * (i / 10), width, height / 10);
                bg.endFill();
            }
            
            // ë°”ë‹¥ ë¼ì¸
            const groundY = height * 0.7;
            bg.lineStyle(2, 0x3a3a5a, 0.6);
            bg.moveTo(0, groundY);
            bg.lineTo(width, groundY);
            
            // ê·¸ë¦¬ë“œ
            bg.lineStyle(1, 0x2a2a3a, 0.2);
            for (let x = 0; x < width; x += 100) {
                bg.moveTo(x, 0);
                bg.lineTo(x, height);
            }
        }
        
        function drawBackground(width, height) {
            const bg = new PIXI.Graphics();
            
            // ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼
            for (let i = 0; i < 10; i++) {
                const alpha = 0.03 + (i * 0.01);
                bg.beginFill(0x1a1a2e, alpha);
                bg.drawRect(0, height * (i / 10), width, height / 10);
                bg.endFill();
            }
            
            // ë°”ë‹¥ ë¼ì¸
            const groundY = height * 0.7;
            bg.lineStyle(2, 0x3a3a5a, 0.6);
            bg.moveTo(0, groundY);
            bg.lineTo(width, groundY);
            
            // ê·¸ë¦¬ë“œ
            bg.lineStyle(1, 0x2a2a3a, 0.2);
            for (let x = 0; x < width; x += 100) {
                bg.moveTo(x, 0);
                bg.lineTo(x, height);
            }
            
            stageContainer.addChild(bg);
        }
        
        async function createCharacters(width, height) {
            const groundY = height * 0.78;  // ë°”ë‹¥ ìœ„ì¹˜
            config.baseY = groundY;
            config.playerBaseX = width * 0.12;  // í”Œë ˆì´ì–´ ì™¼ìª½ ë
            
            // ì  ìœ„ì¹˜ ê³„ì‚° (3ëª… ë°°ì¹˜) - ë„“ì€ ê°„ê²©
            const enemyStartX = width * 0.50;   // ì  ì‹œì‘ ìœ„ì¹˜ (ì¤‘ì•™)
            const enemySpacing = width * 0.18;  // ì  ê°„ê²© (ë„“ê²Œ)
            
            // ğŸ® DDOOAction ì—”ì§„ ì‚¬ìš©!
            const useDDOOEngine = typeof DDOOAction !== 'undefined';
            
            if (useDDOOEngine && DDOOAction.initialized) {
                log('info', 'ğŸ® DDOOAction ì—”ì§„ìœ¼ë¡œ ìºë¦­í„° ìƒì„±...');
                
                // ì•„ì›ƒë¼ì¸ ì„¤ì • ì¡°ì • (ë„ˆë¬´ ë‘ê»ì§€ ì•Šê²Œ)
                DDOOAction.config.character.outlineThickness = 1;
                DDOOAction.config.enableOutline = false;  // í…ŒìŠ¤íŠ¸ìš© ë¹„í™œì„±í™”
                
                // í”Œë ˆì´ì–´ í…ìŠ¤ì²˜ ë¡œë“œ
                let playerTex;
                try {
                    playerTex = await PIXI.Assets.load('hero.png');
                    log('success', `âœ… hero.png (${playerTex.width}x${playerTex.height})`);
                } catch (e) {
                    playerTex = createFallbackTexture(0x60a5fa, 'P');
                    log('warn', 'âš ï¸ hero.png fallback');
                }
                
                // DDOOActionìœ¼ë¡œ í”Œë ˆì´ì–´ ìƒì„± (ê·¸ë¦¼ì, ì•„ì›ƒë¼ì¸, ë¸Œë ˆì‹± í¬í•¨!)
                const playerData = DDOOAction.createCharacter('player', {
                    texture: playerTex,
                    x: config.playerBaseX,
                    y: groundY,
                    scale: 0.65,  // ìºë¦­í„° í¬ê¸° ì¤„ì„
                    team: 'player',
                    enableEffects: true
                });
                playerContainer = playerData.container;
                playerSprite = playerData.sprite;
                playerContainer.zIndex = 100;  // ê¸°ë³¸ zIndex (ì ë³´ë‹¤ ë†’ê²Œ)
                
                // ì  í…ìŠ¤ì²˜ ë¡œë“œ
                let enemyTex;
                try {
                    enemyTex = await PIXI.Assets.load('goblinarcher.png');
                    log('success', `âœ… goblinarcher.png (${enemyTex.width}x${enemyTex.height})`);
                } catch (e) {
                    enemyTex = createFallbackTexture(0xef4444, 'E');
                    log('warn', 'âš ï¸ goblinarcher.png fallback');
                }
                
                // ğŸ¯ ë‹¤ì¤‘ ì  ìƒì„± (3ëª…!)
                enemies = [];
                for (let i = 0; i < config.enemyCount; i++) {
                    const enemyX = enemyStartX + (i * enemySpacing);
                    const enemyId = i === 0 ? 'enemy' : `enemy${i + 1}`;
                    
                    // ì›ê·¼ê°: ë’¤ë¡œ ê°ˆìˆ˜ë¡ ì‘ê³  ë†’ì´ ì˜¬ë¼ê°
                    const depthScale = 0.55 - (i * 0.05);  // ìºë¦­í„° í¬ê¸° ì¤„ì„
                    const depthY = groundY - (i * 12);  // ë’¤ë¡œ ê°ˆìˆ˜ë¡ ì•½ê°„ ìœ„ë¡œ
                    const depthZIndex = 50 - (i * 10);  // ì•ì— ìˆì„ìˆ˜ë¡ ë†’ì€ zIndex
                    
                    const enemyData = DDOOAction.createCharacter(enemyId, {
                        texture: enemyTex,
                        x: enemyX,
                        y: depthY,
                        scale: depthScale,
                        team: 'enemy',
                        enableEffects: true
                    });
                    
                    enemyData.container.zIndex = depthZIndex;  // ë’¤ì— ìˆëŠ” ì ì€ ë‚®ì€ zIndex
                    
                    enemies.push({
                        id: enemyId,
                        container: enemyData.container,
                        sprite: enemyData.sprite,
                        baseX: enemyX,
                        baseY: depthY,
                        scale: depthScale,
                        zIndex: depthZIndex
                    });
                    
                    log('info', `  â†’ ${enemyId} at x=${enemyX.toFixed(0)}, scale=${depthScale.toFixed(2)}, z=${depthZIndex}`);
                }
                
                // ì²« ë²ˆì§¸ ì ì„ ê¸°ë³¸ íƒ€ê²Ÿìœ¼ë¡œ
                enemyContainer = enemies[0].container;
                enemySprite = enemies[0].sprite;
                config.enemyBaseX = enemies[0].baseX;
                
                log('success', `âœ… DDOOAction ìºë¦­í„° ìƒì„± ì™„ë£Œ (í”Œë ˆì´ì–´ 1ëª…, ì  ${config.enemyCount}ëª…)`);
                
            } else {
                // í´ë°±: ê¸°ì¡´ ë°©ì‹
                log('warn', 'âš ï¸ DDOOAction ì—†ìŒ, ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©');
                
                // í”Œë ˆì´ì–´
                playerContainer = new PIXI.Container();
                playerContainer.x = config.playerBaseX;
                playerContainer.y = groundY;
                
                try {
                    const tex = await PIXI.Assets.load('hero.png');
                    playerSprite = new PIXI.Sprite(tex);
                    playerSprite.anchor.set(0.5, 1);
                    playerSprite.scale.set(0.65);  // ìºë¦­í„° í¬ê¸° ì¤„ì„
                } catch (e) {
                    playerSprite = createFallback(0x60a5fa, 'P');
                }
                playerContainer.addChild(playerSprite);
                stageContainer.addChild(playerContainer);
                
                // ë‹¤ì¤‘ ì  (í´ë°±)
                enemies = [];
                const enemyTex = await PIXI.Assets.load('goblinarcher.png').catch(() => null);
                
                for (let i = 0; i < config.enemyCount; i++) {
                    const enemyX = enemyStartX + (i * enemySpacing);
                    const depthScale = 0.55 - (i * 0.05);  // ìºë¦­í„° í¬ê¸° ì¤„ì„
                    const depthY = groundY - (i * 12);
                    
                    const container = new PIXI.Container();
                    container.x = enemyX;
                    container.y = depthY;
                    
                    let sprite;
                    if (enemyTex) {
                        sprite = new PIXI.Sprite(enemyTex);
                        sprite.anchor.set(0.5, 1);
                        sprite.scale.set(depthScale);
                    } else {
                        sprite = createFallback(0xef4444, `E${i+1}`);
                    }
                    container.addChild(sprite);
                    stageContainer.addChild(container);
                    
                    enemies.push({
                        id: `enemy${i === 0 ? '' : i + 1}`,
                        container,
                        sprite,
                        baseX: enemyX,
                        baseY: depthY,
                        scale: depthScale
                    });
                }
                
                enemyContainer = enemies[0].container;
                enemySprite = enemies[0].sprite;
                config.enemyBaseX = enemies[0].baseX;
                
                initAfterimageSystem();
                startBreathing();
            }
            
            // ìºë¦­í„° í¬ê¸° ì €ì¥
            updateCharacterInfo();
            
            // íƒ€ê²Ÿ ì„ íƒ UI ì¶”ê°€
            addTargetSelector();
        }
        
        // í´ë°± í…ìŠ¤ì²˜ ìƒì„±
        function createFallbackTexture(color, letter) {
            const g = new PIXI.Graphics();
            g.beginFill(color);
            g.drawRoundedRect(0, 0, 70, 120, 10);
            g.endFill();
            return app.renderer.generateTexture(g);
        }
        
        function updateCharacterInfo() {
            // í”Œë ˆì´ì–´ ë°”ìš´ë“œ
            const pBounds = playerSprite.getBounds();
            config.playerHeight = pBounds.height;
            config.playerWidth = pBounds.width;
            
            // ì  ë°”ìš´ë“œ
            const eBounds = enemySprite.getBounds();
            config.enemyHeight = eBounds.height;
            config.enemyWidth = eBounds.width;
            
            log('info', `Player: ${config.playerWidth.toFixed(0)}x${config.playerHeight.toFixed(0)}`);
            log('info', `Enemies: ${enemies.length}ëª…`);
        }
        
        // ğŸ¯ íƒ€ê²Ÿ ì„ íƒ UI
        function addTargetSelector() {
            const overlay = document.getElementById('statsOverlay');
            
            const targetRow = document.createElement('div');
            targetRow.className = 'stat-row';
            targetRow.innerHTML = `
                <span>Target:</span>
                <select id="targetSelect" style="background:#252535;color:#60a5fa;border:1px solid #3a3a5a;padding:2px 5px;border-radius:3px;font-size:0.7rem;">
                    ${enemies.map((e, i) => `<option value="${i}">${e.id} (x:${e.baseX.toFixed(0)})</option>`).join('')}
                </select>
            `;
            overlay.appendChild(targetRow);
            
            document.getElementById('targetSelect').addEventListener('change', (e) => {
                selectTarget(parseInt(e.target.value));
            });
        }
        
        // íƒ€ê²Ÿ ë³€ê²½
        function selectTarget(index) {
            if (index < 0 || index >= enemies.length) return;
            currentTargetIndex = index;
            
            const target = enemies[index];
            enemyContainer = target.container;
            enemySprite = target.sprite;
            config.enemyBaseX = target.baseX;
            
            // DDOOActionì˜ íƒ€ê²Ÿë„ ë³€ê²½
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized) {
                // ğŸ¯ enemy ìºë¦­í„°ë¥¼ ìƒˆ íƒ€ê²Ÿìœ¼ë¡œ ì§ì ‘ êµì²´!
                const newCharData = {
                    container: target.container,
                    sprite: target.sprite,
                    baseX: target.baseX,
                    baseY: target.baseY || config.baseY,
                    baseScale: target.scale || 1,  // ğŸ”¥ baseScale ì¶”ê°€!
                    team: 'enemy',
                    state: 'idle'
                };
                DDOOAction.characters.set('enemy', newCharData);
                
                log('info', `ğŸ¯ DDOOAction íƒ€ê²Ÿ ì—…ë°ì´íŠ¸: enemy â†’ ${target.id}`);
            }
            
            log('info', `ğŸ¯ íƒ€ê²Ÿ ë³€ê²½: ${target.id} (x:${target.baseX.toFixed(0)})`);
        }
        
        function createFallback(color, letter) {
            const c = new PIXI.Container();
            const body = new PIXI.Graphics();
            body.beginFill(color);
            body.drawRoundedRect(-35, -120, 70, 120, 10);
            body.endFill();
            const text = new PIXI.Text(letter, { fontFamily: 'Arial', fontSize: 40, fill: 0xffffff, fontWeight: 'bold' });
            text.anchor.set(0.5);
            text.y = -60;
            c.addChild(body);
            c.addChild(text);
            return c;
        }
        
        function startBreathing() {
            // DDOOActionì´ ìˆ¨ì‰¬ê¸°ë¥¼ ì´ë¯¸ ì²˜ë¦¬í•˜ë©´ ìŠ¤í‚µ!
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized && DDOOAction.config.enableBreathing) {
                log('info', 'ğŸ« DDOOAction ìˆ¨ì‰¬ê¸° ì‚¬ìš© ì¤‘ (ë¡œì»¬ ìŠ¤í‚µ)');
                return;
            }
            
            // í´ë°±: DDOOAction ì—†ì„ ë•Œ ë¡œì»¬ ìˆ¨ì‰¬ê¸°
            // í”Œë ˆì´ì–´ ìˆ¨ì‰¬ê¸° (ê¸°ë³¸ ìŠ¤ì¼€ì¼ ê¸°ì¤€)
            const playerBaseScale = playerSprite.scale.x || 0.65;
            gsap.to(playerSprite.scale, { 
                y: playerBaseScale * 1.03,  // ê¸°ë³¸ ìŠ¤ì¼€ì¼ì˜ 103%
                duration: 1.8, 
                repeat: -1, 
                yoyo: true, 
                ease: 'sine.inOut' 
            });
            
            // ì  ìˆ¨ì‰¬ê¸° (ê° ì ì˜ ê¸°ë³¸ ìŠ¤ì¼€ì¼ ê¸°ì¤€)
            enemies.forEach((e, i) => {
                if (e.sprite) {
                    const enemyBaseScale = e.scale || (0.55 - (i * 0.05));
                    gsap.to(e.sprite.scale, { 
                        y: enemyBaseScale * 1.03,  // ê¸°ë³¸ ìŠ¤ì¼€ì¼ì˜ 103%
                        duration: 1.5 + (i * 0.2),  // ì•½ê°„ì”© ë‹¤ë¥¸ ì†ë„
                        repeat: -1, 
                        yoyo: true, 
                        ease: 'sine.inOut' 
                    });
                }
            });
        }
        
        // ==================== ì”ìƒ ì‹œìŠ¤í…œ ====================
        const afterimages = [];
        let afterimageContainer = null;
        
        function initAfterimageSystem() {
            afterimageContainer = new PIXI.Container();
            stageContainer.addChildAt(afterimageContainer, 0); // ìºë¦­í„° ë’¤ì— ë°°ì¹˜
        }
        
        function createAfterimage(sourceSprite, sourceContainer, alpha = 0.6, tint = 0x8888ff) {
            if (!afterimageContainer || !sourceSprite.texture) return;
            
            const ghost = new PIXI.Sprite(sourceSprite.texture);
            ghost.anchor.set(sourceSprite.anchor.x, sourceSprite.anchor.y);
            ghost.x = sourceContainer.x;
            ghost.y = sourceContainer.y;
            ghost.scale.set(sourceSprite.scale.x, sourceSprite.scale.y);
            ghost.rotation = sourceSprite.rotation;
            ghost.alpha = alpha;
            ghost.tint = tint;
            
            afterimageContainer.addChild(ghost);
            
            // ì”ìƒ ë°ì´í„° ì €ì¥
            afterimages.push({
                sprite: ghost,
                life: 150,
                maxLife: 150,
                fadeSpeed: 1
            });
        }
        
        function updateAfterimages(delta) {
            for (let i = afterimages.length - 1; i >= 0; i--) {
                const ai = afterimages[i];
                ai.life -= delta * 16;
                
                const progress = ai.life / ai.maxLife;
                ai.sprite.alpha = progress * 0.6;
                ai.sprite.scale.x *= 0.995;
                ai.sprite.scale.y *= 0.995;
                
                if (ai.life <= 0) {
                    afterimageContainer.removeChild(ai.sprite);
                    ai.sprite.destroy();
                    afterimages.splice(i, 1);
                }
            }
        }
        
        function clearAfterimages() {
            afterimages.forEach(ai => {
                afterimageContainer.removeChild(ai.sprite);
                ai.sprite.destroy();
            });
            afterimages.length = 0;
        }
        
        // ==================== JSON ë¡œë“œ (ë²ˆë“¤ ìš°ì„ , fetch í´ë°±) ====================
        async function loadAllVFX() {
            log('info', 'ğŸ’¥ Loading VFX...');
            
            // ğŸ ë²ˆë“¤ì´ ìˆìœ¼ë©´ ì¦‰ì‹œ ì‚¬ìš©!
            if (window.VFX_BUNDLE) {
                log('success', 'ğŸ VFX ë²ˆë“¤ ì‚¬ìš© (fetch ìŠ¤í‚µ!)');
                Object.entries(window.VFX_BUNDLE).forEach(([id, data]) => {
                    vfxCache.set(id, data);
                });
                VFX_FILES = Object.keys(window.VFX_BUNDLE);
                log('success', `âœ… VFX ë¡œë“œ ì™„ë£Œ: ${vfxCache.size}ê°œ (ë²ˆë“¤)`);
                return;
            }
            
            // í´ë°±: fetchë¡œ ë¡œë“œ
            try {
                const indexRes = await fetch('vfx/index.json');
                if (indexRes.ok) {
                    VFX_FILES = await indexRes.json();
                    log('info', `ğŸ“‹ vfx/index.json: ${VFX_FILES.length}ê°œ ë°œê²¬`);
                }
            } catch (e) {
                log('warn', 'âš ï¸ vfx/index.json ì—†ìŒ, ê¸°ë³¸ ëª©ë¡ ì‚¬ìš©');
                VFX_FILES = ['slash', 'hit', 'spark', 'dash', 'stab', 'critical', 'block'];
            }
            
            for (const id of VFX_FILES) {
                try {
                    const res = await fetch(`vfx/${id}.json`);
                    if (res.ok) {
                        vfxCache.set(id, await res.json());
                    }
                } catch (e) {
                    log('warn', `âš ï¸ vfx/${id} failed`);
                }
            }
            log('success', `âœ… VFX ë¡œë“œ ì™„ë£Œ: ${vfxCache.size}ê°œ`);
        }
        
        async function loadAllAnimations() {
            log('info', 'ğŸ“ Loading animations...');
            
            // ğŸ ë²ˆë“¤ì´ ìˆìœ¼ë©´ ì¦‰ì‹œ ì‚¬ìš©!
            if (window.ANIM_BUNDLE) {
                log('success', 'ğŸ Anim ë²ˆë“¤ ì‚¬ìš© (fetch ìŠ¤í‚µ!)');
                Object.entries(window.ANIM_BUNDLE).forEach(([id, data]) => {
                    animCache.set(id, data);
                });
                ANIM_FILES = Object.keys(window.ANIM_BUNDLE);
                log('success', `âœ… ì• ë‹ˆë©”ì´ì…˜ ë¡œë“œ ì™„ë£Œ: ${animCache.size}ê°œ (ë²ˆë“¤)`);
                return;
            }
            
            // í´ë°±: fetchë¡œ ë¡œë“œ
            try {
                const indexRes = await fetch('anim/index.json');
                if (indexRes.ok) {
                    ANIM_FILES = await indexRes.json();
                    log('info', `ğŸ“‹ anim/index.json: ${ANIM_FILES.length}ê°œ ë°œê²¬`);
                }
            } catch (e) {
                log('warn', 'âš ï¸ anim/index.json ì—†ìŒ, ê¸°ë³¸ ëª©ë¡ ì‚¬ìš©');
                ANIM_FILES = ['player.attack', 'player.hit', 'enemy.attack', 'enemy.hit'];
            }
            
            for (const id of ANIM_FILES) {
                try {
                    const res = await fetch(`anim/${id}.json`);
                    if (res.ok) {
                        animCache.set(id, await res.json());
                    }
                } catch (e) {
                    log('warn', `âš ï¸ anim/${id} failed`);
                }
            }
            log('success', `âœ… ì• ë‹ˆë©”ì´ì…˜ ë¡œë“œ ì™„ë£Œ: ${animCache.size}ê°œ`);
        }
        
        function renderAnimList() {
            const container = document.getElementById('animList');
            container.innerHTML = '';
            
            // ğŸ”¥ ì •ë ¬: card > player > enemy > ê¸°íƒ€
            const sortOrder = { card: 0, player: 1, enemy: 2 };
            const sorted = [...animCache.entries()].sort((a, b) => {
                const typeA = a[0].split('.')[0];
                const typeB = b[0].split('.')[0];
                const orderA = sortOrder[typeA] ?? 99;
                const orderB = sortOrder[typeB] ?? 99;
                if (orderA !== orderB) return orderA - orderB;
                return a[0].localeCompare(b[0]);  // ê°™ì€ íƒ€ì…ì´ë©´ ì•ŒíŒŒë²³ìˆœ
            });
            
            sorted.forEach(([id, data]) => {
                const type = id.split('.')[0];
                const name = id.split('.')[1];
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = id;
                item.innerHTML = `<span class="type ${type}">${type}</span><span class="name">${name}</span>`;
                item.onclick = () => playAnimation(id);
                container.appendChild(item);
            });
        }
        
        // ==================== íƒ­ ì „í™˜ ====================
        function switchTab(tabName) {
            // íƒ­ ë²„íŠ¼ í™œì„±í™”
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            
            // íƒ­ ì»¨í…ì¸  í‘œì‹œ
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = content.id === `tab-${tabName}` ? 'block' : 'none';
            });
            
            // VFX/Draw ë¦¬ìŠ¤íŠ¸ ë Œë”ë§ (ìµœì´ˆ 1íšŒ)
            if (tabName === 'vfx' && !document.getElementById('vfxList').children.length) {
                renderVFXList();
            }
            if (tabName === 'draw' && !document.getElementById('drawList').children.length) {
                renderDrawList();
            }
            
            // Renderer íƒ­ ì´ˆê¸°í™” (ìµœì´ˆ 1íšŒ)
            if (tabName === 'render' && !rendererStudioInitialized) {
                initRendererStudio();
            }
        }
        
        // ==================== DDOORenderer ìŠ¤íŠœë””ì˜¤ ====================
        let rendererStudioInitialized = false;
        
        async function initRendererStudio() {
            if (rendererStudioInitialized) return;
            
            const container = document.getElementById('renderer-preview-container');
            if (!container || typeof DDOORenderer === 'undefined') {
                container.innerHTML = '<span style="color:#f66;">DDOORendererë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</span>';
                return;
            }
            
            try {
                container.innerHTML = '';
                await DDOORenderer.initStudio(container, 280, 300);
                rendererStudioInitialized = true;
                
                // ì´ë²¤íŠ¸ ë°”ì¸ë”©
                bindRendererEvents();
                
                // ê¸°ë³¸ ìŠ¤í”„ë¼ì´íŠ¸ ë¡œë“œ
                loadRendererPreview();
                
                log('info', 'ğŸ–¼ï¸ DDOORenderer ìŠ¤íŠœë””ì˜¤ ì´ˆê¸°í™” ì™„ë£Œ');
            } catch (e) {
                console.error('DDOORenderer ìŠ¤íŠœë””ì˜¤ ì´ˆê¸°í™” ì‹¤íŒ¨:', e);
                container.innerHTML = '<span style="color:#f66;">ì´ˆê¸°í™” ì‹¤íŒ¨</span>';
            }
        }
        
        function bindRendererEvents() {
            // ì•„ì›ƒë¼ì¸ ë‘ê»˜
            const thicknessSlider = document.getElementById('render-outline-thickness');
            if (thicknessSlider) {
                thicknessSlider.oninput = () => {
                    document.getElementById('render-outline-val').textContent = thicknessSlider.value;
                };
            }
            
            // ê·¸ë¦¼ì ë¶ˆíˆ¬ëª…ë„
            const alphaSlider = document.getElementById('render-shadow-alpha');
            if (alphaSlider) {
                alphaSlider.oninput = () => {
                    document.getElementById('render-shadow-val').textContent = (alphaSlider.value / 100).toFixed(2);
                };
            }
        }
        
        async function loadRendererPreview() {
            if (!rendererStudioInitialized || typeof DDOORenderer === 'undefined') {
                log('error', 'ìŠ¤íŠœë””ì˜¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ');
                return;
            }
            
            const path = document.getElementById('render-sprite-path')?.value || 'goblin.png';
            const preset = document.getElementById('render-preset')?.value || 'enemy';
            
            const overrides = {
                outline: {
                    enabled: document.getElementById('render-outline-enabled')?.checked ?? true,
                    color: parseInt((document.getElementById('render-outline-color')?.value || '#000000').replace('#', ''), 16),
                    thickness: parseInt(document.getElementById('render-outline-thickness')?.value || '2')
                },
                shadow: {
                    enabled: document.getElementById('render-shadow-enabled')?.checked ?? true,
                    alpha: parseInt(document.getElementById('render-shadow-alpha')?.value || '40') / 100
                }
            };
            
            try {
                await DDOORenderer.previewSprite(path, preset, overrides);
                log('info', `ğŸ–¼ï¸ í”„ë¦¬ë·° ë¡œë“œ: ${path} (${preset})`);
            } catch (e) {
                log('error', `í”„ë¦¬ë·° ë¡œë“œ ì‹¤íŒ¨: ${e.message}`);
            }
        }
        
        function testRendererState(state) {
            if (typeof DDOORenderer !== 'undefined') {
                DDOORenderer.testState(state);
                log('info', `ğŸ¬ ìƒíƒœ í…ŒìŠ¤íŠ¸: ${state}`);
            }
        }
        
        function testRendererHit() {
            if (typeof DDOORenderer !== 'undefined') {
                DDOORenderer.testHit();
                log('info', 'ğŸ’¥ íˆíŠ¸ í…ŒìŠ¤íŠ¸');
            }
        }
        
        // ==================== VFX ë¦¬ìŠ¤íŠ¸ ë Œë”ë§ ====================
        function renderVFXList() {
            const container = document.getElementById('vfxList');
            container.innerHTML = '';
            
            vfxCache.forEach((data, id) => {
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = id;
                item.innerHTML = `<span class="type vfx">VFX</span><span class="name">${data.name || id}</span>`;
                item.onclick = () => playVFX(id);
                container.appendChild(item);
            });
            
            log('info', `ğŸ“‹ VFX ë¦¬ìŠ¤íŠ¸ ë Œë”ë§: ${vfxCache.size}ê°œ`);
        }
        
        // ==================== VFX ì¬ìƒ ====================
        function playVFX(id) {
            const vfxData = vfxCache.get(id);
            if (!vfxData) {
                log('error', `âŒ VFX not found: ${id}`);
                return;
            }
            
            // ì„ íƒ í‘œì‹œ
            document.querySelectorAll('#vfxList .anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`#vfxList .anim-item[data-id="${id}"]`)?.classList.add('playing');
            
            // í™”ë©´ ì¤‘ì•™ì—ì„œ VFX ì¬ìƒ
            const centerX = app.screen.width / 2;
            const centerY = config.baseY - 60;
            
            log('vfx', `âœ¨ VFX: ${id}`);
            
            if (typeof DDOOAction !== 'undefined' && DDOOAction.triggerVFX) {
                DDOOAction.triggerVFX(id, centerX, centerY, 1, 1.5);
            } else {
                triggerVFX(vfxData, centerX, centerY, 1, 1.5);
            }
        }
        
        // ==================== Draw ë¦¬ìŠ¤íŠ¸ ë Œë”ë§ ====================
        function renderDrawList() {
            const container = document.getElementById('drawList');
            container.innerHTML = '';
            
            // DDOODrawì—ì„œ í•¨ìˆ˜ ëª©ë¡ ì¶”ì¶œ
            const drawFunctions = [
                // === 3D ì´í™íŠ¸ (WebGL) ===
                { id: 'sparks3d', name: 'âœ¨ 3D Sparks', type: '3d', is3d: true },
                // === 2D ì´í™íŠ¸ (Canvas) ===
                { id: 'slash', name: 'âš”ï¸ Slash (ê²€ê¸°)', type: 'slash' },
                { id: 'sword_arc', name: 'ğŸŒ™ Sword Arc (ê²€ í˜¸)', type: 'sword_arc' },
                { id: 'trail_dot', name: 'ğŸ”µ Trail Dot', type: 'trail_dot' },
                { id: 'energy_orb', name: 'ğŸ”® Energy Orb', type: 'energy_orb' },
                { id: 'electric', name: 'âš¡ Electric', type: 'electric' },
                { id: 'wave', name: 'ğŸŒŠ Wave', type: 'wave' },
                { id: 'star', name: 'â­ Star', type: 'star' },
                { id: 'comet', name: 'â˜„ï¸ Comet', type: 'comet' },
                { id: 'voxel', name: 'ğŸ† Voxel', type: 'voxel' },
                { id: 'smoke', name: 'ğŸ’¨ Smoke', type: 'smoke' },
                { id: 'symbol', name: 'âœ¨ Symbol', type: 'symbol' },
                { id: 'arrow', name: 'â¤ Arrow', type: 'arrow' },
                { id: 'spark', name: 'âœ¦ Spark', type: 'spark' },
                { id: 'flash', name: 'ğŸ’« Flash', type: 'flash' },
                { id: 'ring', name: 'â­• Ring', type: 'ring' },
                { id: 'line', name: 'â” Line', type: 'line' },
                { id: 'debris', name: 'ğŸ§± Debris', type: 'debris' }
            ];
            
            drawFunctions.forEach(df => {
                const item = document.createElement('div');
                item.className = 'anim-item';
                item.dataset.id = df.id;
                const typeClass = df.is3d ? 'effect-3d' : 'draw';
                const typeLabel = df.is3d ? '3D' : 'DRAW';
                item.innerHTML = `<span class="type ${typeClass}">${typeLabel}</span><span class="name">${df.name}</span>`;
                item.onclick = () => df.is3d ? play3DEffect(df.id) : playDrawParticle(df.type);
                container.appendChild(item);
            });
            
            // ì„¤ì • ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            document.getElementById('drawSize').addEventListener('input', (e) => {
                document.getElementById('drawSizeValue').textContent = e.target.value;
            });
            document.getElementById('drawAngle').addEventListener('input', (e) => {
                document.getElementById('drawAngleValue').textContent = e.target.value + 'Â°';
            });
            
            log('info', `ğŸ“‹ Draw ë¦¬ìŠ¤íŠ¸ ë Œë”ë§: ${drawFunctions.length}ê°œ`);
            
            // 3D VFX ì´ˆê¸°í™”
            if (typeof DDOOVfx3D !== 'undefined' && !DDOOVfx3D.initialized) {
                DDOOVfx3D.init(document.getElementById('pixiContainer'));
                log('success', 'ğŸ® 3D VFX ì‹œìŠ¤í…œ ì´ˆê¸°í™”');
            }
        }
        
        // ==================== 3D ì´í™íŠ¸ ì¬ìƒ ====================
        function play3DEffect(effectId) {
            // ì„ íƒ í‘œì‹œ
            document.querySelectorAll('#drawList .anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`#drawList .anim-item[data-id="${effectId}"]`)?.classList.add('playing');
            
            // ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸°
            const color = document.getElementById('drawColor').value;
            const glow = document.getElementById('drawGlow').value;
            const size = parseInt(document.getElementById('drawSize').value);
            const angle = parseInt(document.getElementById('drawAngle').value);
            
            // í™”ë©´ ì¤‘ì•™ (pixiContainer ê¸°ì¤€)
            const container = document.getElementById('pixiContainer');
            const centerX = container.clientWidth / 2;
            const centerY = config.baseY - 60;
            
            // ìƒ‰ìƒì„ hexë¡œ ë³€í™˜
            const colorHex = parseInt(color.replace('#', ''), 16);
            const glowHex = parseInt(glow.replace('#', ''), 16);
            
            log('vfx', `ğŸ® 3D Effect: ${effectId} (size:${size})`);
            
            if (typeof DDOOVfx3D === 'undefined') {
                log('error', 'âŒ DDOOVfx3Dê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                return;
            }
            
            // 3D VFX ì´ˆê¸°í™” ì²´í¬
            if (!DDOOVfx3D.initialized) {
                DDOOVfx3D.init(container);
            }
            
            switch (effectId) {
                case 'slash3d':
                    DDOOVfx3D.slash3D(centerX, centerY, {
                        color: colorHex,
                        glowColor: glowHex,
                        length: size,
                        width: size / 4,
                        arc: 140,
                        startAngle: angle,
                        duration: 0.5,
                        direction: 1
                    });
                    break;
                    
                case 'shockwave3d':
                    DDOOVfx3D.shockwave3D(centerX, centerY, {
                        color: colorHex,
                        maxRadius: size,
                        thickness: size / 15,
                        duration: 0.5
                    });
                    break;
                    
                case 'sparks3d':
                    DDOOVfx3D.sparks3D(centerX, centerY, {
                        color: colorHex,
                        count: Math.floor(size / 5),
                        speed: size * 1.5,
                        size: 4,
                        duration: 0.7
                    });
                    break;
            }
        }
        
        // ==================== Draw íŒŒí‹°í´ ì¬ìƒ ====================
        function playDrawParticle(type) {
            // ì„ íƒ í‘œì‹œ
            document.querySelectorAll('#drawList .anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`#drawList .anim-item[data-id="${type}"]`)?.classList.add('playing');
            
            // ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸°
            const color = document.getElementById('drawColor').value;
            const glow = document.getElementById('drawGlow').value;
            const size = parseInt(document.getElementById('drawSize').value);
            const angle = parseInt(document.getElementById('drawAngle').value);
            
            // í™”ë©´ ì¤‘ì•™
            const centerX = app.screen.width / 2;
            const centerY = config.baseY - 60;
            
            log('vfx', `ğŸ¨ Draw: ${type} (size:${size}, angle:${angle}Â°)`);
            
            // íŒŒí‹°í´ ìƒì„±
            const particleConfig = {
                x: centerX,
                y: centerY,
                color: color,
                glow: glow,
                life: 500
            };
            
            switch (type) {
                case 'slash':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'slash',
                            ...particleConfig,
                            angle: angle,
                            length: size,
                            width: size / 8
                        });
                    }
                    break;
                case 'sword_arc':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'sword_arc',
                            ...particleConfig,
                            dir: 1,
                            radius: size / 2,
                            thickness: size / 10,
                            startAngle: -80,
                            endAngle: 80
                        });
                    }
                    break;
                case 'trail_dot':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'trail_dot',
                            ...particleConfig,
                            size: size / 10
                        });
                    }
                    break;
                case 'energy_orb':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'energy_orb',
                            ...particleConfig,
                            startSize: size / 5
                        });
                    }
                    break;
                case 'electric':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'electric',
                            ...particleConfig,
                            angle: angle,
                            length: size,
                            segments: 8,
                            width: 3
                        });
                    }
                    break;
                case 'wave':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'wave',
                            ...particleConfig,
                            startSize: size / 4,
                            maxSize: size,
                            thickness: size / 15,
                            startAngle: -90,
                            endAngle: 90
                        });
                    }
                    break;
                case 'star':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'star',
                            ...particleConfig,
                            startSize: size / 5,
                            points: 4,
                            rotation: angle * Math.PI / 180
                        });
                    }
                    break;
                case 'comet':
                    if (typeof DDOOAction !== 'undefined') {
                        const rad = angle * Math.PI / 180;
                        DDOOAction.spawnParticle({
                            type: 'comet',
                            ...particleConfig,
                            startSize: size / 10,
                            tailLength: size / 2,
                            vx: Math.cos(rad) * 5,
                            vy: Math.sin(rad) * 5
                        });
                    }
                    break;
                case 'voxel':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'voxel',
                            ...particleConfig,
                            size: size / 8,
                            rotation: angle * Math.PI / 180,
                            rotationSpeed: 0.1
                        });
                    }
                    break;
                case 'smoke':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'smoke',
                            ...particleConfig,
                            startSize: size / 4,
                            rotation: 0,
                            rotationSpeed: 0.02
                        });
                    }
                    break;
                case 'symbol':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'symbol',
                            ...particleConfig,
                            size: size / 3,
                            symbol: 'â­'
                        });
                    }
                    break;
                case 'arrow':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'arrow',
                            ...particleConfig,
                            dir: 1,
                            startLength: size,
                            startWidth: size / 2,
                            tipAngle: 35,
                            innerColor: glow + '80'
                        });
                    }
                    break;
                case 'spark':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'spark',
                            ...particleConfig,
                            startSize: size / 10
                        });
                    }
                    break;
                case 'flash':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'flash',
                            ...particleConfig,
                            startSize: size / 2
                        });
                    }
                    break;
                case 'ring':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'ring',
                            ...particleConfig,
                            startSize: size / 5,
                            maxSize: size
                        });
                    }
                    break;
                case 'line':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'line',
                            ...particleConfig,
                            angle: angle,
                            startLength: size,
                            startWidth: 3
                        });
                    }
                    break;
                case 'debris':
                    if (typeof DDOOAction !== 'undefined') {
                        DDOOAction.spawnParticle({
                            type: 'debris',
                            ...particleConfig,
                            startSize: size / 10
                        });
                    }
                    break;
            }
        }
        
        // ==================== ë©”ì¸ ì¬ìƒ ====================
        async function playAnimation(id, skipReset = false) {
            const data = animCache.get(id);
            if (!data) { log('error', `âŒ Not found: ${id}`); return; }
            
            document.querySelectorAll('.anim-item').forEach(el => el.classList.remove('playing'));
            document.querySelector(`.anim-item[data-id="${id}"]`)?.classList.add('playing');
            
            log('anim', `â–¶ï¸ ${id}`);
            
            if (!skipReset) {
                resetCharacters();
                await delay(100);
            }
            
            const target = data.target || (id.startsWith('enemy') ? 'enemy' : 'player');
            const container = target === 'player' ? playerContainer : enemyContainer;
            const sprite = target === 'player' ? playerSprite : enemySprite;
            const baseX = target === 'player' ? config.playerBaseX : config.enemyBaseX;
            const dir = target === 'player' ? 1 : -1;
            
            // ğŸ® DDOOAction ì—”ì§„ ì‚¬ìš©!
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized) {
                // ğŸ¯ í˜„ì¬ ì„ íƒëœ íƒ€ê²Ÿ ì •ë³´
                const currentTarget = enemies[currentTargetIndex];
                const targetCont = currentTarget?.container || enemyContainer;
                const targetSpr = currentTarget?.sprite || enemySprite;
                
                
                await DDOOAction.play(id, {
                    container,
                    sprite,
                    baseX,
                    baseY: config.baseY,
                    dir,
                    isRelative: false,
                    // ğŸ¯ íƒ€ê²Ÿ ì •ë³´ ì „ë‹¬!
                    targetContainer: targetCont,
                    targetSprite: targetSpr,
                    targetBaseX: currentTarget?.baseX || config.enemyBaseX,
                    targetBaseY: currentTarget?.baseY || config.baseY,
                    onComplete: () => log('success', `âœ… ${id} ì™„ë£Œ`),
                    onHit: (kf) => log('info', `ğŸ’¥ íˆíŠ¸! ${kf.vfx || ''}`),
                    getHitPoint: () => {
                        // ğŸ¯ í˜„ì¬ ì„ íƒëœ íƒ€ê²Ÿì˜ íƒ€ê²©ì !
                        return { 
                            x: targetCont.x, 
                            y: targetCont.y - (config.enemyHeight || 100) / 2 
                        };
                    }
                });
                return;
            }
            
            // í´ë°±: ê¸°ì¡´ ë°©ì‹
            if (data.type === 'sequence' && data.steps) {
                await playSequence(data);
            } else if (data.keyframes) {
                await playKeyframes(data, container, sprite, baseX, dir, false);
            }
        }
        
        // ==================== ì‹œí€€ìŠ¤ ì¬ìƒ ====================
        async function playSequence(data) {
            log('anim', `ğŸ¬ Sequence: ${data.id}`);
            
            for (const step of data.steps) {
                if (step.delay && !step.anim) {
                    await delay(step.delay / config.speed);
                    continue;
                }
                
                if (step.anim) {
                    const animData = animCache.get(step.anim);
                    if (!animData) { log('warn', `âš ï¸ ${step.anim} not found`); continue; }
                    
                    log('info', `  â†’ ${step.anim}`);
                    
                    const target = animData.target || (step.anim.startsWith('enemy') ? 'enemy' : 'player');
                    const container = target === 'player' ? playerContainer : enemyContainer;
                    const sprite = target === 'player' ? playerSprite : enemySprite;
                    const dir = target === 'player' ? 1 : -1;
                    
                    if (step.delay) await delay(step.delay / config.speed);
                    
                    if (animData.keyframes) {
                        const promise = playKeyframes(animData, container, sprite, container.x, dir, true);
                        if (step.wait) await promise;
                    }
                }
            }
            
            log('success', `âœ… Sequence done: ${data.id}`);
        }
        
        // ==================== í‚¤í”„ë ˆì„ ì¬ìƒ (FGO ìŠ¤íƒ€ì¼) ====================
        async function playKeyframes(data, container, sprite, startX, dir, isRelative) {
            return new Promise((resolve) => {
                const baseScale = 1.0;
                const returnToBase = data.returnToBase;
                const targetBaseX = dir === 1 ? config.playerBaseX : config.enemyBaseX;
                
                gsap.killTweensOf(container);
                gsap.killTweensOf(sprite);
                gsap.killTweensOf(sprite.scale);
                
                const tl = gsap.timeline({
                    timeScale: config.speed,
                    onComplete: () => {
                        if (returnToBase) {
                            gsap.to(container, {
                                x: targetBaseX,
                                duration: 0.25,
                                ease: 'power2.inOut',
                                onComplete: resolve
                            });
                        } else {
                            resolve();
                        }
                    }
                });
                
                data.keyframes.forEach((kf, idx) => {
                    if (idx === 0) return;
                    
                    const dur = (kf.duration || 100) / 1000;
                    const ease = kf.ease || 'power2.out';
                    const pos = idx === 1 ? 0 : '>';
                    
                    // ì»¨í…Œì´ë„ˆ ì´ë™
                    if (kf.x !== undefined) {
                        const targetX = isRelative ? startX + (kf.x * dir) : config.playerBaseX + (kf.x * dir);
                        tl.to(container, { x: targetX, duration: dur, ease }, pos);
                    }
                    
                    if (kf.y !== undefined) {
                        tl.to(container, { y: config.baseY + kf.y, duration: dur, ease }, '<');
                    }
                    
                    // ìŠ¤ì¼€ì¼ (ìŠ¤ì¿¼ì‹œ/ìŠ¤íŠ¸ë ˆì¹˜)
                    if (kf.scaleX !== undefined || kf.scaleY !== undefined) {
                        const scaleX = (kf.scaleX ?? 1) * baseScale;
                        const scaleY = (kf.scaleY ?? 1) * baseScale;
                        tl.to(sprite.scale, { x: scaleX, y: scaleY, duration: dur, ease }, '<');
                    }
                    
                    // íšŒì „
                    if (kf.rotation !== undefined) {
                        tl.to(sprite, { rotation: kf.rotation * dir, duration: dur, ease }, '<');
                    }
                    
                    // ì•ŒíŒŒ
                    if (kf.alpha !== undefined) {
                        tl.to(sprite, { alpha: kf.alpha, duration: dur, ease }, '<');
                    }
                    
                    // ========== VFX íŠ¸ë¦¬ê±° ==========
                    if (kf.vfx) {
                        tl.call(() => triggerVFX(kf.vfx, container, dir), null, '<');
                    }
                    
                    // ========== íˆíŠ¸ìŠ¤í†± ==========
                    if (kf.hitstop) {
                        tl.call(() => {
                            tl.pause();
                            setTimeout(() => tl.resume(), kf.hitstop / config.speed);
                        }, null, '>');
                    }
                    
                    // ========== ìŠ¤í¬ë¦°ì‰ì´í¬ ==========
                    if (kf.shake) {
                        tl.call(() => screenShake(kf.shake), null, '<');
                    }
                    
                    // ========== ë³µì…€ ì‰í„° (íƒ€ê²©ê°!) ==========
                    if (kf.shatter && typeof DDOOAction !== 'undefined') {
                        tl.call(() => {
                            const shatterOpts = typeof kf.shatter === 'object' ? kf.shatter : {};
                            const target = shatterOpts.target || 'enemy';
                            DDOOAction.shatterTarget(target, {
                                gridSize: shatterOpts.grid || 10,
                                force: shatterOpts.force || 12,
                                gravity: shatterOpts.gravity || 0.35,
                                life: shatterOpts.life || 500,
                                color: shatterOpts.color || null,
                                dirBias: data.target === 'player' ? 1 : -1,
                                hideSprite: shatterOpts.hide !== false,
                                hideTime: shatterOpts.hideTime || 150
                            });
                        }, null, '<');
                    }
                    
                    // ========== ì”ìƒ ìƒì„± ==========
                    if (kf.afterimage) {
                        tl.call(() => {
                            const tint = data.target === 'player' ? 0x60a5fa : 0xef4444;
                            createAfterimage(sprite, container, 0.7, tint);
                        }, null, '<');
                    }
                });
            });
        }
        
        function resetCharacters() {
            gsap.killTweensOf(playerContainer);
            gsap.killTweensOf(playerSprite);
            gsap.killTweensOf(playerSprite.scale);
            gsap.killTweensOf(stageContainer);
            
            // ëª¨ë“  ì  íŠ¸ìœˆ ì •ë¦¬
            enemies.forEach(e => {
                gsap.killTweensOf(e.container);
                gsap.killTweensOf(e.sprite);
                gsap.killTweensOf(e.sprite.scale);
            });
            
            playerContainer.x = config.playerBaseX;
            playerContainer.y = config.baseY;
            playerSprite.rotation = 0;
            playerSprite.scale.set(0.65);  // ìºë¦­í„° í¬ê¸° ì¤„ì„
            playerSprite.alpha = 1;
            
            // ëª¨ë“  ì  ë¦¬ì…‹
            enemies.forEach((e, i) => {
                e.container.x = e.baseX;
                e.container.y = e.baseY || config.baseY;
                e.sprite.rotation = 0;
                e.sprite.scale.set(e.scale || (0.55 - (i * 0.05)));
                e.sprite.alpha = 1;
            });
            
            stageContainer.x = 0;
            stageContainer.y = 0;
            stageContainer.scale.set(1, 1);
            stageContainer.alpha = 1;
            
            // âš ï¸ DDOOAction ì¹´ë©”ë¼/ì´í™íŠ¸ ë¦¬ì…‹!
            if (typeof DDOOAction !== 'undefined' && DDOOAction.initialized) {
                DDOOAction.resetCameraImmediate();
                DDOOAction.resetColorGradeImmediate();
                DDOOAction.resetSlowmoImmediate();
                
                const playerChar = DDOOAction.characters.get('player');
                if (playerChar) {
                    playerChar.sprite.alpha = 1;
                    playerChar.sprite.rotation = 0;
                    const pScale = playerChar.baseScale || 0.65;
                    playerChar.sprite.scale.set(pScale, pScale);
                    playerChar.container.x = config.playerBaseX;
                    playerChar.container.y = config.baseY;
                    
                    // ğŸ« ìˆ¨ì‰¬ê¸° ë‹¤ì‹œ ì‹œì‘!
                    if (DDOOAction.config.enableBreathing) {
                        DDOOAction.startBreathing(playerChar);
                    }
                }
                
                // ëª¨ë“  ì  ë¦¬ì…‹
                enemies.forEach((e, i) => {
                    const charData = DDOOAction.characters.get(e.id);
                    if (charData) {
                        charData.sprite.alpha = 1;
                        charData.sprite.rotation = 0;
                        const scale = e.scale || (0.55 - (i * 0.05));
                        charData.sprite.scale.set(scale, scale);
                        charData.container.x = e.baseX;
                        charData.container.y = e.baseY || config.baseY;
                        
                        // ğŸ« ìˆ¨ì‰¬ê¸° ë‹¤ì‹œ ì‹œì‘!
                        if (DDOOAction.config.enableBreathing) {
                            DDOOAction.startBreathing(charData);
                        }
                    }
                });
            }
            
            // ğŸ¥ 3D ë°°ê²½ ì¹´ë©”ë¼ë„ ë¦¬ì…‹
            if (typeof Background3D !== 'undefined' && Background3D.isInitialized && Background3D.autoZoom) {
                const baseZ = Background3D.cameraDefaults?.posZ || 15;
                Background3D.autoZoom.targetZ = baseZ;
                Background3D.autoZoom.currentZ = baseZ;
            }
            
            clearVFX();
            clearAfterimages();
            startBreathing();
        }
        
        // ==================== VFX ì‹œìŠ¤í…œ (JSON ê¸°ë°˜) ====================
        
        // ìºë¦­í„°ì˜ ì‹¤ì œ ë°”ìš´ë“œ ê³„ì‚°
        function getCharacterBounds(container) {
            const sprite = container.children[0];
            if (!sprite) return { width: 60, height: 120, centerY: -60 };
            
            const bounds = sprite.getBounds();
            const scale = sprite.scale.x;
            
            return {
                width: bounds.width,
                height: bounds.height,
                centerY: -bounds.height / 2,  // ì¤‘ì‹¬ì  Y
                scale: scale
            };
        }
        
        // íƒ€ê²©ì  ê³„ì‚° (ì  ìœ„ì¹˜ ê¸°ì¤€)
        function getHitPoint(attackerContainer, targetContainer) {
            const targetBounds = getCharacterBounds(targetContainer);
            
            // íƒ€ê²©ì ì€ íƒ€ê²Ÿ ìºë¦­í„°ì˜ ì¤‘ì‹¬
            return {
                x: targetContainer.x,
                y: targetContainer.y + targetBounds.centerY,
                scale: targetBounds.scale
            };
        }
        
        function triggerVFX(vfxId, container, dir) {
            const vfxData = vfxCache.get(vfxId);
            if (!vfxData) {
                log('warn', `âš ï¸ VFX not found: ${vfxId}`);
                return;
            }
            
            // íƒ€ê²©ì  ê³„ì‚°: ê³µê²©ìê°€ í”Œë ˆì´ì–´ë©´ ì ì—ê²Œ, ì ì´ë©´ í”Œë ˆì´ì–´ì—ê²Œ
            const isPlayer = container === playerContainer;
            const targetContainer = isPlayer ? enemyContainer : playerContainer;
            const hitPoint = getHitPoint(container, targetContainer);
            
            // VFX íƒ€ì…ì— ë”°ë¥¸ ìœ„ì¹˜ ê²°ì •
            let vfxX, vfxY, vfxScale;
            
            if (vfxId === 'dash' || vfxId === 'trail') {
                // ëŒ€ì‹œ/íŠ¸ë ˆì¼ì€ ìì‹  ìœ„ì¹˜
                const bounds = getCharacterBounds(container);
                vfxX = container.x;
                vfxY = container.y + bounds.centerY;
                vfxScale = bounds.scale;
            } else {
                // ê³µê²© ì´í™íŠ¸ëŠ” íƒ€ê²©ì  (íƒ€ê²Ÿ ìœ„ì¹˜)
                vfxX = hitPoint.x;
                vfxY = hitPoint.y;
                vfxScale = hitPoint.scale;
            }
            
            log('vfx', `ğŸ’¥ ${vfxId} at (${vfxX.toFixed(0)}, ${vfxY.toFixed(0)}) scale:${vfxScale.toFixed(2)}`);
            
            // VFXì— ì •ì˜ëœ shake ì‹¤í–‰
            if (vfxData.shake) {
                screenShake(vfxData.shake);
            }
            
            // ê° íŒŒí‹°í´ ì •ì˜ ì²˜ë¦¬
            for (const pDef of vfxData.particles) {
                spawnParticlesFromDef(pDef, vfxX, vfxY, dir, container, vfxScale);
            }
        }
        
        // JSON ì •ì˜ì—ì„œ íŒŒí‹°í´ ìƒì„± (ìŠ¤ì¼€ì¼ ì ìš©)
        function spawnParticlesFromDef(def, x, y, dir, container, scale = 1.0) {
            const count = def.count || 1;
            const delayBetween = def.delay || 0;
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    switch (def.type) {
                        case 'slash':
                        case 'thrust':
                            spawnSlashParticle(def, x, y, dir, i, scale);
                            break;
                        case 'arrow':
                        case 'wedge':
                            spawnArrowParticle(def, x, y, dir, i, scale);
                            break;
                        case 'spark':
                            spawnSparkParticle(def, x, y, scale);
                            break;
                        case 'flash':
                            spawnFlashParticle(def, x, y, scale);
                            break;
                        case 'ring':
                            spawnRingParticle(def, x, y, scale);
                            break;
                        case 'line':
                            spawnLineParticle(def, x, y, i, scale);
                            break;
                        case 'debris':
                            spawnDebrisParticle(def, x, y, scale);
                            break;
                        case 'trail':
                            spawnTrailParticle(def, container, i, scale);
                            break;
                        case 'projectile':
                            spawnProjectileParticle(def, x, y, dir, scale, container);
                            break;
                        case 'sword_arc':
                            spawnSwordArcParticle(def, x, y, dir, i, scale);
                            break;
                    }
                }, i * delayBetween);
            }
        }
        
        // ê²€ ê¶¤ì  ì•„í¬ ìŠ¤í°
        function spawnSwordArcParticle(def, x, y, dir, index, scale) {
            const radius = getRandValue(def.radius) * scale;
            const thickness = (def.thickness || 15) * scale;
            const colors = Array.isArray(def.colors) ? def.colors : [def.color || '#ffffff'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const glowColors = Array.isArray(def.glowColors) ? def.glowColors : [def.glow || '#60a5fa'];
            const glow = glowColors[Math.floor(Math.random() * glowColors.length)];
            
            spawnParticle({
                type: 'sword_arc',
                x: x,
                y: y,
                dir: dir,
                radius: radius,
                thickness: thickness,
                startAngle: def.startAngle || -60,
                endAngle: def.endAngle || 60,
                color: color,
                glow: glow,
                trail: def.trail !== false,
                life: getRandValue(def.life) || 180
            });
        }
        
        function spawnSlashParticle(def, x, y, dir, index, scale) {
            const angles = Array.isArray(def.angle) ? def.angle : [def.angle || 0];
            const angle = angles[index % angles.length] || (Math.random() - 0.5) * 60;
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 8) * scale;
            
            spawnParticle({
                type: 'slash',
                x, y,
                angle: angle * dir,
                length: length,
                width: width,
                color: def.color || '#ffffff',
                glow: def.glow || '#60a5fa',
                life: def.life || 150
            });
        }
        
        // ">" ëª¨ì–‘ í™”ì‚´í‘œ ì´í™íŠ¸
        function spawnArrowParticle(def, x, y, dir, index, scale) {
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 60) * scale;
            const tipAngle = def.tipAngle || 35; // í™”ì‚´ì´‰ ê°ë„
            
            const p = {
                type: 'arrow',
                x, y,
                dir: dir,
                startLength: length,
                startWidth: width,
                tipAngle: tipAngle,
                color: def.color || '#ffffff',
                glow: def.glow || '#a78bfa',
                innerColor: def.innerColor || 'rgba(167, 139, 250, 0.5)',
                life: def.life || 120
            };
            spawnParticle(p);
        }
        
        function spawnSparkParticle(def, x, y, scale) {
            const spread = (def.spread || 50) * scale;
            const speed = getRandValue(def.speed) * scale;
            const size = getRandValue(def.size) * scale;
            const angle = Math.random() * Math.PI * 2;
            const colors = def.colors || [def.color || '#fbbf24'];
            
            spawnParticle({
                type: 'spark',
                x: x + (Math.random() - 0.5) * spread,
                y: y + (Math.random() - 0.5) * spread,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2,
                size: size,
                color: colors[Math.floor(Math.random() * colors.length)],
                life: getRandValue(def.life)
            });
        }
        
        function spawnFlashParticle(def, x, y, scale) {
            spawnParticle({
                type: 'flash',
                x, y,
                size: (def.size || 80) * scale,
                color: def.color || '#ffffff',
                life: def.life || 80
            });
        }
        
        function spawnRingParticle(def, x, y, scale) {
            spawnParticle({
                type: 'ring',
                x, y,
                size: (def.size || 20) * scale,
                maxSize: (def.maxSize || 100) * scale,
                color: def.color || '#ef4444',
                life: def.life || 200
            });
        }
        
        function spawnLineParticle(def, x, y, index, scale) {
            const angleStep = def.angleStep || 30;
            const angle = index * angleStep;
            const length = getRandValue(def.length) * scale;
            const width = (def.width || 3) * scale;
            
            spawnParticle({
                type: 'line',
                x, y,
                angle: angle,
                length: length,
                width: width,
                color: def.color || '#fbbf24',
                life: def.life || 150
            });
        }
        
        function spawnDebrisParticle(def, x, y, scale) {
            const speed = getRandValue(def.speed) * scale;
            const size = getRandValue(def.size) * scale;
            const angle = Math.random() * Math.PI * 2;
            const colors = def.colors || [def.color || '#ef4444'];
            
            spawnParticle({
                type: 'debris',
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 5,
                size: size,
                color: colors[Math.floor(Math.random() * colors.length)],
                gravity: def.gravity || 0.3,
                life: getRandValue(def.life)
            });
        }
        
        function spawnTrailParticle(def, container, index, scale) {
            const bounds = getCharacterBounds(container);
            const offsetX = (def.offsetX || -20) * index * scale;
            const size = (getRandValue(def.size) - index * 5) * scale;
            
            spawnParticle({
                type: 'trail',
                x: container.x + offsetX,
                y: container.y + bounds.centerY,
                size: Math.max(size, 10),
                color: def.color || 'rgba(96, 165, 250, 0.3)',
                life: def.life || 150
            });
        }
        
        function spawnProjectileParticle(def, startX, startY, dir, scale, container) {
            // ì‹œì‘ì  (í”Œë ˆì´ì–´) â†’ ëì  (ì )
            const targetContainer = container === playerContainer ? enemyContainer : playerContainer;
            const targetBounds = getCharacterBounds(targetContainer);
            const endX = targetContainer.x;
            const endY = targetContainer.y + targetBounds.centerY;
            
            spawnParticle({
                type: 'projectile',
                x: startX,
                y: startY,
                targetX: endX,
                targetY: endY,
                speed: (def.speed || 20) * scale,
                rotation: def.rotation || 0,
                size: (def.size || 15) * scale,
                shape: def.shape || 'circle',
                color: def.color || '#94a3b8',
                glow: def.glow || '#60a5fa',
                life: def.life || 300,
                dir: dir
            });
        }
        
        // ìœ í‹¸: ë°°ì—´ì´ë©´ ëœë¤ ë²”ìœ„, ì•„ë‹ˆë©´ ê·¸ëŒ€ë¡œ
        function getRandValue(val) {
            if (Array.isArray(val)) {
                return val[0] + Math.random() * (val[1] - val[0]);
            }
            return val || 0;
        }
        
        // íŒŒí‹°í´ ìŠ¤í°
        function spawnParticle(config) {
            particles.push({
                ...config,
                startLife: config.life,
                startSize: config.size || 10,
                startLength: config.length || 50,
                born: performance.now()
            });
        }
        
        // VFX ë Œë” ë£¨í”„
        function startVFXLoop() {
            let lastTime = performance.now();
            
            function render() {
                const now = performance.now();
                const delta = (now - lastTime) / 16.67; // 60fps ê¸°ì¤€
                lastTime = now;
                
                // ì”ìƒ ì—…ë°ì´íŠ¸
                updateAfterimages(delta);
                
                vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const age = now - p.born;
                    const progress = age / p.startLife;
                    
                    if (progress >= 1) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    const alpha = 1 - progress;
                    
                    vfxCtx.save();
                    
                    switch (p.type) {
                        case 'slash':
                            // DDOODrawì˜ í™”ë ¤í•œ ë²„ì „ ì‚¬ìš©!
                            if (typeof DDOODraw !== 'undefined' && DDOODraw.drawSlashParticle) {
                                DDOODraw.drawSlashParticle(vfxCtx, p, alpha, progress);
                            } else {
                                drawSlashParticle(p, alpha, progress);
                            }
                            break;
                        case 'arrow':
                            drawArrowParticle(p, alpha, progress);
                            break;
                        case 'spark':
                            p.x += p.vx || 0;
                            p.y += p.vy || 0;
                            if (p.gravity) p.vy += p.gravity;
                            drawSparkParticle(p, alpha);
                            break;
                        case 'flash':
                            drawFlashParticle(p, alpha, progress);
                            break;
                        case 'ring':
                            drawRingParticle(p, alpha, progress);
                            break;
                        case 'line':
                            drawLineParticle(p, alpha, progress);
                            break;
                        case 'debris':
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += p.gravity;
                            drawDebrisParticle(p, alpha);
                            break;
                        case 'trail':
                            drawTrailParticle(p, alpha);
                            break;
                        case 'projectile':
                            updateAndDrawProjectile(p, alpha, progress);
                            break;
                        case 'sword_arc':
                            // DDOODrawì˜ í™”ë ¤í•œ ë²„ì „ ì‚¬ìš©!
                            if (typeof DDOODraw !== 'undefined' && DDOODraw.drawSwordArcParticle) {
                                DDOODraw.drawSwordArcParticle(vfxCtx, p, alpha, progress);
                            } else {
                                drawSwordArcParticle(p, alpha, progress);
                            }
                            break;
                    }
                    
                    vfxCtx.restore();
                }
                
                animationFrame = requestAnimationFrame(render);
            }
            render();
        }
        
        // ê²€ ê¶¤ì  ì•„í¬ ë Œë”ë§
        function drawSwordArcParticle(p, alpha, progress) {
            if (!isFinite(p.x) || !isFinite(p.y)) return;
            
            const radius = p.radius || 60;
            const thickness = (p.thickness || 15) * (1 - progress * 0.4);
            const dir = p.dir || 1;
            const color = p.color || '#ffffff';
            const glow = p.glow || '#60a5fa';
            
            const startAngle = (p.startAngle || -60) * Math.PI / 180;
            const endAngle = (p.endAngle || 60) * Math.PI / 180;
            const currentEnd = startAngle + (endAngle - startAngle) * Math.min(1, progress * 3);
            const fadeStart = Math.max(startAngle, currentEnd - (endAngle - startAngle) * 0.7);
            
            vfxCtx.save();
            vfxCtx.translate(p.x, p.y);
            if (dir < 0) vfxCtx.scale(-1, 1);
            
            // ì™¸ë¶€ ê¸€ë¡œìš°
            vfxCtx.shadowColor = glow;
            vfxCtx.shadowBlur = 30 + thickness;
            
            vfxCtx.strokeStyle = glow;
            vfxCtx.lineWidth = thickness * 2.5;
            vfxCtx.lineCap = 'round';
            vfxCtx.globalAlpha = alpha * 0.3;
            
            vfxCtx.beginPath();
            vfxCtx.arc(0, 0, radius, fadeStart, currentEnd);
            vfxCtx.stroke();
            
            // ë©”ì¸ ì•„í¬
            const arcLength = (currentEnd - fadeStart) * radius;
            if (arcLength > 0) {
                const startX = Math.cos(fadeStart) * radius;
                const startY = Math.sin(fadeStart) * radius;
                const endX = Math.cos(currentEnd) * radius;
                const endY = Math.sin(currentEnd) * radius;
                
                const grad = vfxCtx.createLinearGradient(startX, startY, endX, endY);
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(0.2, color + 'aa');
                grad.addColorStop(0.5, color);
                grad.addColorStop(0.8, '#ffffff');
                grad.addColorStop(1, '#ffffff');
                
                vfxCtx.strokeStyle = grad;
                vfxCtx.lineWidth = thickness;
                vfxCtx.globalAlpha = alpha;
                
                vfxCtx.beginPath();
                vfxCtx.arc(0, 0, radius, fadeStart, currentEnd);
                vfxCtx.stroke();
                
                // ëì  í•˜ì´ë¼ì´íŠ¸
                if (progress < 0.5) {
                    const tipX = Math.cos(currentEnd) * radius;
                    const tipY = Math.sin(currentEnd) * radius;
                    
                    const tipGrad = vfxCtx.createRadialGradient(tipX, tipY, 0, tipX, tipY, thickness * 2);
                    tipGrad.addColorStop(0, '#ffffff');
                    tipGrad.addColorStop(0.5, color);
                    tipGrad.addColorStop(1, 'transparent');
                    
                    vfxCtx.fillStyle = tipGrad;
                    vfxCtx.globalAlpha = alpha * (1 - progress * 2);
                    vfxCtx.beginPath();
                    vfxCtx.arc(tipX, tipY, thickness * 2, 0, Math.PI * 2);
                    vfxCtx.fill();
                }
            }
            
            vfxCtx.restore();
        }
        
        function drawSlashParticle(p, alpha, progress) {
            const rad = p.angle * Math.PI / 180;
            const len = p.startLength * (1 - progress * 0.3);
            
            vfxCtx.translate(p.x, p.y);
            vfxCtx.rotate(rad);
            
            // ê¸€ë¡œìš°
            if (p.glow) {
                vfxCtx.shadowColor = p.glow;
                vfxCtx.shadowBlur = 20;
            }
            
            // ê·¸ë¼ë°ì´ì…˜ ìŠ¬ë˜ì‹œ
            const grad = vfxCtx.createLinearGradient(-len/2, 0, len/2, 0);
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(0.3, p.color);
            grad.addColorStop(0.7, p.color);
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.strokeStyle = grad;
            vfxCtx.lineWidth = p.width * alpha;
            vfxCtx.lineCap = 'round';
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(-len/2, 0);
            vfxCtx.lineTo(len/2, 0);
            vfxCtx.stroke();
        }
        
        // ">" í™”ì‚´í‘œ ëª¨ì–‘ ê·¸ë¦¬ê¸°
        function drawArrowParticle(p, alpha, progress) {
            const len = p.startLength * (1 - progress * 0.4);
            const width = p.startWidth * (1 - progress * 0.3);
            const tipRad = (p.tipAngle || 35) * Math.PI / 180;
            
            // í™”ì‚´í‘œ ë°©í–¥ (dir: 1 = ì˜¤ë¥¸ìª½, -1 = ì™¼ìª½)
            const dir = p.dir || 1;
            
            vfxCtx.translate(p.x, p.y);
            if (dir < 0) vfxCtx.scale(-1, 1);
            
            // ê¸€ë¡œìš°
            if (p.glow) {
                vfxCtx.shadowColor = p.glow;
                vfxCtx.shadowBlur = 25;
            }
            vfxCtx.globalAlpha = alpha;
            
            // ë‚´ë¶€ ì±„ìš°ê¸° (ë°˜íˆ¬ëª…)
            if (p.innerColor) {
                vfxCtx.fillStyle = p.innerColor;
                vfxCtx.beginPath();
                vfxCtx.moveTo(len, 0);                          // ë¾°ì¡±í•œ ë
                vfxCtx.lineTo(0, -width * Math.sin(tipRad));    // ìœ„ìª½ ë‚ ê°œ
                vfxCtx.lineTo(len * 0.3, 0);                    // ì•ˆìª½ êº¾ì„
                vfxCtx.lineTo(0, width * Math.sin(tipRad));     // ì•„ë˜ìª½ ë‚ ê°œ
                vfxCtx.closePath();
                vfxCtx.fill();
            }
            
            // ì™¸ê³½ì„  (ë°ì€ ìƒ‰)
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = 3 * alpha;
            vfxCtx.lineCap = 'round';
            vfxCtx.lineJoin = 'round';
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(0, -width * Math.sin(tipRad));  // ìœ„ìª½ ë‚ ê°œ
            vfxCtx.lineTo(len, 0);                         // ë¾°ì¡±í•œ ë
            vfxCtx.lineTo(0, width * Math.sin(tipRad));   // ì•„ë˜ìª½ ë‚ ê°œ
            vfxCtx.stroke();
            
            // ì¤‘ì•™ ê°•ì¡°ì„ 
            vfxCtx.strokeStyle = '#ffffff';
            vfxCtx.lineWidth = 2 * alpha;
            vfxCtx.beginPath();
            vfxCtx.moveTo(len * 0.2, 0);
            vfxCtx.lineTo(len * 0.9, 0);
            vfxCtx.stroke();
        }
        
        function drawSparkParticle(p, alpha) {
            vfxCtx.fillStyle = p.color;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 8;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawFlashParticle(p, alpha, progress) {
            const size = p.startSize * (1 + progress);
            const grad = vfxCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
            grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
            grad.addColorStop(0.5, `rgba(255,255,255,${alpha * 0.5})`);
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.fillStyle = grad;
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawRingParticle(p, alpha, progress) {
            const size = p.size + (p.maxSize - p.size) * progress;
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = 4 * alpha;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 15;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
            vfxCtx.stroke();
        }
        
        function drawLineParticle(p, alpha, progress) {
            const rad = p.angle * Math.PI / 180;
            const len = p.startLength * (1 - progress * 0.5);
            const startOffset = p.startLength * progress * 0.3;
            
            vfxCtx.strokeStyle = p.color;
            vfxCtx.lineWidth = p.width * alpha;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.lineCap = 'round';
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 8;
            
            const sx = p.x + Math.cos(rad) * startOffset;
            const sy = p.y + Math.sin(rad) * startOffset;
            const ex = p.x + Math.cos(rad) * (startOffset + len);
            const ey = p.y + Math.sin(rad) * (startOffset + len);
            
            vfxCtx.beginPath();
            vfxCtx.moveTo(sx, sy);
            vfxCtx.lineTo(ex, ey);
            vfxCtx.stroke();
        }
        
        function drawDebrisParticle(p, alpha) {
            vfxCtx.fillStyle = p.color;
            vfxCtx.globalAlpha = alpha;
            vfxCtx.shadowColor = p.color;
            vfxCtx.shadowBlur = 5;
            
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function drawTrailParticle(p, alpha) {
            // NaN/Infinity ì²´í¬
            if (!isFinite(p.x) || !isFinite(p.y) || !isFinite(p.size) || p.size <= 0) {
                return;
            }
            
            const grad = vfxCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
            grad.addColorStop(0, p.color.replace('0.3', String(0.3 * alpha)));
            grad.addColorStop(1, 'transparent');
            
            vfxCtx.fillStyle = grad;
            vfxCtx.beginPath();
            vfxCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            vfxCtx.fill();
        }
        
        function updateAndDrawProjectile(p, alpha, progress) {
            // íˆ¬ì‚¬ì²´ ì´ë™ (ì‹œì‘ì  â†’ íƒ€ê²Ÿ)
            const dx = p.targetX - p.x;
            const dy = p.targetY - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > p.speed) {
                p.x += (dx / dist) * p.speed;
                p.y += (dy / dist) * p.speed;
            }
            
            // íšŒì „ ì—…ë°ì´íŠ¸
            if (p.rotation) {
                p.currentRotation = (p.currentRotation || 0) + (p.rotation * Math.PI / 180) * 0.016;
            }
            
            vfxCtx.save();
            vfxCtx.translate(p.x, p.y);
            vfxCtx.rotate(p.currentRotation || 0);
            
            // ê¸€ë¡œìš°
            vfxCtx.shadowColor = p.glow;
            vfxCtx.shadowBlur = 12;
            vfxCtx.globalAlpha = alpha;
            
            // ë‹¨ê²€ ê·¸ë¦¬ê¸°
            if (p.shape === 'dagger') {
                // ë‹¨ê²€ ë¸”ë ˆì´ë“œ
                vfxCtx.fillStyle = p.color;
                vfxCtx.beginPath();
                vfxCtx.moveTo(p.size, 0);           // ë
                vfxCtx.lineTo(0, -p.size * 0.3);    // ìœ„
                vfxCtx.lineTo(-p.size * 0.5, 0);    // ì†ì¡ì´
                vfxCtx.lineTo(0, p.size * 0.3);     // ì•„ë˜
                vfxCtx.closePath();
                vfxCtx.fill();
                
                // í•˜ì´ë¼ì´íŠ¸
                vfxCtx.fillStyle = '#ffffff';
                vfxCtx.globalAlpha = alpha * 0.6;
                vfxCtx.beginPath();
                vfxCtx.moveTo(p.size * 0.8, 0);
                vfxCtx.lineTo(0, -p.size * 0.15);
                vfxCtx.lineTo(-p.size * 0.2, 0);
                vfxCtx.closePath();
                vfxCtx.fill();
            } else {
                // ê¸°ë³¸ ì›í˜•
                vfxCtx.fillStyle = p.color;
                vfxCtx.beginPath();
                vfxCtx.arc(0, 0, p.size, 0, Math.PI * 2);
                vfxCtx.fill();
            }
            
            vfxCtx.restore();
            
            // ì”ìƒ íŠ¸ë ˆì¼ ìƒì„± (dist > 0 ì¼ ë•Œë§Œ)
            if (dist > 0.1 && Math.random() > 0.6) {
                spawnParticle({
                    type: 'trail',
                    x: p.x - (dx / dist) * 10,
                    y: p.y - (dy / dist) * 10,
                    size: p.size * 0.5,
                    color: 'rgba(148, 163, 184, 0.2)',
                    life: 80
                });
            }
        }
        
        
        // ìŠ¤í¬ë¦°ì‰ì´í¬
        function screenShake(intensity) {
            const duration = 150;
            const startTime = performance.now();
            
            function shake() {
                const elapsed = performance.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    stageContainer.x = 0;
                    stageContainer.y = 0;
                    return;
                }
                
                const decay = 1 - progress;
                const offsetX = (Math.random() - 0.5) * intensity * decay;
                const offsetY = (Math.random() - 0.5) * intensity * decay;
                
                stageContainer.x = offsetX;
                stageContainer.y = offsetY;
                
                requestAnimationFrame(shake);
            }
            shake();
        }
        
        function clearVFX() {
            particles.length = 0;
            vfxCtx.clearRect(0, 0, vfxCanvas.width, vfxCanvas.height);
        }
        
        // ==================== ìœ í‹¸ ====================
        function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
        
        function updateSpeed() {
            config.speed = parseFloat(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = config.speed.toFixed(1) + 'x';
        }
        
        function log(type, msg) {
            const c = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString('ko-KR', { hour12: false });
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${msg}`;
            c.appendChild(entry);
            c.scrollTop = c.scrollHeight;
        }
        
        function clearLog() { document.getElementById('logContainer').innerHTML = ''; }
        
        // ì„±ëŠ¥ ìµœì í™”: requestAnimationFrame + ì“°ë¡œí‹€ë§
        let lastUpdateTime = 0;
        function startUpdateLoop() {
            const updateStats = (time) => {
                // 100ms ì“°ë¡œí‹€ë§
                if (time - lastUpdateTime > 100) {
                    lastUpdateTime = time;
                    if (playerContainer) {
                        document.getElementById('playerPos').textContent = `${playerContainer.x | 0}, ${playerContainer.y | 0}`;
                        document.getElementById('enemyPos').textContent = `${enemyContainer.x | 0}, ${enemyContainer.y | 0}`;
                        document.getElementById('fpsValue').textContent = app.ticker.FPS | 0;
                    }
                }
                requestAnimationFrame(updateStats);
            };
            requestAnimationFrame(updateStats);
        }
        
        // ==================== ğŸ¬ íƒ€ì„ë¼ì¸ ì‹œìŠ¤í…œ (ê°œì„ ) ====================
        const Timeline = {
            scale: 0.25,
            duration: 2000,
            currentTime: 0,
            isPlaying: false,
            isLoop: false,
            isVisible: true,
            animId: null,
            playStartTime: 0,
            rafId: null,
            
            tracks: { player: [], enemy: [], vfx: [], camera: [], effects: [], damage: [] },
            
            // ì´ˆê¸°í™”
            init() {
                this.renderRuler();
                this.setupEvents();
            },
            
            // ì´ë²¤íŠ¸ ì„¤ì •
            setupEvents() {
                const content = document.getElementById('timelineContent');
                let isDragging = false;
                let startX = 0;
                let scrollLeft = 0;
                
                // ë“œë˜ê·¸ë¡œ ìŠ¤í¬ë¡¤
                content.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('timeline-keyframe')) return;
                    isDragging = true;
                    startX = e.pageX - content.offsetLeft;
                    scrollLeft = content.scrollLeft;
                });
                
                content.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const x = e.pageX - content.offsetLeft;
                    content.scrollLeft = scrollLeft - (x - startX);
                });
                
                content.addEventListener('mouseup', () => isDragging = false);
                content.addEventListener('mouseleave', () => isDragging = false);
                
                // í´ë¦­ìœ¼ë¡œ ì‹œê°„ ì´ë™
                content.addEventListener('click', (e) => {
                    if (e.target.classList.contains('timeline-keyframe')) return;
                    const rect = content.getBoundingClientRect();
                    const x = e.clientX - rect.left + content.scrollLeft;
                    this.seekTo(x / this.scale);
                });
                
                // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    if (e.code === 'Space') { e.preventDefault(); this.togglePlay(); }
                    if (e.code === 'Home') this.seekTo(0);
                    if (e.code === 'End') this.seekTo(this.duration);
                });
            },
            
            // ëˆˆê¸ˆì ë Œë”ë§ (ìµœì í™”: DocumentFragment ì‚¬ìš©)
            renderRuler() {
                const ruler = document.getElementById('timelineRuler');
                const fragment = document.createDocumentFragment();
                ruler.innerHTML = '';
                ruler.style.width = (this.duration * this.scale) + 'px';
                
                const step = this.scale < 0.15 ? 500 : this.scale < 0.3 ? 200 : 100;
                for (let t = 0; t <= this.duration; t += step) {
                    const mark = document.createElement('div');
                    mark.className = 'timeline-ruler-mark' + (t % 500 === 0 ? ' major' : '');
                    mark.style.left = (t * this.scale) + 'px';
                    if (t % 500 === 0) mark.textContent = (t / 1000).toFixed(1) + 's';
                    fragment.appendChild(mark);
                }
                ruler.appendChild(fragment);
            },
            
            // ì• ë‹ˆë©”ì´ì…˜ ë¶„ì„
            analyzeAnimation(animId) {
                const data = animCache.get(animId);
                if (!data) return;
                
                this.animId = animId;
                this.clear();
                document.getElementById('tlAnimName').textContent = animId;
                
                if (data.type === 'sequence' && data.steps) {
                    this.analyzeSequence(data);
                } else if (data.keyframes) {
                    this.duration = this.calcAnimDuration(data);
                    this.analyzeKeyframes(data, 0);
                }
                
                this.renderRuler();
                this.render();
            },
            
            // ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ ê³„ì‚° (duration ê¸°ë°˜!)
            calcAnimDuration(data) {
                if (!data.keyframes) return data.duration || 500;
                let total = 0;
                data.keyframes.forEach(kf => total += kf.duration || 0);
                return total || data.duration || 500;
            },
            
            // ì‹œí€€ìŠ¤ ë¶„ì„ (ê°œì„ : duration ê¸°ë°˜)
            analyzeSequence(data) {
                let currentTime = 0;
                
                data.steps.forEach((step, idx) => {
                    // ë”œë ˆì´ë§Œ ìˆëŠ” ê²½ìš°
                    if (step.delay && !step.anim) {
                        currentTime += step.delay;
                        return;
                    }
                    
                    if (step.anim) {
                        // ëœë¤ ë°°ì—´ì´ë©´ ì²« ë²ˆì§¸ ì‚¬ìš©
                        const animId = Array.isArray(step.anim) ? step.anim[0] : step.anim;
                        const animData = animCache.get(animId);
                        if (!animData) return;
                        
                        // ë”œë ˆì´ ì ìš©
                        if (step.delay) currentTime += step.delay;
                        
                        // í‚¤í”„ë ˆì„ ë¶„ì„
                        this.analyzeKeyframes(animData, currentTime, step);
                        
                        // ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ ê³„ì‚° (waitë©´ ëŒ€ê¸°)
                        if (step.wait) {
                            currentTime += this.calcAnimDuration(animData);
                        }
                    }
                    
                    // ì´ë²¤íŠ¸ (damage, buff ë“±)
                    if (step.damage) {
                        this.tracks.damage.push({
                            time: currentTime,
                            duration: 50,
                            label: `ğŸ’¥ ${step.damage}`,
                            type: 'damage',
                            data: step
                        });
                    }
                    if (step.event) {
                        this.tracks.damage.push({
                            time: currentTime,
                            duration: 50,
                            label: `ğŸ“¦ ${step.event.type}`,
                            type: 'damage',
                            data: step.event
                        });
                    }
                });
                
                this.duration = Math.max(this.duration, currentTime + 200);
            },
            
            // í‚¤í”„ë ˆì„ ë¶„ì„ (ê°œì„ : ëª¨ë“  ì†ì„± ë¶„ì„)
            analyzeKeyframes(data, startTime, stepData = {}) {
                const target = data.target || (data.id?.startsWith('enemy') ? 'enemy' : 'player');
                if (!data.keyframes) return;
                
                let accTime = startTime;
                
                data.keyframes.forEach((kf, idx) => {
                    const time = accTime;
                    const duration = kf.duration || 50;
                    
                    // ë©”ì¸ í‚¤í”„ë ˆì„ (player/enemy)
                    this.tracks[target].push({
                        time, duration,
                        label: this.getKeyframeLabel(kf, idx),
                        type: target,
                        data: kf
                    });
                    
                    // VFX
                    if (kf.vfx) {
                        this.tracks.vfx.push({
                            time, duration: 150,
                            label: kf.vfx,
                            type: 'vfx',
                            data: kf
                        });
                    }
                    
                    // ì¹´ë©”ë¼ (zoom, focus)
                    if (kf.camera) {
                        let label = 'ğŸ“·';
                        if (kf.camera.zoom) label += ` ${kf.camera.zoom}x`;
                        if (kf.camera.focus) label += ` â†’ ${kf.camera.focus}`;
                        this.tracks.camera.push({
                            time, duration: kf.camera.duration || 200,
                            label, type: 'camera',
                            data: kf.camera
                        });
                    }
                    
                    // ì´í™íŠ¸ (shake, hitstop, slowmo, color, shatter)
                    if (kf.shake) {
                        this.tracks.effects.push({
                            time, duration: 150,
                            label: `ğŸ“³ ${kf.shake}`,
                            type: 'shake',
                            data: kf
                        });
                    }
                    if (kf.hitstop) {
                        this.tracks.effects.push({
                            time, duration: kf.hitstop,
                            label: `â¸ ${kf.hitstop}ms`,
                            type: 'hitstop',
                            data: kf
                        });
                    }
                    if (kf.slowmo) {
                        const slowLabel = typeof kf.slowmo === 'object' ? `${kf.slowmo.scale}x` : kf.slowmo;
                        this.tracks.effects.push({
                            time, duration: 200,
                            label: `ğŸŒ ${slowLabel}`,
                            type: 'slowmo',
                            data: kf
                        });
                    }
                    if (kf.color) {
                        this.tracks.effects.push({
                            time, duration: 150,
                            label: `ğŸ¨ ${kf.color}`,
                            type: 'color',
                            data: kf
                        });
                    }
                    if (kf.shatter) {
                        const grid = kf.shatter.grid || 10;
                        this.tracks.effects.push({
                            time, duration: 200,
                            label: `ğŸ’ ${grid}Â²`,
                            type: 'shatter',
                            data: kf
                        });
                    }
                    
                    // ë‹¤ìŒ í‚¤í”„ë ˆì„ ì‹œê°„
                    accTime += duration;
                });
                
                // ìŠ¤í…ì—ì„œ damageê°€ ìˆìœ¼ë©´ ë§ˆì§€ë§‰ì— ì¶”ê°€
                if (stepData.damage && !data.keyframes.some(kf => kf.damage)) {
                    this.tracks.damage.push({
                        time: accTime - 50,
                        duration: 50,
                        label: `ğŸ’¥ ${stepData.damage}`,
                        type: 'damage',
                        data: stepData
                    });
                }
            },
            
            // í‚¤í”„ë ˆì„ ë ˆì´ë¸” (ê°„ê²°í•˜ê²Œ)
            getKeyframeLabel(kf, idx) {
                const parts = [];
                if (kf.x !== undefined) parts.push(`x${kf.x}`);
                if (kf.y !== undefined) parts.push(`y${kf.y}`);
                if (kf.scaleX !== undefined && kf.scaleX !== 1) parts.push(`s${kf.scaleX.toFixed(1)}`);
                if (kf.rotation !== undefined && kf.rotation !== 0) parts.push(`r${kf.rotation.toFixed(1)}`);
                if (kf.alpha !== undefined && kf.alpha !== 1) parts.push(`Î±${kf.alpha}`);
                if (kf.afterimage) parts.push('ğŸ‘¤');
                if (kf.dashToTarget) parts.push('ğŸ¯');
                return parts.length > 0 ? parts.join(' ') : `#${idx}`;
            },
            
            // ë Œë”ë§ (ìµœì í™”: batch DOM ì—…ë°ì´íŠ¸)
            render() {
                const lanes = document.getElementById('timelineLanes');
                lanes.style.width = (this.duration * this.scale + 50) + 'px';
                
                this.renderTrack('player', 'playerLane');
                this.renderTrack('enemy', 'enemyLane');
                this.renderTrack('vfx', 'vfxLane');
                this.renderTrack('camera', 'cameraLane');
                this.renderTrack('effects', 'effectsLane');
                this.renderTrack('damage', 'damageLane');
            },
            
            renderTrack(trackName, laneId) {
                const lane = document.getElementById(laneId);
                const fragment = document.createDocumentFragment();
                
                this.tracks[trackName].forEach(item => {
                    const el = document.createElement('div');
                    el.className = `timeline-keyframe ${item.type}`;
                    el.style.cssText = `left:${item.time * this.scale}px;width:${Math.max(item.duration * this.scale, 20)}px`;
                    el.textContent = item.label;
                    el.dataset.time = item.time;
                    el.addEventListener('click', (e) => { e.stopPropagation(); this.onKeyframeClick(item, e); });
                    el.addEventListener('mouseenter', (e) => this.showTooltip(item, e));
                    el.addEventListener('mouseleave', () => this.hideTooltip());
                    fragment.appendChild(el);
                });
                
                lane.innerHTML = '';
                lane.appendChild(fragment);
            },
            
            // íˆ´íŒ
            showTooltip(item, e) {
                const tt = document.getElementById('tlTooltip');
                let html = `<div class="tt-title">${item.label}</div>`;
                html += `<div class="tt-row"><span>Time:</span><span>${item.time}ms</span></div>`;
                html += `<div class="tt-row"><span>Duration:</span><span>${item.duration}ms</span></div>`;
                
                const d = item.data;
                if (d.x !== undefined) html += `<div class="tt-row"><span>X:</span><span>${d.x}</span></div>`;
                if (d.y !== undefined) html += `<div class="tt-row"><span>Y:</span><span>${d.y}</span></div>`;
                if (d.scaleX !== undefined) html += `<div class="tt-row"><span>ScaleX:</span><span>${d.scaleX}</span></div>`;
                if (d.scaleY !== undefined) html += `<div class="tt-row"><span>ScaleY:</span><span>${d.scaleY}</span></div>`;
                if (d.vfx) html += `<div class="tt-row"><span>VFX:</span><span>${d.vfx}</span></div>`;
                if (d.ease) html += `<div class="tt-row"><span>Ease:</span><span>${d.ease}</span></div>`;
                
                tt.innerHTML = html;
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 10) + 'px';
                tt.style.top = (e.clientY - tt.offsetHeight - 10) + 'px';
            },
            
            hideTooltip() {
                document.getElementById('tlTooltip').style.display = 'none';
            },
            
            onKeyframeClick(item, e) {
                log('info', `ğŸ¯ ${item.type}: ${item.label} @ ${item.time}ms`);
                this.seekTo(item.time);
            },
            
            // í”Œë ˆì´í—¤ë“œ ì„¤ì •
            setPlayhead(time) {
                this.currentTime = Math.max(0, Math.min(time, this.duration));
                const playhead = document.getElementById('timelinePlayhead');
                playhead.style.left = (this.currentTime * this.scale) + 'px';
                document.getElementById('timelineTime').textContent = 
                    `${(this.currentTime / 1000).toFixed(2)}s / ${(this.duration / 1000).toFixed(2)}s`;
                
                // ìë™ ìŠ¤í¬ë¡¤
                const content = document.getElementById('timelineContent');
                const playheadX = this.currentTime * this.scale;
                if (playheadX > content.scrollLeft + content.clientWidth - 50) {
                    content.scrollLeft = playheadX - 100;
                } else if (playheadX < content.scrollLeft + 50) {
                    content.scrollLeft = Math.max(0, playheadX - 100);
                }
            },
            
            // ì‹œê°„ ì´ë™
            seekTo(time) {
                this.setPlayhead(time);
            },
            
            // ì¬ìƒ/ì •ì§€ í† ê¸€
            togglePlay() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            },
            
            // ì¬ìƒ
            play() {
                if (!this.animId) return;
                this.isPlaying = true;
                document.getElementById('tlPlayBtn').textContent = 'â¸';
                document.getElementById('tlPlayBtn').classList.add('active');
                
                // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
                playAnimation(this.animId, true);
                
                // í”Œë ˆì´í—¤ë“œ ë™ê¸°í™”
                this.playStartTime = performance.now();
                const updateLoop = () => {
                    if (!this.isPlaying) return;
                    const elapsed = (performance.now() - this.playStartTime) / config.speed;
                    this.setPlayhead(elapsed);
                    
                    if (elapsed >= this.duration) {
                        if (this.isLoop) {
                            this.playStartTime = performance.now();
                            playAnimation(this.animId, true);
                        } else {
                            this.stop();
                        }
                    } else {
                        this.rafId = requestAnimationFrame(updateLoop);
                    }
                };
                this.rafId = requestAnimationFrame(updateLoop);
            },
            
            // ì¼ì‹œì •ì§€
            pause() {
                this.isPlaying = false;
                if (this.rafId) cancelAnimationFrame(this.rafId);
                document.getElementById('tlPlayBtn').textContent = 'â–¶';
                document.getElementById('tlPlayBtn').classList.remove('active');
            },
            
            // ì •ì§€
            stop() {
                this.pause();
                this.setPlayhead(0);
                resetCharacters();
            },
            
            // ë£¨í”„ í† ê¸€
            toggleLoop() {
                this.isLoop = !this.isLoop;
                document.getElementById('tlLoopBtn').classList.toggle('active', this.isLoop);
            },
            
            // ì¤Œ
            zoom(delta) {
                this.scale = Math.max(0.05, Math.min(1, this.scale + delta));
                this.renderRuler();
                this.render();
                this.setPlayhead(this.currentTime);
            },
            
            // íŒ¨ë„ í† ê¸€
            toggle() {
                this.isVisible = !this.isVisible;
                const panel = document.getElementById('timelinePanel');
                const main = document.querySelector('.main-container');
                const btn = document.getElementById('tlToggleBtn');
                
                panel.classList.toggle('collapsed', !this.isVisible);
                main.classList.toggle('timeline-collapsed', !this.isVisible);
                btn.textContent = this.isVisible ? 'â–¼' : 'â–²';
            },
            
            // í´ë¦¬ì–´
            clear() {
                this.tracks = { player: [], enemy: [], vfx: [], camera: [], effects: [], damage: [] };
                this.duration = 2000;
                this.setPlayhead(0);
            }
        };
        
        // playAnimation ë˜í•‘ (íƒ€ì„ë¼ì¸ ì—°ë™)
        const _originalPlayAnimation = playAnimation;
        playAnimation = async function(id, skipReset) {
            Timeline.analyzeAnimation(id);
            return _originalPlayAnimation(id, skipReset);
        };
        
        // íƒ€ì„ë¼ì¸ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => Timeline.init(), 100);
        });
    </script>
</body>
</html>
