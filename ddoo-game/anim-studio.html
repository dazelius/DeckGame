<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé¨ Animation Studio - DDOO Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --bg-card: #1a1a25;
            --accent: #ff6b35;
            --accent-glow: rgba(255, 107, 53, 0.3);
            --text: #e8e8e8;
            --text-dim: #888;
            --border: #2a2a3a;
            --success: #4ade80;
            --danger: #f87171;
            --info: #60a5fa;
        }
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }
        
        .app {
            display: grid;
            grid-template-columns: 320px 1fr 300px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 1px;
            background: var(--border);
        }
        
        /* Ìó§Îçî */
        .header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, var(--bg-panel), #1a1a28);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            border-bottom: 1px solid var(--border);
        }
        
        .header h1 {
            font-size: 1.4rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent), #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .header-actions {
            display: flex;
            gap: 10px;
        }
        
        /* ÏôºÏ™Ω Ìå®ÎÑê - Ïª®Ìä∏Î°§ */
        .left-panel {
            background: var(--bg-panel);
            overflow-y: auto;
            padding: 16px;
        }
        
        .panel-section {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid var(--border);
        }
        
        .panel-section h3 {
            font-size: 0.9rem;
            color: var(--accent);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .form-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .form-row label {
            width: 80px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        
        .form-row input, .form-row select {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.9rem;
        }
        
        .form-row input:focus, .form-row select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-glow);
        }
        
        .form-row input[type="range"] {
            padding: 0;
        }
        
        .range-value {
            width: 50px;
            text-align: right;
            font-size: 0.85rem;
            color: var(--info);
        }
        
        /* Î≤ÑÌäº */
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent), #ff8c5a);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px var(--accent-glow);
        }
        
        .btn-secondary {
            background: var(--bg-card);
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: var(--bg-panel);
            border-color: var(--accent);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, var(--danger), #ef4444);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, var(--success), #22c55e);
            color: white;
        }
        
        .btn-sm {
            padding: 6px 10px;
            font-size: 0.8rem;
        }
        
        .btn-block {
            width: 100%;
            justify-content: center;
        }
        
        /* Î©îÏù∏ Ï∫îÎ≤ÑÏä§ ÏòÅÏó≠ */
        .main-area {
            background: var(--bg-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #canvas-container {
            position: relative;
        }
        
        #game-canvas {
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
        }
        
        /* Ïò§Î•∏Ï™Ω Ìå®ÎÑê - Î°úÍ∑∏ & ÌîÑÎ¶¨ÏÖã */
        .right-panel {
            background: var(--bg-panel);
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }
        
        /* Ïï°ÏÖò Í∑∏Î¶¨Îìú */
        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        /* ÌîÑÎ¶¨ÏÖã Î¶¨Ïä§Ìä∏ */
        .preset-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .preset-item {
            padding: 10px 12px;
            background: var(--bg-dark);
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .preset-item:hover {
            background: var(--bg-card);
            border-left: 3px solid var(--accent);
        }
        
        .preset-item .name {
            font-size: 0.9rem;
        }
        
        .preset-item .type {
            font-size: 0.75rem;
            color: var(--text-dim);
            background: var(--bg-panel);
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        /* Î°úÍ∑∏ ÏòÅÏó≠ */
        .log-area {
            flex: 1;
            background: var(--bg-dark);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Fira Code', monospace;
            font-size: 0.8rem;
            overflow-y: auto;
            max-height: 300px;
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid var(--border);
            color: var(--text-dim);
        }
        
        .log-entry.info { color: var(--info); }
        .log-entry.success { color: var(--success); }
        .log-entry.error { color: var(--danger); }
        .log-entry.action { color: var(--accent); }
        
        /* Ïú†Îãõ ÏÑ†ÌÉù */
        .unit-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .unit-chip {
            padding: 8px 14px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        
        .unit-chip:hover {
            border-color: var(--accent);
        }
        
        .unit-chip.selected {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        /* ÌÉÄÏûÑÎùºÏù∏ ÌîÑÎ¶¨Î∑∞ */
        .timeline {
            background: var(--bg-dark);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }
        
        .timeline-bar {
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--success));
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s;
        }
        
        .timeline-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        
        /* Ìà¥ÌåÅ */
        .tooltip {
            position: absolute;
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        /* Î°úÎî© */
        .loading {
            position: fixed;
            inset: 0;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 16px;
            color: var(--text-dim);
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Animation Studio...</div>
    </div>
    
    <div class="app">
        <!-- Ìó§Îçî -->
        <header class="header">
            <h1>üé¨ Animation Studio</h1>
            <div class="header-actions">
                <button class="btn btn-secondary" onclick="AnimStudio.reset()">üîÑ Reset</button>
                <button class="btn btn-primary" onclick="AnimStudio.exportConfig()">üíæ Export</button>
            </div>
        </header>
        
        <!-- ÏôºÏ™Ω Ìå®ÎÑê -->
        <aside class="left-panel">
            <!-- Ïú†Îãõ Ïä§Ìè∞ -->
            <div class="panel-section">
                <h3>üë§ Units</h3>
                <div class="form-row">
                    <label>Player</label>
                    <select id="player-sprite">
                        <option value="hero.png">Hero</option>
                        <option value="knight.png">Knight</option>
                        <option value="archer.png">Archer</option>
                    </select>
                </div>
                <div class="form-row">
                    <label>Enemy</label>
                    <select id="enemy-sprite">
                        <option value="goblin.png">Goblin</option>
                        <option value="goblinshield.png">Goblin Shield</option>
                        <option value="orc.png">Orc</option>
                        <option value="skeleton.png">Skeleton</option>
                        <option value="slime.png">Slime</option>
                    </select>
                </div>
                <div class="action-grid">
                    <button class="btn btn-secondary btn-sm" onclick="AnimStudio.spawnPlayer()">+ Player</button>
                    <button class="btn btn-danger btn-sm" onclick="AnimStudio.spawnEnemy()">+ Enemy</button>
                </div>
            </div>
            
            <!-- Ïï°ÏÖò ÏÑ†ÌÉù -->
            <div class="panel-section">
                <h3>‚öîÔ∏è Actions</h3>
                <div class="form-row">
                    <label>Type</label>
                    <select id="action-type" onchange="AnimStudio.onActionTypeChange()">
                        <option value="dash">Dash To Target</option>
                        <option value="attack">Attack Motion</option>
                        <option value="hit">Hit Reaction</option>
                        <option value="skill">Skill Animation</option>
                        <option value="vfx">VFX Only</option>
                    </select>
                </div>
                <div class="form-row" id="skill-select-row" style="display:none;">
                    <label>Skill</label>
                    <select id="skill-type">
                        <option value="strike">Strike</option>
                        <option value="bash">Bash</option>
                        <option value="cleave">Cleave</option>
                        <option value="flurry">Flurry</option>
                    </select>
                </div>
                <div class="form-row" id="vfx-select-row" style="display:none;">
                    <label>VFX</label>
                    <select id="vfx-type">
                        <option value="hit">Hit Spark</option>
                        <option value="slash">Slash</option>
                        <option value="fire">Fire</option>
                        <option value="lightning">Lightning</option>
                        <option value="heal">Heal</option>
                        <option value="block">Block</option>
                    </select>
                </div>
            </div>
            
            <!-- ÌååÎùºÎØ∏ÌÑ∞ -->
            <div class="panel-section">
                <h3>‚öôÔ∏è Parameters</h3>
                <div class="form-row">
                    <label>Duration</label>
                    <input type="range" id="param-duration" min="0.1" max="1.5" step="0.05" value="0.28" oninput="AnimStudio.updateParam('duration')">
                    <span class="range-value" id="duration-val">0.28s</span>
                </div>
                <div class="form-row">
                    <label>Ease</label>
                    <select id="param-ease">
                        <option value="power2.inOut">power2.inOut (Í∞ÄÏÜç‚ÜíÍ∞êÏÜç)</option>
                        <option value="power2.in">power2.in (Ï≤úÏ≤úÌûà‚ÜíÎπ†Î•¥Í≤å)</option>
                        <option value="power2.out">power2.out (Îπ†Î•¥Í≤å‚ÜíÏ≤úÏ≤úÌûà)</option>
                        <option value="power4.out">power4.out (Í∞ïÌïú Í∞êÏÜç)</option>
                        <option value="back.out(1.5)">back.out (Ïò§Î≤ÑÏäàÌä∏)</option>
                        <option value="elastic.out(1,0.3)">elastic (ÌÉÑÏÑ±)</option>
                        <option value="linear">linear</option>
                    </select>
                </div>
                <div class="form-row">
                    <label>Distance</label>
                    <input type="range" id="param-distance" min="50" max="300" step="10" value="150" oninput="AnimStudio.updateParam('distance')">
                    <span class="range-value" id="distance-val">150px</span>
                </div>
                <div class="form-row">
                    <label>Scale</label>
                    <input type="range" id="param-scale" min="0.5" max="2" step="0.1" value="1" oninput="AnimStudio.updateParam('scale')">
                    <span class="range-value" id="scale-val">1.0x</span>
                </div>
            </div>
            
            <!-- Ïã§Ìñâ -->
            <div class="panel-section">
                <h3>‚ñ∂Ô∏è Execute</h3>
                <button class="btn btn-primary btn-block" onclick="AnimStudio.execute()">
                    ‚ñ∂Ô∏è Play Animation
                </button>
                <div class="timeline">
                    <div class="timeline-bar">
                        <div class="timeline-progress" id="timeline-progress"></div>
                    </div>
                    <div class="timeline-markers">
                        <span>0s</span>
                        <span id="timeline-total">0.5s</span>
                    </div>
                </div>
            </div>
        </aside>
        
        <!-- Î©îÏù∏ Ï∫îÎ≤ÑÏä§ -->
        <main class="main-area">
            <div id="canvas-container"></div>
        </main>
        
        <!-- Ïò§Î•∏Ï™Ω Ìå®ÎÑê -->
        <aside class="right-panel">
            <!-- ÌîÑÎ¶¨ÏÖã -->
            <div class="panel-section">
                <h3>üì¶ Presets</h3>
                <div class="preset-list" id="preset-list">
                    <div class="preset-item" onclick="AnimStudio.loadPreset('dashFast')">
                        <span class="name">Îπ†Î•∏ ÎåÄÏãú</span>
                        <span class="type">Dash</span>
                    </div>
                    <div class="preset-item" onclick="AnimStudio.loadPreset('dashSmooth')">
                        <span class="name">Î∂ÄÎìúÎü¨Ïö¥ ÎåÄÏãú</span>
                        <span class="type">Dash</span>
                    </div>
                    <div class="preset-item" onclick="AnimStudio.loadPreset('heavyAttack')">
                        <span class="name">Í∞ïÌÉÄ</span>
                        <span class="type">Attack</span>
                    </div>
                    <div class="preset-item" onclick="AnimStudio.loadPreset('quickStrike')">
                        <span class="name">ÏÜçÍ≥µ</span>
                        <span class="type">Attack</span>
                    </div>
                    <div class="preset-item" onclick="AnimStudio.loadPreset('hitReact')">
                        <span class="name">ÌîºÍ≤© Î∞òÏùë</span>
                        <span class="type">Hit</span>
                    </div>
                </div>
                <button class="btn btn-secondary btn-sm btn-block" onclick="AnimStudio.savePreset()" style="margin-top:10px;">
                    üíæ Save Current as Preset
                </button>
            </div>
            
            <!-- Î°úÍ∑∏ -->
            <div class="panel-section" style="flex:1; display:flex; flex-direction:column;">
                <h3>üìã Log</h3>
                <div class="log-area" id="log-area">
                    <div class="log-entry info">[Studio] Ready</div>
                </div>
                <button class="btn btn-secondary btn-sm" onclick="AnimStudio.clearLog()" style="margin-top:8px;">
                    üóëÔ∏è Clear Log
                </button>
            </div>
        </aside>
    </div>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.0.0/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <script>
        // =====================================================
        // Animation Studio - Ïó∞Ï∂ú ÏãúÎÆ¨Î†àÏù¥ÏÖò Ìà¥
        // =====================================================
        
        const AnimStudio = {
            app: null,
            container: null,
            player: null,
            enemy: null,
            isPlaying: false,
            
            // ÌîÑÎ¶¨ÏÖã
            presets: {
                dashFast: { duration: 0.15, ease: 'power4.out', distance: 150 },
                dashSmooth: { duration: 0.35, ease: 'power2.inOut', distance: 150 },
                heavyAttack: { duration: 0.4, ease: 'back.out(1.5)', distance: 120 },
                quickStrike: { duration: 0.12, ease: 'power2.out', distance: 100 },
                hitReact: { duration: 0.15, ease: 'elastic.out(1,0.3)', distance: 30 }
            },
            
            // ==========================================
            // Ï¥àÍ∏∞Ìôî
            // ==========================================
            async init() {
                this.log('Initializing PIXI...', 'info');
                
                // PIXI Ïï± ÏÉùÏÑ±
                this.app = new PIXI.Application();
                await this.app.init({
                    width: 800,
                    height: 500,
                    backgroundColor: 0x1a1a2e,
                    antialias: true
                });
                
                document.getElementById('canvas-container').appendChild(this.app.canvas);
                this.app.canvas.id = 'game-canvas';
                
                // Î©îÏù∏ Ïª®ÌÖåÏù¥ÎÑà
                this.container = new PIXI.Container();
                this.container.sortableChildren = true;
                this.app.stage.addChild(this.container);
                
                // Í∑∏Î¶¨Îìú Í∑∏Î¶¨Í∏∞
                this.drawGrid();
                
                // Í∏∞Î≥∏ Ïú†Îãõ Ïä§Ìè∞
                await this.spawnPlayer();
                await this.spawnEnemy();
                
                // Î°úÎî© ÏôÑÎ£å
                document.getElementById('loading').style.display = 'none';
                this.log('Studio ready!', 'success');
            },
            
            // ==========================================
            // Í∑∏Î¶¨Îìú Í∑∏Î¶¨Í∏∞
            // ==========================================
            drawGrid() {
                const grid = new PIXI.Graphics();
                
                // Î∞∞Í≤Ω
                grid.rect(0, 0, 800, 500);
                grid.fill({ color: 0x0f0f18 });
                
                // Í∑∏Î¶¨Îìú ÎùºÏù∏
                grid.stroke({ width: 1, color: 0x2a2a3a, alpha: 0.5 });
                for (let x = 0; x <= 800; x += 50) {
                    grid.moveTo(x, 0);
                    grid.lineTo(x, 500);
                }
                for (let y = 0; y <= 500; y += 50) {
                    grid.moveTo(0, y);
                    grid.lineTo(800, y);
                }
                grid.stroke();
                
                // Ï§ëÏïôÏÑ†
                grid.stroke({ width: 2, color: 0x444455 });
                grid.moveTo(400, 0);
                grid.lineTo(400, 500);
                grid.stroke();
                
                // Î∞îÎã• ÎùºÏù∏
                grid.stroke({ width: 3, color: 0x3a3a4a });
                grid.moveTo(0, 380);
                grid.lineTo(800, 380);
                grid.stroke();
                
                this.container.addChild(grid);
            },
            
            // ==========================================
            // Ïú†Îãõ Ïä§Ìè∞
            // ==========================================
            async spawnPlayer() {
                if (this.player) {
                    this.player.destroy();
                }
                
                const spriteName = document.getElementById('player-sprite').value;
                
                try {
                    const texture = await PIXI.Assets.load(`image/${spriteName}`);
                    const sprite = new PIXI.Sprite(texture);
                    sprite.anchor.set(0.5, 1);
                    sprite.x = 200;
                    sprite.y = 380;
                    sprite.scale.set(0.4);
                    sprite.zIndex = 10;
                    
                    // Ïª®ÌÖåÏù¥ÎÑàÎ°ú Í∞êÏã∏Í∏∞
                    const container = new PIXI.Container();
                    container.x = sprite.x;
                    container.y = sprite.y;
                    container.zIndex = 10;
                    sprite.x = 0;
                    sprite.y = 0;
                    container.addChild(sprite);
                    
                    this.container.addChild(container);
                    this.player = { container, sprite, baseScale: 0.4, baseX: 200, baseY: 380 };
                    
                    this.log(`Player spawned: ${spriteName}`, 'success');
                } catch (e) {
                    this.log(`Failed to load: ${spriteName}`, 'error');
                    // ÎåÄÏ≤¥ Ïõê ÏÉùÏÑ±
                    const circle = new PIXI.Graphics();
                    circle.circle(0, -40, 30);
                    circle.fill({ color: 0x4488ff });
                    
                    const container = new PIXI.Container();
                    container.x = 200;
                    container.y = 380;
                    container.zIndex = 10;
                    container.addChild(circle);
                    
                    this.container.addChild(container);
                    this.player = { container, sprite: circle, baseScale: 1, baseX: 200, baseY: 380 };
                }
            },
            
            async spawnEnemy() {
                if (this.enemy) {
                    this.enemy.destroy();
                }
                
                const spriteName = document.getElementById('enemy-sprite').value;
                
                try {
                    const texture = await PIXI.Assets.load(`image/${spriteName}`);
                    const sprite = new PIXI.Sprite(texture);
                    sprite.anchor.set(0.5, 1);
                    sprite.x = 600;
                    sprite.y = 380;
                    sprite.scale.set(-0.4, 0.4);  // Ï¢åÏö∞ Î∞òÏ†Ñ
                    sprite.zIndex = 10;
                    
                    // Ïª®ÌÖåÏù¥ÎÑàÎ°ú Í∞êÏã∏Í∏∞
                    const container = new PIXI.Container();
                    container.x = sprite.x;
                    container.y = sprite.y;
                    container.zIndex = 10;
                    sprite.x = 0;
                    sprite.y = 0;
                    container.addChild(sprite);
                    
                    this.container.addChild(container);
                    this.enemy = { container, sprite, baseScale: 0.4, baseX: 600, baseY: 380 };
                    
                    this.log(`Enemy spawned: ${spriteName}`, 'success');
                } catch (e) {
                    this.log(`Failed to load: ${spriteName}`, 'error');
                    // ÎåÄÏ≤¥ Ïõê ÏÉùÏÑ±
                    const circle = new PIXI.Graphics();
                    circle.circle(0, -40, 30);
                    circle.fill({ color: 0xff4444 });
                    
                    const container = new PIXI.Container();
                    container.x = 600;
                    container.y = 380;
                    container.zIndex = 10;
                    container.addChild(circle);
                    
                    this.container.addChild(container);
                    this.enemy = { container, sprite: circle, baseScale: 1, baseX: 600, baseY: 380 };
                }
            },
            
            // ==========================================
            // ÌååÎùºÎØ∏ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            // ==========================================
            getParams() {
                return {
                    duration: parseFloat(document.getElementById('param-duration').value),
                    ease: document.getElementById('param-ease').value,
                    distance: parseInt(document.getElementById('param-distance').value),
                    scale: parseFloat(document.getElementById('param-scale').value),
                    actionType: document.getElementById('action-type').value,
                    skillType: document.getElementById('skill-type').value,
                    vfxType: document.getElementById('vfx-type').value
                };
            },
            
            updateParam(name) {
                const el = document.getElementById(`param-${name}`);
                const valEl = document.getElementById(`${name}-val`);
                if (name === 'duration') valEl.textContent = el.value + 's';
                else if (name === 'distance') valEl.textContent = el.value + 'px';
                else if (name === 'scale') valEl.textContent = el.value + 'x';
                
                // ÌÉÄÏûÑÎùºÏù∏ ÏóÖÎç∞Ïù¥Ìä∏
                document.getElementById('timeline-total').textContent = 
                    (parseFloat(document.getElementById('param-duration').value) + 0.3).toFixed(2) + 's';
            },
            
            // ==========================================
            // Ïï°ÏÖò Ïã§Ìñâ
            // ==========================================
            async execute() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                
                const params = this.getParams();
                this.log(`Executing: ${params.actionType} (${params.duration}s, ${params.ease})`, 'action');
                
                // ÌÉÄÏûÑÎùºÏù∏ ÏãúÏûë
                this.startTimeline(params.duration + 0.3);
                
                // ÏúÑÏπò Ï¥àÍ∏∞Ìôî
                this.resetPositions();
                await this.wait(100);
                
                switch (params.actionType) {
                    case 'dash':
                        await this.executeDash(params);
                        break;
                    case 'attack':
                        await this.executeAttack(params);
                        break;
                    case 'hit':
                        await this.executeHit(params);
                        break;
                    case 'skill':
                        await this.executeSkill(params);
                        break;
                    case 'vfx':
                        await this.executeVFX(params);
                        break;
                }
                
                // Î≥µÍ∑Ä
                await this.wait(200);
                await this.returnToBase();
                
                this.isPlaying = false;
                this.log('Animation complete', 'success');
            },
            
            // ==========================================
            // ÎåÄÏãú Ïã§Ìñâ
            // ==========================================
            async executeDash(params) {
                const { container, sprite, baseScale } = this.player;
                const target = this.enemy;
                const targetX = target.container.x - params.distance;
                
                // ÏõÖÌÅ¨Î¶¨Í∏∞
                await new Promise(resolve => {
                    gsap.to(container, { x: container.x - 20, duration: 0.1, ease: 'power2.in', onComplete: resolve });
                    gsap.to(sprite.scale, { x: baseScale * 0.85, y: baseScale * 1.15, duration: 0.1 });
                });
                
                // ÎåÄÏãú
                await new Promise(resolve => {
                    gsap.to(container, { 
                        x: targetX, 
                        duration: params.duration, 
                        ease: params.ease,
                        onComplete: resolve 
                    });
                    gsap.to(sprite.scale, { 
                        x: baseScale * 1.1, 
                        y: baseScale * 0.9, 
                        duration: params.duration,
                        ease: params.ease
                    });
                });
                
                // Ï∞©ÏßÄ
                await new Promise(resolve => {
                    gsap.to(sprite.scale, { x: baseScale, y: baseScale, duration: 0.1, ease: 'power2.out', onComplete: resolve });
                });
            },
            
            // ==========================================
            // Í≥µÍ≤© Ïã§Ìñâ
            // ==========================================
            async executeAttack(params) {
                await this.executeDash(params);
                
                const { container, sprite, baseScale } = this.player;
                
                // Í≥µÍ≤© Î™®ÏÖò
                await new Promise(resolve => {
                    gsap.to(container, { x: container.x + 30, duration: 0.08, ease: 'power4.out' });
                    gsap.to(sprite.scale, { x: baseScale * 1.2, y: baseScale * 0.8, duration: 0.08, onComplete: resolve });
                });
                
                // ÌûàÌä∏ Ïù¥ÌéôÌä∏
                this.createHitEffect(this.enemy.container.x - 30, this.enemy.container.y - 50);
                
                // Ï†Å ÌûàÌä∏ Î∞òÏùë
                gsap.to(this.enemy.container, { x: this.enemy.container.x + 20, duration: 0.1, ease: 'power2.out' });
                gsap.to(this.enemy.sprite, { tint: 0xff8888, duration: 0.1 });
                gsap.to(this.enemy.sprite, { tint: 0xffffff, duration: 0.2, delay: 0.1 });
                
                await new Promise(resolve => {
                    gsap.to(sprite.scale, { x: baseScale, y: baseScale, duration: 0.1, onComplete: resolve });
                });
            },
            
            // ==========================================
            // ÌûàÌä∏ Î∞òÏùë Ïã§Ìñâ
            // ==========================================
            async executeHit(params) {
                const { container, sprite } = this.enemy;
                const originalX = container.x;
                
                // ÌûàÌä∏ Î∞òÏùë
                await new Promise(resolve => {
                    gsap.to(container, { 
                        x: originalX + params.distance * 0.2, 
                        duration: params.duration * 0.3, 
                        ease: 'power2.out'
                    });
                    gsap.to(sprite, { tint: 0xff4444, duration: 0.05 });
                    gsap.to(sprite, { tint: 0xffffff, duration: params.duration, delay: 0.05, onComplete: resolve });
                });
                
                // Î≥µÍ∑Ä
                await new Promise(resolve => {
                    gsap.to(container, { x: originalX, duration: params.duration * 0.7, ease: params.ease, onComplete: resolve });
                });
            },
            
            // ==========================================
            // Ïä§ÌÇ¨ Ïã§Ìñâ
            // ==========================================
            async executeSkill(params) {
                // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Í≥µÍ≤©Í≥º ÎèôÏùº, Ïä§ÌÇ¨Î≥ÑÎ°ú ÌôïÏû• Í∞ÄÎä•
                await this.executeAttack(params);
            },
            
            // ==========================================
            // VFX Ïã§Ìñâ
            // ==========================================
            async executeVFX(params) {
                const x = 400;
                const y = 300;
                
                switch (params.vfxType) {
                    case 'hit':
                        this.createHitEffect(x, y);
                        break;
                    case 'slash':
                        this.createSlashEffect(x, y);
                        break;
                    case 'fire':
                        this.createFireEffect(x, y);
                        break;
                    default:
                        this.createHitEffect(x, y);
                }
                
                await this.wait(500);
            },
            
            // ==========================================
            // Ïù¥ÌéôÌä∏ ÏÉùÏÑ±
            // ==========================================
            createHitEffect(x, y) {
                const particles = [];
                const NUM_PARTICLES = 12;
                
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    const particle = new PIXI.Graphics();
                    const angle = (i / NUM_PARTICLES) * Math.PI * 2;
                    particle.x = x;
                    particle.y = y;
                    particle.zIndex = 100;
                    
                    const size = 3 + Math.random() * 5;
                    particle.circle(0, 0, size);
                    particle.fill({ color: 0xffcc44, alpha: 1 });
                    
                    this.container.addChild(particle);
                    
                    const distance = 30 + Math.random() * 40;
                    gsap.to(particle, {
                        x: x + Math.cos(angle) * distance,
                        y: y + Math.sin(angle) * distance,
                        alpha: 0,
                        duration: 0.3 + Math.random() * 0.2,
                        ease: 'power2.out',
                        onComplete: () => particle.destroy()
                    });
                }
                
                // ÌîåÎûòÏãú
                const flash = new PIXI.Graphics();
                flash.circle(0, 0, 30);
                flash.fill({ color: 0xffffff, alpha: 0.8 });
                flash.x = x;
                flash.y = y;
                flash.zIndex = 99;
                this.container.addChild(flash);
                
                gsap.to(flash, {
                    alpha: 0,
                    duration: 0.15,
                    onComplete: () => flash.destroy()
                });
                gsap.to(flash.scale, { x: 2, y: 2, duration: 0.15 });
            },
            
            createSlashEffect(x, y) {
                const slash = new PIXI.Graphics();
                slash.x = x;
                slash.y = y;
                slash.zIndex = 100;
                
                // Ïä¨ÎûòÏãú ÎùºÏù∏
                slash.moveTo(-40, 30);
                slash.lineTo(40, -30);
                slash.stroke({ width: 6, color: 0xffffff, alpha: 0.9 });
                
                this.container.addChild(slash);
                
                gsap.to(slash, {
                    alpha: 0,
                    duration: 0.3,
                    onComplete: () => slash.destroy()
                });
                gsap.to(slash.scale, { x: 1.5, y: 1.5, duration: 0.3 });
            },
            
            createFireEffect(x, y) {
                for (let i = 0; i < 20; i++) {
                    const particle = new PIXI.Graphics();
                    particle.x = x + (Math.random() - 0.5) * 40;
                    particle.y = y;
                    particle.zIndex = 100;
                    
                    const size = 5 + Math.random() * 10;
                    const colors = [0xff4400, 0xff8800, 0xffcc00];
                    particle.circle(0, 0, size);
                    particle.fill({ color: colors[Math.floor(Math.random() * 3)] });
                    
                    this.container.addChild(particle);
                    
                    gsap.to(particle, {
                        y: y - 50 - Math.random() * 50,
                        alpha: 0,
                        duration: 0.5 + Math.random() * 0.3,
                        ease: 'power2.out',
                        delay: i * 0.02,
                        onComplete: () => particle.destroy()
                    });
                    gsap.to(particle.scale, {
                        x: 0,
                        y: 0,
                        duration: 0.5 + Math.random() * 0.3,
                        delay: i * 0.02
                    });
                }
            },
            
            // ==========================================
            // Ïú†Ìã∏Î¶¨Ìã∞
            // ==========================================
            resetPositions() {
                if (this.player) {
                    gsap.killTweensOf(this.player.container);
                    gsap.killTweensOf(this.player.sprite);
                    gsap.killTweensOf(this.player.sprite.scale);
                    this.player.container.x = this.player.baseX;
                    this.player.container.y = this.player.baseY;
                    this.player.sprite.scale.set(this.player.baseScale);
                }
                if (this.enemy) {
                    gsap.killTweensOf(this.enemy.container);
                    gsap.killTweensOf(this.enemy.sprite);
                    this.enemy.container.x = this.enemy.baseX;
                    this.enemy.container.y = this.enemy.baseY;
                    this.enemy.sprite.scale.set(-this.enemy.baseScale, this.enemy.baseScale);
                    this.enemy.sprite.tint = 0xffffff;
                }
            },
            
            async returnToBase() {
                const promises = [];
                
                if (this.player) {
                    promises.push(new Promise(resolve => {
                        gsap.to(this.player.container, { 
                            x: this.player.baseX, 
                            y: this.player.baseY, 
                            duration: 0.2, 
                            ease: 'power2.out',
                            onComplete: resolve 
                        });
                    }));
                }
                if (this.enemy) {
                    promises.push(new Promise(resolve => {
                        gsap.to(this.enemy.container, { 
                            x: this.enemy.baseX, 
                            duration: 0.2, 
                            ease: 'power2.out',
                            onComplete: resolve 
                        });
                    }));
                }
                
                await Promise.all(promises);
            },
            
            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            
            // ==========================================
            // ÌÉÄÏûÑÎùºÏù∏
            // ==========================================
            startTimeline(totalDuration) {
                const progress = document.getElementById('timeline-progress');
                progress.style.width = '0%';
                
                gsap.to({ val: 0 }, {
                    val: 100,
                    duration: totalDuration,
                    ease: 'linear',
                    onUpdate: function() {
                        progress.style.width = this.targets()[0].val + '%';
                    }
                });
            },
            
            // ==========================================
            // ÌîÑÎ¶¨ÏÖã
            // ==========================================
            loadPreset(name) {
                const preset = this.presets[name];
                if (!preset) return;
                
                document.getElementById('param-duration').value = preset.duration;
                document.getElementById('param-ease').value = preset.ease || 'power2.inOut';
                document.getElementById('param-distance').value = preset.distance;
                
                this.updateParam('duration');
                this.updateParam('distance');
                
                this.log(`Loaded preset: ${name}`, 'info');
            },
            
            savePreset() {
                const params = this.getParams();
                const name = prompt('Preset name:');
                if (!name) return;
                
                this.presets[name] = {
                    duration: params.duration,
                    ease: params.ease,
                    distance: params.distance
                };
                
                this.log(`Saved preset: ${name}`, 'success');
            },
            
            // ==========================================
            // UI Ïù¥Î≤§Ìä∏
            // ==========================================
            onActionTypeChange() {
                const actionType = document.getElementById('action-type').value;
                document.getElementById('skill-select-row').style.display = actionType === 'skill' ? 'flex' : 'none';
                document.getElementById('vfx-select-row').style.display = actionType === 'vfx' ? 'flex' : 'none';
            },
            
            reset() {
                this.resetPositions();
                this.log('Reset complete', 'info');
            },
            
            exportConfig() {
                const params = this.getParams();
                const config = JSON.stringify(params, null, 2);
                
                navigator.clipboard.writeText(config).then(() => {
                    this.log('Config copied to clipboard!', 'success');
                });
                
                console.log('Exported config:', config);
            },
            
            // ==========================================
            // Î°úÍ∑∏
            // ==========================================
            log(message, type = '') {
                const logArea = document.getElementById('log-area');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logArea.appendChild(entry);
                logArea.scrollTop = logArea.scrollHeight;
            },
            
            clearLog() {
                document.getElementById('log-area').innerHTML = '<div class="log-entry info">[Studio] Log cleared</div>';
            }
        };
        
        // ÏãúÏûë
        AnimStudio.init();
    </script>
</body>
</html>
